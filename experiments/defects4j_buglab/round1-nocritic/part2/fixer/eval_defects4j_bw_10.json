{
    "Closure-168": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (t.getScopeDepth() < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:53:27.977518167 +0200\n+++ /tmp/tmp3saitxsj.java\t2022-07-12 13:53:28.033517775 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (t.getScopeDepth() == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:54:14.553193083 +0200\n+++ /tmp/tmp74_ldjcv.java\t2022-07-12 13:54:14.553193083 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() == 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (t.getScopeDepth!= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:54:56.212908307 +0200\n+++ /tmp/tmpnbv56orp.java\t2022-07-12 13:54:56.212908307 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth!= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (t.getScopeDepth()!= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:54:59.880883210 +0200\n+++ /tmp/tmpktgfm2vn.java\t2022-07-12 13:54:59.884883182 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth()!= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (t.getScopeDepth <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:55:41.556597781 +0200\n+++ /tmp/tmpl16aub75.java\t2022-07-12 13:55:41.556597781 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (t.getScopeDepth == 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:55:45.240572529 +0200\n+++ /tmp/tmpe_v7pcum.java\t2022-07-12 13:55:45.268572337 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth == 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (t.getScopeDepth < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:55:49.056546367 +0200\n+++ /tmp/tmp3iz87lmw.java\t2022-07-12 13:55:49.056546367 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (t.getScopeDepth() <= 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:55:52.688521463 +0200\n+++ /tmp/tmp6f3zzaru.java\t2022-07-12 13:55:52.688521463 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (t.getScopeDepth() <= 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type.getScopeDepth < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:56:34.400235212 +0200\n+++ /tmp/tmp6vthzn8v.java\t2022-07-12 13:56:34.400235212 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (type.getScopeDepth < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.t.getScopeDepth() < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-168/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 13:56:38.056210101 +0200\n+++ /tmp/tmpv8lrlzdl.java\t2022-07-12 13:56:38.060210072 +0200\n@@ -1991,11 +1991,11 @@\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+if (this.t.getScopeDepth() < 2) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n         //\n         // 2) Local variables that are assigned more than once.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (t.getScopeDepth() <= 2) {",
        "fixed_line": "if (t.getScopeDepth() <= 1) {"
    },
    "Math-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [JACKSON-139] = f1 / (x0 + fx;",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + fx;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x1);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x0);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 *= i;",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 *= i;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-139] = f1 / (x0 + fx);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + fx);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x;",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x1 = x0);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x1 = x0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 *= (f1 = x0);",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 *= (f1 = x0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x1;",
                "patch_diff": "// [JACKSON-139] = f1 / (x0 + x1) * (x0 + point1.x0 = x1;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case REGULA_FALSI: if (x == x1) { final double delta = FastMath.max(rtol * FastMath.abs(x1), atol); // Update formula cannot make any progress: Update the // search interval. x0 = 0.5 * (x0 + x1 - delta); f0 = computeObjectiveValue(x0); } break; default: // Should never happen. throw new MathInternalError();"
    },
    "Closure-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.process_primitives) { options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:43.716171223 +0200\n+++ /tmp/tmp1b4l35wh.java\t2022-07-12 13:56:43.736171083 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.process_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:45.860156493 +0200\n+++ /tmp/tmpclntyr2c.java\t2022-07-12 13:56:45.864156465 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.process_primitives) { nopePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:47.404145884 +0200\n+++ /tmp/tmpzv_ahkk1.java\t2022-07-12 13:56:47.404145884 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { nopePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.process_primitives) {(flags.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:49.180133680 +0200\n+++ /tmp/tmpwybucle3.java\t2022-07-12 13:56:49.180133680 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) {(flags.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.process_closure_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:50.780122688 +0200\n+++ /tmp/tmpu0_knubz.java\t2022-07-12 13:56:50.784122659 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_closure_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.process_primitives) { if (options.closurePass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:52.304112215 +0200\n+++ /tmp/tmpsjn61_f_.java\t2022-07-12 13:56:52.308112186 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { if (options.closurePass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.remove_closure_ = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:53.836101687 +0200\n+++ /tmp/tmphfn5gtch.java\t2022-07-12 13:56:53.840101658 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_closure_ = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.remove_closure_primitives) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:55.360091212 +0200\n+++ /tmp/tmpsv34tx_5.java\t2022-07-12 13:56:55.360091212 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.remove_closure_primitives) {\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.process_finalPass = false; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:56.852080958 +0200\n+++ /tmp/tmpd5h9klrf.java\t2022-07-12 13:56:56.856080932 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_finalPass = false; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.process_primitives) { options.closurePass = true; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-101/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 13:56:58.380070458 +0200\n+++ /tmp/tmpl6cuu7r6.java\t2022-07-12 13:56:58.380070458 +0200\n@@ -428,13 +428,11 @@\n     WarningLevel wLevel = flags.warning_level;\n     wLevel.setOptionsForWarningLevel(options);\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n-    }\n+if (options.process_primitives) { options.closurePass = true; }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (flags.process_closure_primitives) { options.closurePass = true; }",
        "fixed_line": "options.closurePass = flags.process_closure_primitives;"
    },
    "Math-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (c1 * (xMax - xMin);",
                "patch_diff": "} else if (c1 * (xMax - xMin);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (c1 * (xMax - xMin) /",
                "patch_diff": "} else if (c1 * (xMax - xMin) /",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (c1 * (xMax - xMin)) {",
                "patch_diff": "} else if (c1 * (xMax - xMin)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (c1 * (xMax - xMin) / (a = 0.5 * (c1 - xMin);",
                "patch_diff": "} else if (c1 * (xMax - xMin) / (a = 0.5 * (c1 - xMin);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (c1 / c2;",
                "patch_diff": "} else if (c1 / c2;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// this.yMax = 0.5 * (c1 - yMin);",
                "patch_diff": "// this.yMax = 0.5 * (c1 - yMin);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (c1 * (xMax - xMin) / (c1 - xMin);",
                "patch_diff": "} else if (c1 * (xMax - xMin) / (c1 - xMin);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (c1 * (xMax - xMin) / c1);",
                "patch_diff": "} else if (c1 * (xMax - xMin) / c1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (c1 / 0.5 * (xMax - xMin);",
                "patch_diff": "} else if (c1 / 0.5 * (xMax - xMin);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (c1 * (xMax - xMin) {",
                "patch_diff": "} else if (c1 * (xMax - xMin) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (c2 == 0) { // In some ill-conditioned cases (cf. MATH-844), the guesser // procedure cannot produce sensible results. throw new MathIllegalStateException(LocalizedFormats.ZERO_DENOMINATOR); }"
    },
    "Jsoup-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return accum.toString().trim(html;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:02.012045494 +0200\n+++ /tmp/tmpia0jirh_.java\t2022-07-12 13:57:02.036045327 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(html;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return accum.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:04.008031771 +0200\n+++ /tmp/tmpfjeu0r8g.java\t2022-07-12 13:57:04.008031771 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return accum.toString().trim(accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:07.948004684 +0200\n+++ /tmp/tmp0gm46uhd.java\t2022-07-12 13:57:07.948004684 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(accum;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return accum.toString().trim(accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:09.443994398 +0200\n+++ /tmp/tmp4cs6ek2_.java\t2022-07-12 13:57:09.443994398 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(accum);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return accum.toString().trim;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:11.151982653 +0200\n+++ /tmp/tmpjg6vmosq.java\t2022-07-12 13:57:11.151982653 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return accum.toString().trim( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:12.791971377 +0200\n+++ /tmp/tmp3g3ayknp.java\t2022-07-12 13:57:12.791971377 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim( accum;\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return accum.toString().trim(html);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:14.287961090 +0200\n+++ /tmp/tmp11yk9lsn.java\t2022-07-12 13:57:14.287961090 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim(html);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return flag.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:15.915949894 +0200\n+++ /tmp/tmp7mcdk219.java\t2022-07-12 13:57:15.915949894 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return flag.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return attributes.toString().trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:17.643938008 +0200\n+++ /tmp/tmp6deixmf7.java\t2022-07-12 13:57:17.643938008 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return attributes.toString().trim();\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return accum.toString().trim( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-37/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 13:57:20.699916991 +0200\n+++ /tmp/tmpqn_vo151.java\t2022-07-12 13:57:20.699916991 +0200\n@@ -1096,11 +1096,11 @@\n      * @see #outerHtml()\n      */\n     public String html() {\n         StringBuilder accum = new StringBuilder();\n         html(accum);\n-        return accum.toString().trim();\n+return accum.toString().trim( accum);\n     }\n \n     private void html(StringBuilder accum) {\n         for (Node node : childNodes)\n             node.outerHtml(accum);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return accum.toString().trim();",
        "fixed_line": "return getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();"
    },
    "Lang-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:22.643903617 +0200\n+++ /tmp/tmpqamjdna7.java\t2022-07-12 13:57:22.847902215 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:24.655889779 +0200\n+++ /tmp/tmp4f06hnan.java\t2022-07-12 13:57:24.655889779 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:26.187879238 +0200\n+++ /tmp/tmpsyrrxtgv.java\t2022-07-12 13:57:26.191879212 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:27.663869084 +0200\n+++ /tmp/tmp024bvk2i.java\t2022-07-12 13:57:27.663869084 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:29.187858599 +0200\n+++ /tmp/tmpvfo4uw24.java\t2022-07-12 13:57:29.187858599 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen =tokenLen; }\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:30.695848226 +0200\n+++ /tmp/tmpqktnntxi.java\t2022-07-12 13:57:30.695848226 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:32.195837905 +0200\n+++ /tmp/tmpse5tlnw7.java\t2022-07-12 13:57:32.195837905 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:33.663827804 +0200\n+++ /tmp/tmph3chen4r.java\t2022-07-12 13:57:33.667827775 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule.YEAR, tokenLen = TwoDigitYearField.INSTANCE;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:35.163817480 +0200\n+++ /tmp/tmppeb675m0.java\t2022-07-12 13:57:35.163817480 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-18/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:57:36.707806855 +0200\n+++ /tmp/tmplya5ftrh.java\t2022-07-12 13:57:36.711806830 +0200\n@@ -490,14 +490,11 @@\n             switch (c) {\n             case 'G': // era designator (text)\n                 rule = new TextField(Calendar.ERA, ERAs);\n                 break;\n             case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n+if (tokenLen == 2) { rule = selectNumberRule(Calendar.YEAR, tokenLen =tokenLen;\n                 }\n                 break;\n             case 'M': // month in year (text and number)\n                 if (tokenLen >= 4) {\n                     rule = new TextField(Calendar.MONTH, months);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (tokenLen >= 4) { rule = selectNumberRule(Calendar.YEAR, tokenLen); } else { rule = TwoDigitYearField.INSTANCE;",
        "fixed_line": "if (tokenLen == 2) { rule = TwoDigitYearField.INSTANCE; } else { rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);"
    },
    "JacksonDatabind-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:38.363795460 +0200\n+++ /tmp/tmpaiasj3q4.java\t2022-07-12 13:57:38.447794884 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer == null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:40.395781476 +0200\n+++ /tmp/tmp728mvekm.java\t2022-07-12 13:57:40.395781476 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer == null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:41.939770850 +0200\n+++ /tmp/tmprmpsef2u.java\t2022-07-12 13:57:41.943770820 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer.instance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:43.511760029 +0200\n+++ /tmp/tmp3w8_uwil.java\t2022-07-12 13:57:43.511760029 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer.instance;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:45.103749072 +0200\n+++ /tmp/tmpi7dsyko7.java\t2022-07-12 13:57:45.103749072 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null);\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:46.591738827 +0200\n+++ /tmp/tmpmvssm38h.java\t2022-07-12 13:57:46.595738801 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer!= null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:48.183727867 +0200\n+++ /tmp/tmpw93xk8s9.java\t2022-07-12 13:57:48.183727867 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer);\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _valueTypeDeserializer!= null && key deserializer.valueTypeDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:49.783716854 +0200\n+++ /tmp/tmpi_0d1efl.java\t2022-07-12 13:57:49.783716854 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && key deserializer.valueTypeDeserializer;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer == null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:51.307706361 +0200\n+++ /tmp/tmpnrk2pxcb.java\t2022-07-12 13:57:51.307706361 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null && _valueTypeDeserializer == null;\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-12/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java\t2022-07-12 13:57:52.955695016 +0200\n+++ /tmp/tmpnxj2o4dl.java\t2022-07-12 13:57:52.955695016 +0200\n@@ -298,11 +298,11 @@\n     @Override\n     public boolean isCachable() {\n         /* As per [databind#735], existence of value or key deserializer (only passed\n          * if annotated to use non-standard one) should also prevent caching.\n          */\n-        return (_valueTypeDeserializer == null)\n+return _valueTypeDeserializer!= null && _valueTypeDeserializer!= null)\n                 && (_ignorableProperties == null);\n     }\n \n     @Override\n     @SuppressWarnings(\"unchecked\")\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (_valueTypeDeserializer == null)",
        "fixed_line": "return (_valueDeserializer == null) && (_keyDeserializer == null) && (_valueTypeDeserializer == null)"
    },
    "Jsoup-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (this.getFormType!= null) {",
                "patch_diff": "} else if (this.getFormType!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return tb.error;",
                "patch_diff": "return tb.error;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (this.getFormType == null) {",
                "patch_diff": "} else if (this.getFormType == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tb.equals(\"*s? tb.getFormCount() == 2) {",
                "patch_diff": "if (tb.equals(\"*s? tb.getFormCount() == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.error.equals(\"*s? tb.getFormCount() == 2) {",
                "patch_diff": "if (this.error.equals(\"*s? tb.getFormCount() == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (this.getFormCount!= 1) {",
                "patch_diff": "} else if (this.getFormCount!= 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.error.equals(\"*s? tb.getFormType() == null) {",
                "patch_diff": "if (this.error.equals(\"*s? tb.getFormType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (tb.equals(\"*s? tb.getFormType() == null) {",
                "patch_diff": "} else if (tb.equals(\"*s? tb.getFormType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tb.equals(\"*s? tb.getFormType() == null) {",
                "patch_diff": "if (tb.equals(\"*s? tb.getFormType() == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.error.equals(\"*s? tb.getFormType() == null : tb.error;",
                "patch_diff": "if (this.error.equals(\"*s? tb.getFormType() == null : tb.error;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (tb.getFromStack(\"svg\") == null) return tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg else tb.insert(startTag);"
    },
    "JacksonDatabind-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:57:56.371671494 +0200\n+++ /tmp/tmpgafim9ie.java\t2022-07-12 13:57:56.391671357 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:57:59.147652381 +0200\n+++ /tmp/tmpo_l51kaq.java\t2022-07-12 13:57:59.147652381 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiatorCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:00.891640371 +0200\n+++ /tmp/tmpd46zgc59.java\t2022-07-12 13:58:00.891640371 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiatorCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:02.591628663 +0200\n+++ /tmp/tmpwb11wqa4.java\t2022-07-12 13:58:02.591628663 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:04.075618443 +0200\n+++ /tmp/tmpgkvnkasq.java\t2022-07-12 13:58:04.075618443 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiatorCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:05.891605933 +0200\n+++ /tmp/tmpx9ueh5vr.java\t2022-07-12 13:58:05.891605933 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiatorCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:07.715593372 +0200\n+++ /tmp/tmp_hrnhl15.java\t2022-07-12 13:58:07.715593372 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator - _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:09.343582159 +0200\n+++ /tmp/tmpf3ea_6h1.java\t2022-07-12 13:58:09.343582159 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:11.019570611 +0200\n+++ /tmp/tmpj9q62m7_.java\t2022-07-12 13:58:11.019570611 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator;\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-112/src/main/java/com/fasterxml/jackson/databind/deser/std/StringCollectionDeserializer.java\t2022-07-12 13:58:12.663559287 +0200\n+++ /tmp/tmpkhq23sgn.java\t2022-07-12 13:58:12.663559287 +0200\n@@ -102,11 +102,11 @@\n     {\n         // May need to resolve types for delegate-based creators:\n         JsonDeserializer<Object> delegate = null;\n         if (_valueInstantiator != null) {\n             // [databind#2324]: check both array-delegating and delegating\n-            AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();\n+AnnotatedWithParams delegateType = _valueInstantiator.getDelegateCreator!= _valueInstantiator.getDelegateCreator) {\n             if (delegateCreator != null) {\n                 JavaType delegateType = _valueInstantiator.getDelegateType(ctxt.getConfig());\n                 delegate = findDeserializer(ctxt, delegateType, property);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getDelegateCreator();",
        "fixed_line": "AnnotatedWithParams delegateCreator = _valueInstantiator.getArrayDelegateCreator(); if (delegateCreator != null) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); delegate = findDeserializer(ctxt, delegateType, property); } else if ((delegateCreator = _valueInstantiator.getDelegateCreator()) != null) {"
    },
    "Lang-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Calendar c = new GregorianCalendar(2006, 10, 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:14.415547216 +0200\n+++ /tmp/tmpncojcgv1.java\t2022-07-12 13:58:14.467546861 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(2006, 10, 1);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone.mTimeZoneCount);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:25.503470816 +0200\n+++ /tmp/tmpsi4pbyui.java\t2022-07-12 13:58:25.503470816 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone.mTimeZoneCount);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:27.255458743 +0200\n+++ /tmp/tmp66cqm48i.java\t2022-07-12 13:58:27.259458714 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Calendar c = new GregorianCalendar(200mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:36.671393842 +0200\n+++ /tmp/tmp0d1d9sh7.java\t2022-07-12 13:58:36.671393842 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(200mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneCount);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:38.211383223 +0200\n+++ /tmp/tmpp7g1gkye.java\t2022-07-12 13:58:38.211383223 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneCount);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:39.915371479 +0200\n+++ /tmp/tmpl5h81nlp.java\t2022-07-12 13:58:39.915371479 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:41.407361190 +0200\n+++ /tmp/tmp6edzwoqi.java\t2022-07-12 13:58:41.407361190 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneId);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Calendar c = new GregorianCalendar(mTimeZoneLengthEstimate);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:43.143349223 +0200\n+++ /tmp/tmpz0708qoq.java\t2022-07-12 13:58:43.147349193 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZoneLengthEstimate);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Calendar c = new GregorianCalendar(mTimeZone.mTimeZone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:44.899337115 +0200\n+++ /tmp/tmp4so7trhe.java\t2022-07-12 13:58:44.899337115 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(mTimeZone.mTimeZone;\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Calendar c = new GregorianCalendar(200mTimeZone(mTimeZone);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-26/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\t2022-07-12 13:58:46.471326274 +0200\n+++ /tmp/tmp4o8m9vce.java\t2022-07-12 13:58:46.471326274 +0200\n@@ -815,11 +815,11 @@\n      * \n      * @param date  the date to format\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+Calendar c = new GregorianCalendar(200mTimeZone(mTimeZone);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Calendar c = new GregorianCalendar(mTimeZone);",
        "fixed_line": "Calendar c = new GregorianCalendar(mTimeZone, mLocale);"
    },
    "Math-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "final Line reverted = new Line2Ddirection, iValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:58:48.207314308 +0200\n+++ /tmp/tmpjj8goxqn.java\t2022-07-12 13:58:48.231314138 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, iValues;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final Line reverted = new Line2Ddirection;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:58:51.819289395 +0200\n+++ /tmp/tmp4qbm7exm.java\t2022-07-12 13:58:51.819289395 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final Line reverted = new Line2Ddirectiondirection;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:58:53.875275216 +0200\n+++ /tmp/tmpyl6hclkw.java\t2022-07-12 13:58:53.875275216 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final Line reverted = new Line2DUPed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:58:55.819261810 +0200\n+++ /tmp/tmpq2j3ipfe.java\t2022-07-12 13:58:55.819261810 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2DUPed;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final Line reverted = new Line2D(0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:58:58.743241642 +0200\n+++ /tmp/tmp1qgwkwi7.java\t2022-07-12 13:58:58.743241642 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2D(0) {\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final Line reverted = new Line2Ddirection, this.direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:59:01.607221885 +0200\n+++ /tmp/tmp16zv4pbw.java\t2022-07-12 13:59:01.607221885 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, this.direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final Line reverted = new Line2Ddirectiondirection, iValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:59:04.063204944 +0200\n+++ /tmp/tmpm1pjrg3a.java\t2022-07-12 13:59:04.063204944 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection, iValues;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final Line reverted = new Line2Ddirectiondirection, this.direction));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:59:06.731186536 +0200\n+++ /tmp/tmpnziljafp.java\t2022-07-12 13:59:06.731186536 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirectiondirection, this.direction));\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final Line reverted = new Line2DUMMYed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:59:09.975164157 +0200\n+++ /tmp/tmpi9z3rjtx.java\t2022-07-12 13:59:09.975164157 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2DUMMYed;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final Line reverted = new Line2Ddirection, this.direction;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-9/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\t2022-07-12 13:59:13.519139701 +0200\n+++ /tmp/tmpgkvhqsmz.java\t2022-07-12 13:59:13.519139701 +0200\n@@ -82,11 +82,11 @@\n \n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n     public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n+final Line reverted = new Line2Ddirection, this.direction;\n         return reverted;\n     }\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final Line reverted = new Line(zero, zero.subtract(direction));",
        "fixed_line": "final Line reverted = new Line(this); reverted.direction = reverted.direction.negate();"
    },
    "Lang-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 13:59:16.771117263 +0200\n+++ /tmp/tmpsa1egj2c.java\t2022-07-12 13:59:16.963115944 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 13:59:32.087011548 +0200\n+++ /tmp/tmpfy1en4uy.java\t2022-07-12 13:59:32.087011548 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 13:59:44.158928200 +0200\n+++ /tmp/tmp2uu7yuae.java\t2022-07-12 13:59:44.594925195 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 13:59:56.850840541 +0200\n+++ /tmp/tmp60bmp0he.java\t2022-07-12 13:59:56.850840541 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:09.434753605 +0200\n+++ /tmp/tmp9a8iy32h.java\t2022-07-12 14:00:09.438753580 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Math.abs(u) < 1 || Math.abs(v - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:21.930667254 +0200\n+++ /tmp/tmpwfulzs82.java\t2022-07-12 14:00:21.930667254 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) < 1 || Math.abs(v - 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v) < 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:24.834647183 +0200\n+++ /tmp/tmplo3nshqv.java\t2022-07-12 14:00:24.874646907 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v) < 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:36.290567992 +0200\n+++ /tmp/tmphvn36vkv.java\t2022-07-12 14:00:36.310567852 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 || Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:45.794502277 +0200\n+++ /tmp/tmp52o75zco.java\t2022-07-12 14:00:45.798502247 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 0 && Math.abs(v) <= 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (Math.abs(u) <= 1 || Math.abs(v - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-22/src/main/java/org/apache/commons/lang3/math/Fraction.java\t2022-07-12 14:00:55.186437326 +0200\n+++ /tmp/tmp37utk4rj.java\t2022-07-12 14:00:55.190437296 +0200\n@@ -579,11 +579,11 @@\n      * @return the greatest common divisor, never zero\n      */\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+if (Math.abs(u) <= 1 || Math.abs(v - 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {",
        "fixed_line": "if ((u == 0) || (v == 0)) { if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } return Math.abs(u) + Math.abs(v); } //if either operand is abs 1, return 1: if (Math.abs(u) == 1 || Math.abs(v) == 1) {"
    },
    "JacksonCore-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:00:56.990424850 +0200\n+++ /tmp/tmpyjo_aavl.java\t2022-07-12 14:00:57.018424653 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:00:58.866411874 +0200\n+++ /tmp/tmpbsx9b7u6.java\t2022-07-12 14:00:58.866411874 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:00.426401080 +0200\n+++ /tmp/tmpw485g2sx.java\t2022-07-12 14:01:00.430401055 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= _class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:01.958390485 +0200\n+++ /tmp/tmpovubu79i.java\t2022-07-12 14:01:01.958390485 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= _class) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:03.446380192 +0200\n+++ /tmp/tmpv4_e48de.java\t2022-07-12 14:01:03.450380164 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= 0;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length < src) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:04.926369954 +0200\n+++ /tmp/tmpcyfzov1s.java\t2022-07-12 14:01:04.926369954 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length < src) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= src;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:06.462359328 +0200\n+++ /tmp/tmpgdr9ec8z.java\t2022-07-12 14:01:06.462359328 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= src;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:07.970348896 +0200\n+++ /tmp/tmp7rrx1iak.java\t2022-07-12 14:01:07.970348896 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:09.430338795 +0200\n+++ /tmp/tmpglrk87va.java\t2022-07-12 14:01:09.430338795 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toReleaseBuf.length!= toReleaseBuf.length);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (toRelease!= src) && (toRelease.length!= toReleaseBuf.length)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-14/src/main/java/com/fasterxml/jackson/core/io/IOContext.java\t2022-07-12 14:01:10.966328169 +0200\n+++ /tmp/tmpep16dta3.java\t2022-07-12 14:01:10.966328169 +0200\n@@ -269,18 +269,8 @@\n         if (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n     }\n \n     protected final void _verifyRelease(byte[] toRelease, byte[] src) {\n         // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    protected final void _verifyRelease(char[] toRelease, char[] src) {\n-        // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer\n-        if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n-    }\n-\n-    private IllegalArgumentException wrongBuf() {\n-        // sanity check failed; trying to return different, smaller buffer.\n-return new IllegalArgumentException(\"Trying to release buffer not owned by the context\"); \n+if (toRelease!= src) && (toRelease.length!= toReleaseBuf.length)) {\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer not owned by the context\");",
        "fixed_line": "if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } protected final void _verifyRelease(char[] toRelease, char[] src) { // 07-Mar-2016, tatu: As per [core#255], only prevent shrinking of buffer if ((toRelease != src) && (toRelease.length < src.length)) { throw wrongBuf(); } } private IllegalArgumentException wrongBuf() { // sanity check failed; trying to return different, smaller buffer. return new IllegalArgumentException(\"Trying to release buffer smaller than original\");"
    },
    "Chart-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:12.830315273 +0200\n+++ /tmp/tmp5bdtn2vt.java\t2022-07-12 14:01:12.874314968 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:15.162299137 +0200\n+++ /tmp/tmpmpkx13gz.java\t2022-07-12 14:01:15.162299137 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime();\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:16.742288202 +0200\n+++ /tmp/tmp3486bwf3.java\t2022-07-12 14:01:16.746288178 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() { this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:18.390276802 +0200\n+++ /tmp/tmpqw63hwbb.java\t2022-07-12 14:01:18.390276802 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex;\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd() {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:20.030265451 +0200\n+++ /tmp/tmp47ykw8qj.java\t2022-07-12 14:01:20.030265451 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd() {\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:21.658254188 +0200\n+++ /tmp/tmpulqe3z4d.java\t2022-07-12 14:01:21.658254188 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex;\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:23.318242698 +0200\n+++ /tmp/tmpkv_gv50h.java\t2022-07-12 14:01:23.318242698 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex + 1;\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:24.970231266 +0200\n+++ /tmp/tmpr1f5s1yq.java\t2022-07-12 14:01:24.970231266 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() - this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:26.666219530 +0200\n+++ /tmp/tmpku0pbvsv.java\t2022-07-12 14:01:26.666219530 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() {this.minMiddleIndex = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd()",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-7/source/org/jfree/data/time/TimePeriodValues.java\t2022-07-12 14:01:28.246208596 +0200\n+++ /tmp/tmph894zr0o.java\t2022-07-12 14:01:28.246208596 +0200\n@@ -295,13 +295,11 @@\n         else {\n             this.minMiddleIndex = index;\n         }\n         \n         if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+long s = getDataItem(this.minMiddleIndex).getPeriod().getTime() + this.minMiddleIndex).getPeriod().getEnd()\n                 .getTime();\n             long maxMiddle = s + (e - s) / 2;\n             if (middle > maxMiddle) {\n                 this.maxMiddleIndex = index;           \n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()",
        "fixed_line": "long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart() .getTime(); long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()"
    },
    "Closure-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:30.198195087 +0200\n+++ /tmp/tmpgs1maqcn.java\t2022-07-12 14:01:30.218194948 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:32.182181352 +0200\n+++ /tmp/tmpoptwxcxp.java\t2022-07-12 14:01:32.182181352 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:33.690170916 +0200\n+++ /tmp/tmptut_9szx.java\t2022-07-12 14:01:33.694170886 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:35.250160119 +0200\n+++ /tmp/tmp8v0aam8w.java\t2022-07-12 14:01:35.250160119 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:36.842149099 +0200\n+++ /tmp/tmppjg54p4c.java\t2022-07-12 14:01:36.842149099 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:38.398138329 +0200\n+++ /tmp/tmpx0c9n3n_.java\t2022-07-12 14:01:38.402138300 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:39.946127613 +0200\n+++ /tmp/tmpjrtsvmwl.java\t2022-07-12 14:01:39.946127613 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:41.502116838 +0200\n+++ /tmp/tmphpnuy4_l.java\t2022-07-12 14:01:41.506116813 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:43.118105651 +0200\n+++ /tmp/tmpsvm5fj23.java\t2022-07-12 14:01:43.118105651 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-102/src/com/google/javascript/jscomp/Normalize.java\t2022-07-12 14:01:44.706094660 +0200\n+++ /tmp/tmpsqzjvz7c.java\t2022-07-12 14:01:44.706094660 +0200\n@@ -89,11 +89,11 @@\n     if (MAKE_LOCAL_NAMES_UNIQUE) {\n       MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n       NodeTraversal t = new NodeTraversal(compiler, renamer);\n       t.traverseRoots(externs, root);\n     }\n-    removeDuplicateDeclarations(root);\n+removeDuplicateDeclarations(root).processQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedNameQualifiedName;\n     new PropogateConstantAnnotations(compiler, assertOnChange)\n         .process(externs, root);\n   }\n \n   @Override\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "removeDuplicateDeclarations(root);",
        "fixed_line": "removeDuplicateDeclarations(root);"
    },
    "JacksonDatabind-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _typeFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:46.446082613 +0200\n+++ /tmp/tmpegl55q25.java\t2022-07-12 14:01:46.490082309 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _typeFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:48.266070013 +0200\n+++ /tmp/tmpywxzi2ik.java\t2022-07-12 14:01:48.266070013 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _valueTypeReaders);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:49.826059212 +0200\n+++ /tmp/tmpo2s52le8.java\t2022-07-12 14:01:49.826059212 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _valueTypeReaders);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:51.394048356 +0200\n+++ /tmp/tmpg35gb1or.java\t2022-07-12 14:01:51.394048356 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src, offset, length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:52.978037388 +0200\n+++ /tmp/tmp17ges4ur.java\t2022-07-12 14:01:52.982037360 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src, offset, length);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _generatorFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:54.550026503 +0200\n+++ /tmp/tmpk9cvjbgq.java\t2022-07-12 14:01:54.550026503 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _generatorFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _bindAndReadValues(_jsonFactory.createParser(src), _typeFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:56.186015175 +0200\n+++ /tmp/tmp2su9wcz4.java\t2022-07-12 14:01:56.186015175 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_jsonFactory.createParser(src), _typeFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:57.834003762 +0200\n+++ /tmp/tmp5pvfrblz.java\t2022-07-12 14:01:57.834003762 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _parserFactory.createParser(_parserFactory);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData, offset, length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:01:59.461992489 +0200\n+++ /tmp/tmp169hi9xy.java\t2022-07-12 14:01:59.461992489 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _bufferedData, offset, length);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _bindAndReadValues(_parserFactory.createParser(src), _generatorFeatures);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-57/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\t2022-07-12 14:02:01.045981517 +0200\n+++ /tmp/tmp0zy6wno8.java\t2022-07-12 14:02:01.045981517 +0200\n@@ -1436,11 +1436,11 @@\n         throws IOException, JsonProcessingException\n     {\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+return _bindAndReadValues(_parserFactory.createParser(src), _generatorFeatures);\n                 true));\n     }\n \n     /**\n      * Overloaded version of {@link #readValue(InputStream)}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src),",
        "fixed_line": "return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length),"
    },
    "Lang-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean wasWhite= false; if if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:02.821969221 +0200\n+++ /tmp/tmpr9a3fdch.java\t2022-07-12 14:02:02.857968971 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean wasWhite= false; if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:04.421958139 +0200\n+++ /tmp/tmppax_sznz.java\t2022-07-12 14:02:04.425958111 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean wasWhite= false; if if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:05.861948167 +0200\n+++ /tmp/tmph7ms0g1_.java\t2022-07-12 14:02:05.861948167 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean wasWhite= false; if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:07.361937777 +0200\n+++ /tmp/tmpvwgokyco.java\t2022-07-12 14:02:07.361937777 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean wasWhite= false; if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:08.877927278 +0200\n+++ /tmp/tmpcb_y1pyc.java\t2022-07-12 14:02:08.877927278 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean wasWhite= false; if if if if (value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:10.505916002 +0200\n+++ /tmp/tmpncxbjg5f.java\t2022-07-12 14:02:10.509915974 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if if (value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean wasWhite= false; if if ifNode<value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:11.997905669 +0200\n+++ /tmp/tmpf4zwehzo.java\t2022-07-12 14:02:12.001905640 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if ifNode<value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean wasWhite= false; if if if if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:13.489895333 +0200\n+++ /tmp/tmpy4m218wi.java\t2022-07-12 14:02:13.489895333 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if if if if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean wasWhite= false; if ifNode<value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:15.025884693 +0200\n+++ /tmp/tmpiq2q_thv.java\t2022-07-12 14:02:15.025884693 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if ifNode<value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean wasWhite= false; if(value.charAt(i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-10/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\t2022-07-12 14:02:16.525874303 +0200\n+++ /tmp/tmp_aw6sx3p.java\t2022-07-12 14:02:16.525874303 +0200\n@@ -299,21 +299,11 @@\n      * @param value The source field\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n     private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n+boolean wasWhite= false; if(value.charAt(i++) {\n             switch(c) {\n             case '\\'':\n                 if(unquote) {\n                     if(++i==value.length()) {\n                         return regex;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false;",
        "fixed_line": ""
    },
    "Lang-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int i = 0; i < searchList[i].length; i++) {",
                "patch_diff": "private static final /*day*/int i = 0; i < searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "matches.length = 0; i < searchList[i].length; i++) {",
                "patch_diff": "matches.length = 0; i < searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "matches.length = 0;",
                "patch_diff": "matches.length = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "matches.length = 0; for (int i = 0; i < searchList[i].length; i++) {",
                "patch_diff": "matches.length = 0; for (int i = 0; i < searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < searchList[i].length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList[i].length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int i = 0; i < searchList[i].length - i;",
                "patch_diff": "private static final /*day*/int i = 0; i < searchList[i].length - i;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int i = 0; i < searchList[i].length - searchList[i].length;",
                "patch_diff": "private static final /*day*/int i = 0; i < searchList[i].length - searchList[i].length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < searchList.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchList.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "matches.length = 0; i < searchList[i].length - i;",
                "patch_diff": "matches.length = 0; i < searchList[i].length - i;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "matches.length = 0; i < str.length; i++) {",
                "patch_diff": "matches.length = 0; i < str.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (searchList[i] == null || replacementList[i] == null) { continue; }"
    },
    "Chart-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "return super.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:19.905850889 +0200\n+++ /tmp/tmpq4snqsep.java\t2022-07-12 14:02:19.929850724 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return super.equalsParent.equals(obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:21.789837837 +0200\n+++ /tmp/tmp3m35swlt.java\t2022-07-12 14:02:21.793837810 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return super.equalsParent.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:23.441826392 +0200\n+++ /tmp/tmpbiftlysf.java\t2022-07-12 14:02:23.445826364 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return super.equalsParent.equals;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:25.021815447 +0200\n+++ /tmp/tmppv5xkzzc.java\t2022-07-12 14:02:25.021815447 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return typeList.equals(obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:26.645804195 +0200\n+++ /tmp/tmpzk6339zm.java\t2022-07-12 14:02:26.645804195 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return typeList.equals(obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return super.object.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:28.349792389 +0200\n+++ /tmp/tmp49pbsimr.java\t2022-07-12 14:02:28.349792389 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.object.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return typeList.equals(objType.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:29.897781664 +0200\n+++ /tmp/tmpsxfsip4o.java\t2022-07-12 14:02:29.897781664 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return typeList.equals(objType.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return super.equals(obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:31.453770882 +0200\n+++ /tmp/tmpfb11gmnd.java\t2022-07-12 14:02:31.453770882 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return super.equalsParent.equals(objType.obj);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:40.533707963 +0200\n+++ /tmp/tmpzc8l_mv7.java\t2022-07-12 14:02:40.533707963 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equalsParent.equals(objType.obj);\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return super.equals(obj.obj;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-6/source/org/jfree/chart/util/ShapeList.java\t2022-07-12 14:02:42.185696515 +0200\n+++ /tmp/tmpc7jzkx48.java\t2022-07-12 14:02:42.209696349 +0200\n@@ -106,11 +106,11 @@\n             return true;\n         }\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+return super.equals(obj.obj;\n \n     }\n \n     /**\n      * Returns a hash code value for the object.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return super.equals(obj);",
        "fixed_line": "ShapeList that = (ShapeList) obj; int listSize = size(); for (int i = 0; i < listSize; i++) { if (!ShapeUtilities.equal((Shape) get(i), (Shape) that.get(i))) { return false; } } return true;"
    },
    "Jsoup-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static String nullString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:43.913684541 +0200\n+++ /tmp/tmpyoqmmlii.java\t2022-07-12 14:02:43.933684400 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static String nullString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:45.829671261 +0200\n+++ /tmp/tmpqgmoed7g.java\t2022-07-12 14:02:45.829671261 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static String typeString = String.valueOf(0x0000,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:49.581645256 +0200\n+++ /tmp/tmpxpunl8sr.java\t2022-07-12 14:02:49.581645256 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x0000,\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static String nullString = String.valueOf(0x0000,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:51.149634388 +0200\n+++ /tmp/tmplfvogvqn.java\t2022-07-12 14:02:51.149634388 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String nullString = String.valueOf(0x0000,\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static String typeString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:52.645624020 +0200\n+++ /tmp/tmpnfw0g__c.java\t2022-07-12 14:02:52.645624020 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static String typeString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:54.445611543 +0200\n+++ /tmp/tmpfv3236_0.java\t2022-07-12 14:02:54.445611543 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String typeString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static String[]String = String.valueOf(0x0000,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:55.969600979 +0200\n+++ /tmp/tmpi20j8zc4.java\t2022-07-12 14:02:55.969600979 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String[]String = String.valueOf(0x0000,\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static String[]String = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:57.561589944 +0200\n+++ /tmp/tmp3qkgpnx1.java\t2022-07-12 14:02:57.561589944 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String[]String = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static String String nullString = String.valueOf(0x00000000000;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:02:59.265578131 +0200\n+++ /tmp/tmpbkv7mgid.java\t2022-07-12 14:02:59.265578131 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String String nullString = String.valueOf(0x00000000000;\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static String String nullString = String.valueOf(0x0000);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-17/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 14:03:00.821567345 +0200\n+++ /tmp/tmpus5n3a4_.java\t2022-07-12 14:03:00.821567345 +0200\n@@ -1446,11 +1446,11 @@\n             return true;\n             // todo: implement. Also; how do we get here?\n         }\n     };\n \n-    private static String nullString = String.valueOf(0x0000);\n+private static String String nullString = String.valueOf(0x0000);\n \n     abstract boolean process(Token t, TreeBuilder tb);\n \n     private static boolean isWhitespace(Token t) {\n         if (t.isCharacter()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static String nullString = String.valueOf(0x0000);",
        "fixed_line": "private static String nullString = String.valueOf('\\u0000');"
    },
    "Cli-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return root;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:02.425556225 +0200\n+++ /tmp/tmpssx_vug_.java\t2022-07-12 14:03:02.489555783 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return root;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:04.145544301 +0200\n+++ /tmp/tmpzavbbl9g.java\t2022-07-12 14:03:04.145544301 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return parent;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return current;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:05.765533070 +0200\n+++ /tmp/tmp27u35joa.java\t2022-07-12 14:03:05.769533042 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return current;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:07.445521423 +0200\n+++ /tmp/tmp_6dxhc6s.java\t2022-07-12 14:03:07.445521423 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return null;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return empty;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:10.117502899 +0200\n+++ /tmp/tmp6ji20eg3.java\t2022-07-12 14:03:10.117502899 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return empty;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:11.749491583 +0200\n+++ /tmp/tmpi5y3fgac.java\t2022-07-12 14:03:11.753491555 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return valueType;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return coll;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:13.441479852 +0200\n+++ /tmp/tmp95a40j61.java\t2022-07-12 14:03:13.445479823 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return coll;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return last;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:15.221467510 +0200\n+++ /tmp/tmpiyu6x7mb.java\t2022-07-12 14:03:15.221467510 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return last;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:16.865456110 +0200\n+++ /tmp/tmpfk22qbz8.java\t2022-07-12 14:03:16.869456081 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return NONE;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return result;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-40/src/main/java/org/apache/commons/cli/TypeHandler.java\t2022-07-12 14:03:18.545444461 +0200\n+++ /tmp/tmp700r7ral.java\t2022-07-12 14:03:18.545444461 +0200\n@@ -98,11 +98,11 @@\n         {\n             return (T) createURL(str);\n         }\n         else\n         {\n-            return null;\n+return result;\n         }\n     }\n \n     /**\n       * Create an Object from the classname and empty constructor.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "throw new ParseException(\"Unable to handle the class: \" + clazz);"
    },
    "Codec-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lineSeparator.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:20.365431840 +0200\n+++ /tmp/tmp5l3bnf77.java\t2022-07-12 14:03:20.401431588 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length == 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (lineSeparator == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:23.733408484 +0200\n+++ /tmp/tmpv_4t_d1y.java\t2022-07-12 14:03:23.737408457 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator == 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (lineSeparator!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:25.425396750 +0200\n+++ /tmp/tmpm5au_j11.java\t2022-07-12 14:03:25.429396722 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator!= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lineSeparator.length!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:27.129384933 +0200\n+++ /tmp/tmpjt_jkni8.java\t2022-07-12 14:03:27.129384933 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length!= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lineSeparator.length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:29.665367346 +0200\n+++ /tmp/tmpilhstvy7.java\t2022-07-12 14:03:29.665367346 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lineSeparator.length >= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:32.233349536 +0200\n+++ /tmp/tmp2dyywng9.java\t2022-07-12 14:03:32.233349536 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length >= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (lineSeparator.length < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:34.657332723 +0200\n+++ /tmp/tmpgkj4qctd.java\t2022-07-12 14:03:34.661332695 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length < 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lineSeparator.length <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:37.109315715 +0200\n+++ /tmp/tmp5n1go6gj.java\t2022-07-12 14:03:37.109315715 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator.length <= 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (pos > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:39.657298042 +0200\n+++ /tmp/tmp3eqmkx2f.java\t2022-07-12 14:03:39.657298042 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (pos > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lineSeparator > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-2/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 14:03:42.113281006 +0200\n+++ /tmp/tmpuiyoujrd.java\t2022-07-12 14:03:42.117280978 +0200\n@@ -441,11 +441,11 @@\n                     if (encodeTable == STANDARD_ENCODE_TABLE) {\n                         buf[pos++] = PAD;\n                     }\n                     break;\n             }\n-            if (lineLength > 0) {\n+if (lineSeparator > 0) {\n                 System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n                 pos += lineSeparator.length;\n             }\n         } else {\n             for (int i = 0; i < inAvail; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (lineLength > 0) {",
        "fixed_line": "if (lineLength > 0 && pos > 0) {"
    },
    "Gson-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter,Pointer.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:44.005267881 +0200\n+++ /tmp/tmpo_98yyp_.java\t2022-07-12 14:03:44.033267688 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter,Pointer.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:45.809255367 +0200\n+++ /tmp/tmp0h0rcnet.java\t2022-07-12 14:03:45.809255367 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue);\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, value, typeAdapter.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:47.485243741 +0200\n+++ /tmp/tmpqp87fjvy.java\t2022-07-12 14:03:47.485243741 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, value, typeAdapter.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, value.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:49.189231919 +0200\n+++ /tmp/tmpeikm0idn.java\t2022-07-12 14:03:49.189231919 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, value.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, locale.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:50.845220431 +0200\n+++ /tmp/tmphglluf5x.java\t2022-07-12 14:03:50.845220431 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(typeAdapter, fieldValue, locale.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, field.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:52.545208637 +0200\n+++ /tmp/tmpoc0nnfot.java\t2022-07-12 14:03:52.545208637 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, field.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, serializationType.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:54.197197175 +0200\n+++ /tmp/tmpqx1wu37t.java\t2022-07-12 14:03:54.197197175 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, serializationType.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:55.849185713 +0200\n+++ /tmp/tmp8fdby9po.java\t2022-07-12 14:03:55.849185713 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, elementValue.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, value, typeAdapter.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:03:58.197169423 +0200\n+++ /tmp/tmp2jvr33j5.java\t2022-07-12 14:03:58.197169423 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, value, typeAdapter.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, context.getType());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-10/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java\t2022-07-12 14:04:00.509153380 +0200\n+++ /tmp/tmprj9n96mj.java\t2022-07-12 14:04:00.509153380 +0200\n@@ -117,12 +117,11 @@\n     return new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n       @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n       @Override void write(JsonWriter writer, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = field.get(value);\n-        TypeAdapter t =\n-          new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n+TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(fieldType, typeAdapter, context.getType());\n         t.write(writer, fieldValue);\n       }\n       @Override void read(JsonReader reader, Object value)\n           throws IOException, IllegalAccessException {\n         Object fieldValue = typeAdapter.read(reader);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());",
        "fixed_line": "TypeAdapter t = jsonAdapterPresent ? typeAdapter : new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());"
    },
    "Math-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "double denominator = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:03.129135200 +0200\n+++ /tmp/tmpplmvyhli.java\t2022-07-12 14:04:03.349133679 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double ret = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:06.701110416 +0200\n+++ /tmp/tmpe6nv9bvc.java\t2022-07-12 14:04:06.705110388 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double ret = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:09.437091429 +0200\n+++ /tmp/tmprvdvxq3q.java\t2022-07-12 14:04:09.497091016 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double p = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:11.853074663 +0200\n+++ /tmp/tmp6gpa0y4s.java\t2022-07-12 14:04:11.853074663 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double p = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double denominator = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:14.573055786 +0200\n+++ /tmp/tmphvc3gwmp.java\t2022-07-12 14:04:14.593055649 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = p;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double p = p.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:16.965039187 +0200\n+++ /tmp/tmpis59vl_b.java\t2022-07-12 14:04:16.965039187 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double p = p.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double ret = p.enom;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:19.657020503 +0200\n+++ /tmp/tmpd16bz0iu.java\t2022-07-12 14:04:19.697020228 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p.enom;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double denominator = this.enominator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:22.321002014 +0200\n+++ /tmp/tmpc9c2ckgj.java\t2022-07-12 14:04:22.321002014 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = this.enominator;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double ret = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:25.264981579 +0200\n+++ /tmp/tmpur6a2ztn.java\t2022-07-12 14:04:25.268981553 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double ret = p;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double denominator = p.enom;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-95/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\t2022-07-12 14:04:35.996907084 +0200\n+++ /tmp/tmpge9317y2.java\t2022-07-12 14:04:36.000907056 +0200\n@@ -139,11 +139,11 @@\n      * \n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n-        double ret;\n+double denominator = p.enom;\n         double d = getDenominatorDegreesOfFreedom();\n             // use mean\n             ret = d / (d - 2.0);\n         return ret;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "double ret;",
        "fixed_line": "double ret = 1.0; double d = getDenominatorDegreesOfFreedom(); if (d > 2.0) { // use mean ret = d / (d - 2.0); }"
    },
    "Cli-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "break.addValue(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:39.180884980 +0200\n+++ /tmp/tmpu0tsobm_.java\t2022-07-12 14:04:40.008879232 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addValue(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "break.addOption(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:43.016858350 +0200\n+++ /tmp/tmpqe4eq3o4.java\t2022-07-12 14:04:43.016858350 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "break.addValue(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:45.488841187 +0200\n+++ /tmp/tmp1pwljqoo.java\t2022-07-12 14:04:45.488841187 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addValue(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "break.addOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:48.156822664 +0200\n+++ /tmp/tmpa2wfdtcn.java\t2022-07-12 14:04:48.160822635 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "break.isOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:50.820804167 +0200\n+++ /tmp/tmp9mtr4_md.java\t2022-07-12 14:04:50.820804167 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.isOption;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "break.add(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:53.604784835 +0200\n+++ /tmp/tmpr0mjufxg.java\t2022-07-12 14:04:53.652784504 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add(value);\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "break.addOption(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:56.100767504 +0200\n+++ /tmp/tmpc0seo135.java\t2022-07-12 14:04:56.104767476 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.addOption(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "break.add;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:04:58.984747478 +0200\n+++ /tmp/tmp_ueqpe50.java\t2022-07-12 14:04:59.016747256 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "break.add(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:05:01.516729896 +0200\n+++ /tmp/tmpo61di5xz.java\t2022-07-12 14:05:01.544729701 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.add(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "break.isOption(value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-28/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 14:05:03.768714256 +0200\n+++ /tmp/tmpa124d25f.java\t2022-07-12 14:05:04.608708424 +0200\n@@ -285,11 +285,11 @@\n                         || \"true\".equalsIgnoreCase(value)\n                         || \"1\".equalsIgnoreCase(value)))\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+break.isOption(value;\n                 }\n \n                 cmd.addOption(opt);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "break;",
        "fixed_line": "continue;"
    },
    "JacksonDatabind-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:07.396689063 +0200\n+++ /tmp/tmpcnev0hus.java\t2022-07-12 14:05:07.688687033 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(value)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:10.516667394 +0200\n+++ /tmp/tmpapvaq47p.java\t2022-07-12 14:05:10.516667394 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(value)\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _unknownType; no collision listType = context.findType(actualType, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:13.408647307 +0200\n+++ /tmp/tmpk73gqnr2.java\t2022-07-12 14:05:13.408647307 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(actualType, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(actualType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:15.760630972 +0200\n+++ /tmp/tmpit_xa97a.java\t2022-07-12 14:05:15.836630443 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(actualType);\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _unknownType; no collision listType = context.findType(actualType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:18.396612662 +0200\n+++ /tmp/tmpf73a29cw.java\t2022-07-12 14:05:18.428612440 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(actualType);\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _unknownType; /* declared if it's || context.findType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:20.932595048 +0200\n+++ /tmp/tmpu52h45mf.java\t2022-07-12 14:05:21.020594437 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if it's || context.findType) {\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _unknownType; no collision listType = context.findType(value)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:23.584576627 +0200\n+++ /tmp/tmp8tja5cas.java\t2022-07-12 14:05:23.632576294 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(value)\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:26.088559233 +0200\n+++ /tmp/tmprsf432dn.java\t2022-07-12 14:05:26.092559207 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared if necessary, actualType = context.findType(actualType, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _unknownType; /* declared iffracts || context.findType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:28.644541478 +0200\n+++ /tmp/tmpyfb22rap.java\t2022-07-12 14:05:28.684541201 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; /* declared iffracts || context.findType) {\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _unknownType; no collision listType = context.findType(actualType, _unknownClass, _unknownClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-11/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 14:05:31.172523918 +0200\n+++ /tmp/tmp_wajvtlw.java\t2022-07-12 14:05:31.172523918 +0200\n@@ -890,18 +890,11 @@\n     {\n         final String name = type.getName();\n         // 19-Mar-2015: Without context, all we can check are bounds.\n         if (context == null) {\n             // And to prevent infinite loops, now need this:\n-            return _unknownType();\n-        } else {\n-            // Ok: here's where context might come in handy!\n-            /* 19-Mar-2015, tatu: As per [databind#609], may need to allow\n-             *   unresolved type variables to handle some cases where bounds\n-             *   are enough. Let's hope it does not hide real fail cases.\n-             */\n-            JavaType actualType = context.findType(name);\n+return _unknownType; no collision listType = context.findType(actualType, _unknownClass, _unknownClass;\n             if (actualType != null) {\n                 return actualType;\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _unknownType(); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name);",
        "fixed_line": "context = new TypeBindings(this, (Class<?>) null); } else { // Ok: here's where context might come in handy! /* 19-Mar-2015, tatu: As per [databind#609], may need to allow * unresolved type variables to handle some cases where bounds * are enough. Let's hope it does not hide real fail cases. */ JavaType actualType = context.findType(name, false);"
    },
    "Lang-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "stopTime = this.runningState!= STATE_STOPPED; }",
                "patch_diff": "stopTime = this.runningState!= STATE_STOPPED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.runningState = STATE_STOPPED;",
                "patch_diff": "this.runningState = STATE_STOPPED;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.runningState = STATE_STOPPED; }",
                "patch_diff": "this.runningState = STATE_STOPPED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_STOPPED; }",
                "patch_diff": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_STOPPED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED; }",
                "patch_diff": "if(this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if(this.runningState!= STATE_STOPPED || this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_STOPPED || this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "stopTime = this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "patch_diff": "stopTime = this.runningState!= STATE_STOPPED && this.runningState!= STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if(this.runningState!= STATE_STOPPED && this.runningState == STATE_SUSPENDED) {",
                "patch_diff": "if(this.runningState!= STATE_STOPPED && this.runningState == STATE_SUSPENDED) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(this.runningState == STATE_RUNNING) { stopTime = System.currentTimeMillis(); }"
    },
    "Chart-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "super(paint, stroke, outlinePaint, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:36.552486544 +0200\n+++ /tmp/tmp0oaxo735.java\t2022-07-12 14:05:36.572486402 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "super(paint, stroke, outlinePaint, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:38.792470981 +0200\n+++ /tmp/tmpyoolvo_3.java\t2022-07-12 14:05:38.792470981 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "super(paint, stroke, outlinePaint, outlineStroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:40.504459085 +0200\n+++ /tmp/tmpmyu7277c.java\t2022-07-12 14:05:40.508459059 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "super(label, stroke, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:49.316397860 +0200\n+++ /tmp/tmpgwxtpcog.java\t2022-07-12 14:05:49.316397860 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(label, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "super(paint, stroke, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:50.988386243 +0200\n+++ /tmp/tmpni0ux6rv.java\t2022-07-12 14:05:50.988386243 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "super(paint, stroke, outlinePaint, bar, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:05:58.872331457 +0200\n+++ /tmp/tmpyec6tctd.java\t2022-07-12 14:05:58.872331457 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, bar, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "super(paint, stroke, outlinePaint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:06:00.528319952 +0200\n+++ /tmp/tmpmy28yxtm.java\t2022-07-12 14:06:00.532319924 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "super(value, stroke, paint, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:06:08.356265550 +0200\n+++ /tmp/tmps88g9wcw.java\t2022-07-12 14:06:08.356265550 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(value, stroke, paint, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "super(paint, stroke, outlinePaint, alpha, alpha, stroke, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:06:10.048253792 +0200\n+++ /tmp/tmp5oc5vrlx.java\t2022-07-12 14:06:10.048253792 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha, alpha, stroke, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "super(paint, stroke, outlinePaint, alpha);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-20/source/org/jfree/chart/plot/ValueMarker.java\t2022-07-12 14:06:11.780241753 +0200\n+++ /tmp/tmpevrr6tf6.java\t2022-07-12 14:06:11.780241753 +0200\n@@ -90,11 +90,11 @@\n      * @param outlineStroke  the outline stroke (<code>null</code> permitted).\n      * @param alpha  the alpha transparency (in the range 0.0f to 1.0f).\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, alpha);\n         this.value = value;\n     }\n     \n     /**\n      * Returns the value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "super(paint, stroke, paint, stroke, alpha);",
        "fixed_line": "super(paint, stroke, outlinePaint, outlineStroke, alpha);"
    },
    "Lang-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (f = createFloat(str.doubleValue() == 0.0) {",
                "patch_diff": "return (f = createFloat(str.doubleValue() == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return f.doubleValue() == 0.0;",
                "patch_diff": "return f.doubleValue() == 0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (f.isInfinite() &&!allZeros == 0.0) {",
                "patch_diff": "if (f.isInfinite() &&!allZeros == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (f = createFloat(str.doubleValue() == 0.0;",
                "patch_diff": "return (f = createFloat(str.doubleValue() == 0.0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (f.isInfinite() &&!allZeros) {",
                "patch_diff": "if (f.isInfinite() &&!allZeros) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (f.doubleValue() == 0.0 ||!allZeros))) {",
                "patch_diff": "return (f.doubleValue() == 0.0 ||!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (f.doubleValue() == 0.0) {",
                "patch_diff": "return (f.doubleValue() == 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (d.isInfinite() &&!allZeros))) {",
                "patch_diff": "return (d.isInfinite() &&!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (f.doubleValue() == 0.0 ||!allZeros) {",
                "patch_diff": "return (f.doubleValue() == 0.0 ||!allZeros) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (f.isInfinite() &&!allZeros))) {",
                "patch_diff": "if (f.isInfinite() &&!allZeros))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(numDecimals <= 7){// If number has 7 or fewer digits past the decimal point then make it a float final Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } } catch (final NumberFormatException nfe) { // NOPMD // ignore the bad number } try { if(numDecimals <= 16){// If number has between 8 and 16 digits past the decimal point then make it a double final Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } }"
    },
    "Lang-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (mTimeZoneForced) {",
                "patch_diff": "if (mTimeZoneForced) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (mTimeZoneForced) {",
                "patch_diff": "return (mTimeZoneForced) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this.mTimeZoneForced;",
                "patch_diff": "return this.mTimeZoneForced;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int calendar = (mTimeZoneForced) calendar.clone();",
                "patch_diff": "private static final /*day*/int calendar = (mTimeZoneForced) calendar.clone();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] buf = (Calendar) calendar.clone();",
                "patch_diff": "private static final /*day*/int[] buf = (Calendar) calendar.clone();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] buf = (Calendar) calendar;",
                "patch_diff": "private static final /*day*/int[] buf = (Calendar) calendar;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public StringBuffer buf = (Calendar) { calendar.clone(); } return applyRules(Calendar.HOUR_OF_DAY;",
                "patch_diff": "public StringBuffer buf = (Calendar) { calendar.clone(); } return applyRules(Calendar.HOUR_OF_DAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (mTimeZone.clone(Calendar.HOUR_OF_DAY) {",
                "patch_diff": "if (mTimeZone.clone(Calendar.HOUR_OF_DAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return return this.mTimeZoneForced;",
                "patch_diff": "return return this.mTimeZoneForced;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public StringBuffer buf = (Calendar) { calendar = (Calendar) calendar.clone(); }",
                "patch_diff": "public StringBuffer buf = (Calendar) { calendar = (Calendar) calendar.clone(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "calendar.getTime(); /// LANG-538"
    },
    "Closure-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (target!= null && target.get(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:06:17.172204279 +0200\n+++ /tmp/tmp9cobaaqs.java\t2022-07-12 14:06:17.228203889 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.get(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (target!= null && tail.target) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:06:22.480167383 +0200\n+++ /tmp/tmp7b3rjs6o.java\t2022-07-12 14:06:22.480167383 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && tail.target) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (target!= null && target.equals(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:06:26.176141693 +0200\n+++ /tmp/tmp793tae40.java\t2022-07-12 14:06:26.180141664 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.equals(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (target!= null && names.target) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:06:29.488118670 +0200\n+++ /tmp/tmp0tz54ka0.java\t2022-07-12 14:06:29.492118642 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && names.target) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (target!= null && target.equals(qualifiedName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:06:33.156093171 +0200\n+++ /tmp/tmpjudfihdf.java\t2022-07-12 14:06:33.156093171 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.equals(qualifiedName)) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (target == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:07:11.819824338 +0200\n+++ /tmp/tmpkzgrdgyn.java\t2022-07-12 14:07:11.819824338 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (target!= null && target.getFirstChild) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:07:48.511569118 +0200\n+++ /tmp/tmpfoyhvxej.java\t2022-07-12 14:07:48.511569118 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.getFirstChild) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (target!= null && target.getString) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:07:52.163543712 +0200\n+++ /tmp/tmp9cw5_55q.java\t2022-07-12 14:07:52.163543712 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target!= null && target.getString) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (target == null && target.get(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:07:55.627519613 +0200\n+++ /tmp/tmpsqrmql21.java\t2022-07-12 14:07:55.627519613 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.get(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (target == null && target.equals(qualifiedName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-57/src/com/google/javascript/jscomp/ClosureCodingConvention.java\t2022-07-12 14:07:58.863497100 +0200\n+++ /tmp/tmpg15n59la.java\t2022-07-12 14:07:58.863497100 +0200\n@@ -192,11 +192,11 @@\n       Node callee = node.getFirstChild();\n       if (callee != null && callee.getType() == Token.GETPROP) {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target == null && target.equals(qualifiedName) {\n             className = target.getString();\n           }\n         }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (target != null) {",
        "fixed_line": "if (target != null && target.getType() == Token.STRING) {"
    },
    "Closure-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private boolean hasExceptionHandlerUse(cfg, n, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfg, n, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private boolean hasExceptionHandlerUse(Node, n, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(Node, n, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private boolean hasExceptionHandlerUse((cfgNode, n, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse((cfgNode, n, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private boolean hasExceptionHandlerUse(cfg, n, cfgNode, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfg, n, cfgNode, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, cfgNode, output, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, cfgNode, output, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, conditional);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, output, conditional) {",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, output, conditional) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, conditional) {",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, conditional) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private boolean hasExceptionHandlerUse(cfgNode, n, output);",
                "patch_diff": "private boolean hasExceptionHandlerUse(cfgNode, n, output);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode); for (DiGraphEdge<Node, Branch> edge : branchEdges) { if (edge.getValue() == Branch.ON_EX) { return true; } }"
    },
    "Math-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "targetY = -REQUI || this.yB; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:04.099460668 +0200\n+++ /tmp/tmpc4vyy_09.java\t2022-07-12 14:08:04.127460474 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "targetY = -RE true; } else if (targetY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:07.099439794 +0200\n+++ /tmp/tmp94en9e9l.java\t2022-07-12 14:08:07.099439794 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "targetY = -RE true; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:08.987426657 +0200\n+++ /tmp/tmp9x_lja4i.java\t2022-07-12 14:08:08.987426657 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "targetY = -RE true; } else if (targetY == targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:10.991412711 +0200\n+++ /tmp/tmpkd53t4fm.java\t2022-07-12 14:08:10.991412711 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY == targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "targetY = -REQUI || this.yB; } else if (targetY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:13.015398629 +0200\n+++ /tmp/tmp96l5xntp.java\t2022-07-12 14:08:13.015398629 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "targetY = -REQUI || this.yB; } else if (targetY == targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:15.111384043 +0200\n+++ /tmp/tmpf19_mwm4.java\t2022-07-12 14:08:15.111384043 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetY == targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "targetY = -REyB; } else if (targetYY > targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:17.215369404 +0200\n+++ /tmp/tmpx49zvwr8.java\t2022-07-12 14:08:17.215369404 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REyB; } else if (targetYY > targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "targetY = -REASON * 2, targetY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:19.295354931 +0200\n+++ /tmp/tmpeu6rblk4.java\t2022-07-12 14:08:19.299354902 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REASON * 2, targetY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "targetY = -RE true; } else if (targetY == targetYY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:21.319340845 +0200\n+++ /tmp/tmpa0vtd39a.java\t2022-07-12 14:08:21.323340817 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -RE true; } else if (targetY == targetYY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "targetY = -REQUI || this.yB; } else if (targetYY > targetYY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-40/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\t2022-07-12 14:08:23.323326900 +0200\n+++ /tmp/tmpp0av7m3j.java\t2022-07-12 14:08:23.327326872 +0200\n@@ -230,14 +230,11 @@\n \n             // target for the next evaluation point\n             double targetY;\n             if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+targetY = -REQUI || this.yB; } else if (targetYY > targetYY) {\n             } else {\n                 // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "targetY = -REDUCTION_FACTOR * yB; } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this targetY = -REDUCTION_FACTOR * yA;",
        "fixed_line": "final int p = agingA - MAXIMAL_AGING; final double weightA = (1 << p) - 1; final double weightB = p + 1; targetY = (weightA * yA - weightB * REDUCTION_FACTOR * yB) / (weightA + weightB); } else if (agingB >= MAXIMAL_AGING) { // we keep updating the low bracket, try to compensate this final int p = agingB - MAXIMAL_AGING; final double weightA = p + 1; final double weightB = (1 << p) - 1; targetY = (weightB * yB - weightA * REDUCTION_FACTOR * yA) / (weightA + weightB);"
    },
    "Csv-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:25.715310253 +0200\n+++ /tmp/tmpy_0_9osn.java\t2022-07-12 14:08:25.775309836 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:27.503297810 +0200\n+++ /tmp/tmpub1sz8nb.java\t2022-07-12 14:08:27.503297810 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:29.055287009 +0200\n+++ /tmp/tmpe4f7ejhc.java\t2022-07-12 14:08:29.055287009 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:30.575276430 +0200\n+++ /tmp/tmp5thftad8.java\t2022-07-12 14:08:30.579276401 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:32.147265490 +0200\n+++ /tmp/tmpc26v9a_x.java\t2022-07-12 14:08:32.147265490 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:33.903253270 +0200\n+++ /tmp/tmp5xz5mz09.java\t2022-07-12 14:08:33.903253270 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:35.523241995 +0200\n+++ /tmp/tmpot99j_em.java\t2022-07-12 14:08:35.523241995 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a'\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:37.059231305 +0200\n+++ /tmp/tmp3nh4fcai.java\t2022-07-12 14:08:37.059231305 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' && c < 'A' || c > 'Z' || c < 'a' || c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:38.747219556 +0200\n+++ /tmp/tmp3e66wv11.java\t2022-07-12 14:08:38.747219556 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (c < '0' || (c > '9' && c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-14/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 14:08:43.279188013 +0200\n+++ /tmp/tmplmi480ia.java\t2022-07-12 14:08:43.279188013 +0200\n@@ -1034,11 +1034,11 @@\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+if (first && (c < '0' || c > '9' || c < 'A' || c > 'Z' || c < 'a' && c > 'z')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
        "fixed_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {"
    },
    "Time-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:45.283174065 +0200\n+++ /tmp/tmpivbmfkda.java\t2022-07-12 14:08:45.327173759 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:47.035161870 +0200\n+++ /tmp/tmpt_tcqcib.java\t2022-07-12 14:08:47.035161870 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:48.627150789 +0200\n+++ /tmp/tmpnhfmogxi.java\t2022-07-12 14:08:48.627150789 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:50.211139764 +0200\n+++ /tmp/tmphtn0ccvh.java\t2022-07-12 14:08:50.215139736 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:51.751129045 +0200\n+++ /tmp/tmpe02lw3li.java\t2022-07-12 14:08:51.751129045 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:53.335118017 +0200\n+++ /tmp/tmpryykq_v2.java\t2022-07-12 14:08:53.335118017 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:54.867107355 +0200\n+++ /tmp/tmpj7teefe6.java\t2022-07-12 14:08:54.871107327 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputputputputput12DST\", \"Linenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:56.479096135 +0200\n+++ /tmp/tmp8rnntqg9.java\t2022-07-12 14:08:56.479096135 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputputputputput12DST\", \"Linenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:57.979085692 +0200\n+++ /tmp/tmpezm5ydcj.java\t2022-07-12 14:08:58.003085523 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoeno);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-23/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:08:59.591074472 +0200\n+++ /tmp/tmpcvwyenyk.java\t2022-07-12 14:08:59.595074444 +0200\n@@ -567,27 +567,11 @@\n             map.put(\"PST\", \"America/Los_Angeles\");\n             map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n             map.put(\"PNT\", \"America/Phoenix\");\n             map.put(\"CST\", \"America/Chicago\");\n             map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n-            map.put(\"IET\", \"America/Indianapolis\");\n-            map.put(\"PRT\", \"America/Puerto_Rico\");\n-            map.put(\"CNT\", \"America/St_Johns\");\n-            map.put(\"AGT\", \"America/Buenos_Aires\");\n-            map.put(\"BET\", \"America/Sao_Paulo\");\n-            map.put(\"WET\", \"Europe/London\");\n-            map.put(\"ECT\", \"Europe/Paris\");\n-            map.put(\"ART\", \"Africa/Cairo\");\n-            map.put(\"CAT\", \"Africa/Harare\");\n-            map.put(\"EET\", \"Europe/Bucharest\");\n-            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n-            map.put(\"MET\", \"Asia/Tehran\");\n-            map.put(\"NET\", \"Asia/Yerevan\");\n-            map.put(\"PLT\", \"Asia/Karachi\");\n-            map.put(\"IST\", \"Asia/Calcutta\");\n-            map.put(\"BST\", \"Asia/Dhaka\");\n-            map.put(\"VST\", \"Asia/Saigon\");\n+map.put(\"Horizontal/ET\", map.putputputputputputputput12DST\", \"Linenoenoenoenoenoeno);\n             map.put(\"CTT\", \"Asia/Shanghai\");\n             map.put(\"JST\", \"Asia/Tokyo\");\n             map.put(\"ACT\", \"Australia/Darwin\");\n             map.put(\"AET\", \"Australia/Sydney\");\n             map.put(\"SST\", \"Pacific/Guadalcanal\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "map.put(\"IET\", \"America/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"WET\", \"Europe/London\"); map.put(\"ECT\", \"Europe/Paris\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EET\", \"Europe/Bucharest\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"MET\", \"Asia/Tehran\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Calcutta\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Saigon\");",
        "fixed_line": "map.put(\"WET\", \"WET\"); map.put(\"CET\", \"CET\"); map.put(\"MET\", \"CET\"); map.put(\"ECT\", \"CET\"); map.put(\"EET\", \"EET\"); map.put(\"MIT\", \"Pacific/Apia\"); map.put(\"HST\", \"Pacific/Honolulu\"); // JDK 1.1 compatible map.put(\"AST\", \"America/Anchorage\"); map.put(\"PST\", \"America/Los_Angeles\"); map.put(\"MST\", \"America/Denver\"); // JDK 1.1 compatible map.put(\"PNT\", \"America/Phoenix\"); map.put(\"CST\", \"America/Chicago\"); map.put(\"EST\", \"America/New_York\"); // JDK 1.1 compatible map.put(\"IET\", \"America/Indiana/Indianapolis\"); map.put(\"PRT\", \"America/Puerto_Rico\"); map.put(\"CNT\", \"America/St_Johns\"); map.put(\"AGT\", \"America/Argentina/Buenos_Aires\"); map.put(\"BET\", \"America/Sao_Paulo\"); map.put(\"ART\", \"Africa/Cairo\"); map.put(\"CAT\", \"Africa/Harare\"); map.put(\"EAT\", \"Africa/Addis_Ababa\"); map.put(\"NET\", \"Asia/Yerevan\"); map.put(\"PLT\", \"Asia/Karachi\"); map.put(\"IST\", \"Asia/Kolkata\"); map.put(\"BST\", \"Asia/Dhaka\"); map.put(\"VST\", \"Asia/Ho_Chi_Minh\");"
    },
    "Math-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:01.383061997 +0200\n+++ /tmp/tmpvd8j6m4x.java\t2022-07-12 14:09:01.415061772 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:03.499047265 +0200\n+++ /tmp/tmpod1cf5_r.java\t2022-07-12 14:09:03.503047240 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:05.451033676 +0200\n+++ /tmp/tmpouerueat.java\t2022-07-12 14:09:05.451033676 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability(t));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:07.475019588 +0200\n+++ /tmp/tmp1ka4jpum.java\t2022-07-12 14:09:07.475019588 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability(t));\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "out[i][j] = 2 * r; - tDistribution.cumulativeProbability) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:09.443005888 +0200\n+++ /tmp/tmpn86kox9m.java\t2022-07-12 14:09:09.443005888 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; - tDistribution.cumulativeProbability) {\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:11.498991575 +0200\n+++ /tmp/tmpjcw2vlta.java\t2022-07-12 14:09:11.498991575 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "out[i][j] = 2 * r; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:13.454977958 +0200\n+++ /tmp/tmpiarhn9lf.java\t2022-07-12 14:09:13.454977958 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; }\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "out[i][j] = 2 * r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:15.454964034 +0200\n+++ /tmp/tmpqbnnrx1z.java\t2022-07-12 14:09:15.458964006 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "out[i][j] = 2 * r.cumulativeProbability(t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:22.678913737 +0200\n+++ /tmp/tmp7mn107sk.java\t2022-07-12 14:09:22.678913737 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r.cumulativeProbability(t;\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "out[i][j] = 2 * r; tDistribution.cumulativeProbability) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-69/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\t2022-07-12 14:09:24.666899898 +0200\n+++ /tmp/tmpjzwb7utb.java\t2022-07-12 14:09:24.670899869 +0200\n@@ -166,11 +166,11 @@\n                 if (i == j) {\n                     out[i][j] = 0d;\n                 } else {\n                     double r = correlationMatrix.getEntry(i, j);\n                     double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n-                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+out[i][j] = 2 * r; tDistribution.cumulativeProbability) {\n                 }\n             }\n         }\n         return new BlockRealMatrix(out);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
        "fixed_line": "out[i][j] = 2 * tDistribution.cumulativeProbability(-t);"
    },
    "Math-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (u1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:26.878884497 +0200\n+++ /tmp/tmpp1ev4mp2.java\t2022-07-12 14:09:26.906884301 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (u1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (k1 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:30.442859682 +0200\n+++ /tmp/tmp4lgl76n3.java\t2022-07-12 14:09:30.458859568 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:32.558844946 +0200\n+++ /tmp/tmpomrk2846.java\t2022-07-12 14:09:32.558844946 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (k1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:34.534831190 +0200\n+++ /tmp/tmpo8_mnx_0.java\t2022-07-12 14:09:34.534831190 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (k1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:36.506817458 +0200\n+++ /tmp/tmpljrommhd.java\t2022-07-12 14:09:36.534817261 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (k1 > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:38.530803365 +0200\n+++ /tmp/tmpxcgulves.java\t2022-07-12 14:09:38.530803365 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k1 > 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c1 == v2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:40.542789355 +0200\n+++ /tmp/tmphoko4oor.java\t2022-07-12 14:09:40.546789327 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (c1 == v2) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (v1 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:42.510775649 +0200\n+++ /tmp/tmpv0yxeayy.java\t2022-07-12 14:09:42.510775649 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (v1 == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (u1!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:44.510761725 +0200\n+++ /tmp/tmppe5wkwvn.java\t2022-07-12 14:09:44.510761725 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (u1!= 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (k == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-52/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Rotation.java\t2022-07-12 14:09:46.602747154 +0200\n+++ /tmp/tmpg5h3hkqr.java\t2022-07-12 14:09:46.602747154 +0200\n@@ -339,26 +339,11 @@\n   Vector3D v1Su1 = v1.subtract(u1);\n   Vector3D v2Su2 = v2.subtract(u2);\n   Vector3D k     = v1Su1.crossProduct(v2Su2);\n   Vector3D u3    = u1.crossProduct(u2);\n   double c       = k.dotProduct(u3);\n-  if (c == 0) {\n-    // the (q1, q2, q3) vector is close to the (u1, u2) plane\n-    // we try other vectors\n-    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n-    Vector3D v3Su3 = v3.subtract(u3);\n-    k = v1Su1.crossProduct(v3Su3);\n-    Vector3D u2Prime = u1.crossProduct(u3);\n-    c = k.dotProduct(u2Prime);\n-\n-    if (c == 0) {\n-      // the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n-      // it is almost aligned with u1: we try (u2, u3) and (v2, v3)\n-      k = v2Su2.crossProduct(v3Su3);;\n-      c = k.dotProduct(u2.crossProduct(u3));;\n-\n-      if (c == 0) {\n+if (k == 0) {\n         // the (q1, q2, q3) vector is aligned with everything\n         // this is really the identity rotation\n         q0 = 1.0;\n         q1 = 0.0;\n         q2 = 0.0;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c == 0) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c == 0) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c == 0) {",
        "fixed_line": "final double inPlaneThreshold = 0.001; if (c <= inPlaneThreshold * k.getNorm() * u3.getNorm()) { // the (q1, q2, q3) vector is close to the (u1, u2) plane // we try other vectors Vector3D v3 = Vector3D.crossProduct(v1, v2); Vector3D v3Su3 = v3.subtract(u3); k = v1Su1.crossProduct(v3Su3); Vector3D u2Prime = u1.crossProduct(u3); c = k.dotProduct(u2Prime); if (c <= inPlaneThreshold * k.getNorm() * u2Prime.getNorm()) { // the (q1, q2, q3) vector is also close to the (u1, u3) plane, // it is almost aligned with u1: we try (u2, u3) and (v2, v3) k = v2Su2.crossProduct(v3Su3);; c = k.dotProduct(u2.crossProduct(u3));; if (c <= 0) {"
    },
    "Gson-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:48.934730918 +0200\n+++ /tmp/tmpwbgq8ir1.java\t2022-07-12 14:09:48.994730501 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:50.690718687 +0200\n+++ /tmp/tmp2aothjcv.java\t2022-07-12 14:09:50.690718687 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (Double.isNaN(value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:52.190708243 +0200\n+++ /tmp/tmppqzw2vgx.java\t2022-07-12 14:09:52.190708243 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (Double.isNaN(value || Double.isInfinite()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:53.734697490 +0200\n+++ /tmp/tmpanqfdjxx.java\t2022-07-12 14:09:53.734697490 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite()) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (Double.isNaN || Double.isInfinite(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:55.210687212 +0200\n+++ /tmp/tmpkvbn7jnb.java\t2022-07-12 14:09:55.214687182 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (Double.isNaN || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:56.702676822 +0200\n+++ /tmp/tmp4vdhbw3j.java\t2022-07-12 14:09:56.702676822 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (Double.isNaN(value || Double.isInfinite(_value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:58.294665735 +0200\n+++ /tmp/tmpzh96gxls.java\t2022-07-12 14:09:58.294665735 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(_value) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (Double.isNaN || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:09:59.742655651 +0200\n+++ /tmp/tmptbi0a914.java\t2022-07-12 14:09:59.746655622 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(_value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:10:01.398644118 +0200\n+++ /tmp/tmpq8sd5z6d.java\t2022-07-12 14:10:01.398644118 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(_value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-15/gson/src/main/java/com/google/gson/stream/JsonWriter.java\t2022-07-12 14:10:02.930633448 +0200\n+++ /tmp/tmp489zqwjl.java\t2022-07-12 14:10:02.930633448 +0200\n@@ -490,11 +490,11 @@\n    *     {@link Double#isInfinite() infinities}.\n    * @return this writer.\n    */\n   public JsonWriter value(double value) throws IOException {\n     writeDeferredName();\n-    if (Double.isNaN(value) || Double.isInfinite(value)) {\n+if (Double.isNaN(value || Double.isInfinite(value || Double.isInfinite(value)) {\n       throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n     }\n     beforeValue();\n     out.append(Double.toString(value));\n     return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Double.isNaN(value) || Double.isInfinite(value)) {",
        "fixed_line": "if (!lenient && (Double.isNaN(value) || Double.isInfinite(value))) {"
    },
    "Chart-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "TimeSeriesDataItem item = start; index <= end;",
                "patch_diff": "TimeSeriesDataItem item = start; index <= end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone; index++) {",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone; index++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data;",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone;",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone();",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TimeSeries copy = this.data.clone; index <= end;",
                "patch_diff": "TimeSeries copy = this.data.clone; index <= end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone; index <= end;",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data.clone; index <= end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TimeSeriesDataItem item = start;",
                "patch_diff": "TimeSeriesDataItem item = start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TimeSeries copy = (TimeSeriesDataItem) this.data; index++) {",
                "patch_diff": "TimeSeries copy = (TimeSeriesDataItem) this.data; index++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.data.clone() > start) {",
                "patch_diff": "if (this.data.clone() > start) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "copy.minY = Double.NaN; copy.maxY = Double.NaN;"
    },
    "JxPath-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:06.334609742 +0200\n+++ /tmp/tmpqfguz_ga.java\t2022-07-12 14:10:06.354609601 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:08.654593584 +0200\n+++ /tmp/tmp0pcevcoy.java\t2022-07-12 14:10:08.654593584 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? context : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:10.154583134 +0200\n+++ /tmp/tmpvgvzr3t4.java\t2022-07-12 14:10:10.154583134 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? context : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? context : args;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:11.694572408 +0200\n+++ /tmp/tmpqfrajzz4.java\t2022-07-12 14:10:11.694572408 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? context : args;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:13.198561935 +0200\n+++ /tmp/tmpjxe4s3ns.java\t2022-07-12 14:10:13.198561935 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue : context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:14.626551989 +0200\n+++ /tmp/tmpr_x3gs5f.java\t2022-07-12 14:10:14.626551989 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue : context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? context :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:16.042542127 +0200\n+++ /tmp/tmpgj7x44li.java\t2022-07-12 14:10:16.042542127 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? context :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:17.534531735 +0200\n+++ /tmp/tmpm_x2n3j5.java\t2022-07-12 14:10:17.534531735 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[0].computeValue(context? Boolean.TRUEValue :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:19.114520727 +0200\n+++ /tmp/tmpir983fz7.java\t2022-07-12 14:10:19.114520727 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? Boolean.TRUEValue :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return computeValue[0].computeValue(context == args[1].computeValue(context? context :context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-10/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\t2022-07-12 14:10:21.918501200 +0200\n+++ /tmp/tmpde4xgkuu.java\t2022-07-12 14:10:21.918501200 +0200\n@@ -37,11 +37,11 @@\n     protected CoreOperationRelationalExpression(Expression[] args) {\n         super(args);\n     }\n \n     public final Object computeValue(EvalContext context) {\n-        return compute(args[0].computeValue(context), args[1].computeValue(context)) \n+return computeValue[0].computeValue(context == args[1].computeValue(context? context :context;\n                 ? Boolean.TRUE : Boolean.FALSE;\n     }\n \n     protected final int getPrecedence() {\n         return 3;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return compute(args[0].computeValue(context), args[1].computeValue(context))",
        "fixed_line": "return compute(args[0].compute(context), args[1].compute(context))"
    },
    "Gson-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "} else if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "// if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "// if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "// if (timezoneIndicator == '+' || timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "} else if (\"+\".equals(timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (offset == 0 && timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "if (offset == 0 && timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "patch_diff": "if (timezoneIndicator == '+' || timezoneIndicator == '-') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (timezoneIndicator == '+' || timezoneIndicator == 'J') {",
                "patch_diff": "} else if (timezoneIndicator == '+' || timezoneIndicator == 'J') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "timezoneOffset = timezoneOffset.length() >= 5 ? timezoneOffset : timezoneOffset + \"00\";"
    },
    "Math-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "return MIN_OUT_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:28.486455452 +0200\n+++ /tmp/tmpx5fe3b0i.java\t2022-07-12 14:10:28.838452998 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_MONTH;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return MIN_OUT_OF_BOUND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:33.806418390 +0200\n+++ /tmp/tmpynj2aaf3.java\t2022-07-12 14:10:33.806418390 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_BOUND;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return MIN_OUT_OF_STREAM;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:36.750397882 +0200\n+++ /tmp/tmplah4b2b1.java\t2022-07-12 14:10:36.750397882 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_STREAM;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return imaginary;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:39.850376290 +0200\n+++ /tmp/tmpx75z7ph3.java\t2022-07-12 14:10:39.854376262 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return imaginary;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return MIN_OUT_OF_CHAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:42.742356144 +0200\n+++ /tmp/tmptbop_ky3.java\t2022-07-12 14:10:42.742356144 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_CHAR;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return MIN_OUT_OF_EXTENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:45.598336248 +0200\n+++ /tmp/tmptuja_ga8.java\t2022-07-12 14:10:45.650335888 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_EXTENDED;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cinary;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:49.086311948 +0200\n+++ /tmp/tmpi7axc337.java\t2022-07-12 14:10:49.110311781 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return cinary;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return MIN_OUT_OF_MONTH_EXTENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:52.238289989 +0200\n+++ /tmp/tmpzbpyyyf1.java\t2022-07-12 14:10:52.238289989 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_MONTH_EXTENDED;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return MIN_OUT_OF_RANGE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:55.598266579 +0200\n+++ /tmp/tmp73rbhpfq.java\t2022-07-12 14:10:55.646266244 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_RANGE;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return MIN_OUT_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-5/src/main/java/org/apache/commons/math3/complex/Complex.java\t2022-07-12 14:10:58.370247269 +0200\n+++ /tmp/tmptq2lddqv.java\t2022-07-12 14:10:58.374247241 +0200\n@@ -300,11 +300,11 @@\n         if (isNaN) {\n             return NaN;\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return MIN_OUT_OF_YEAR;\n         }\n \n         if (isInfinite) {\n             return ZERO;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NaN;",
        "fixed_line": "return INF;"
    },
    "Closure-114": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (recordDepScope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:01.870222884 +0200\n+++ /tmp/tmplbncbwpo.java\t2022-07-12 14:11:02.158220878 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordDepScope) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (recordInfo) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:10.974159453 +0200\n+++ /tmp/tmpa1od1okn.java\t2022-07-12 14:11:10.974159453 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordInfo) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (parent) record.onlyAffectsClassDef) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:16.450121299 +0200\n+++ /tmp/tmphg8pgmeg.java\t2022-07-12 14:11:17.274115559 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent) record.onlyAffectsClassDef) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (recordFunction) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:23.746070461 +0200\n+++ /tmp/tmp2m4vh0tw.java\t2022-07-12 14:11:23.746070461 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordFunction) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:29.222032303 +0200\n+++ /tmp/tmp_0z3hpot.java\t2022-07-12 14:11:29.222032303 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (parent) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (recordOnly) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:34.297996932 +0200\n+++ /tmp/tmpd7xwpurp.java\t2022-07-12 14:11:34.305996875 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordOnly) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (elseHasScope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:39.685959384 +0200\n+++ /tmp/tmpkwm2izy1.java\t2022-07-12 14:11:39.685959384 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (elseHasScope) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (recordParent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:45.069921863 +0200\n+++ /tmp/tmpwmjrhwmb.java\t2022-07-12 14:11:45.073921837 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordParent) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (elseHasSideEffects) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:50.213886015 +0200\n+++ /tmp/tmpb22i9lyi.java\t2022-07-12 14:11:50.213886015 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (elseHasSideEffects) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (recordNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-114/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 14:11:55.317850443 +0200\n+++ /tmp/tmpabwrim9u.java\t2022-07-12 14:11:55.317850443 +0200\n@@ -573,11 +573,11 @@\n           if (parent.getFirstChild().getNext() != n) {\n             recordDepScope(recordNode, ns);\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+} else if (recordNode) {\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the\n           // caller expression, but it could be nested deeper in the caller and\n           // we would still get a bug.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (!(parent.isCall() && parent.getFirstChild() == n)) {"
    },
    "Chart-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:00.529814120 +0200\n+++ /tmp/tmp1nnb0gsg.java\t2022-07-12 14:12:00.749812592 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:09.985748213 +0200\n+++ /tmp/tmpt8m5tmsi.java\t2022-07-12 14:12:09.985748213 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:17.993692397 +0200\n+++ /tmp/tmpvszb_vks.java\t2022-07-12 14:12:17.997692369 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset = dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:25.973636773 +0200\n+++ /tmp/tmpar2t9bak.java\t2022-07-12 14:12:25.973636773 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:34.061580395 +0200\n+++ /tmp/tmpodqxsa3p.java\t2022-07-12 14:12:34.061580395 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:41.829526243 +0200\n+++ /tmp/tmpz1lhjz7l.java\t2022-07-12 14:12:41.829526243 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset (this.dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:49.785470782 +0200\n+++ /tmp/tmp791myjdz.java\t2022-07-12 14:12:49.801470668 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:12:57.789414981 +0200\n+++ /tmp/tmpzqn_myes.java\t2022-07-12 14:12:57.789414981 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:13:05.837358872 +0200\n+++ /tmp/tmpzb2xsd9_.java\t2022-07-12 14:13:05.853358760 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset when the dataset is to the dataset (this.dataset)\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-12/source/org/jfree/chart/plot/MultiplePiePlot.java\t2022-07-12 14:13:13.833303123 +0200\n+++ /tmp/tmp53e281xp.java\t2022-07-12 14:13:13.837303095 +0200\n@@ -140,11 +140,11 @@\n      *\n      * @param dataset  the dataset (<code>null</code> permitted).\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+this.dataset = dataset; // the dataset when the dataset is to the dataset is to the dataset (dataset) this.dataset;\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();\n         this.dataExtractOrder = TableOrder.BY_COLUMN;\n         this.pieChart.setBackgroundPaint(null);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this.dataset = dataset;",
        "fixed_line": "setDataset(dataset);"
    },
    "Lang-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = startIndex - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:13:21.853247205 +0200\n+++ /tmp/tmprpfdzxm0.java\t2022-07-12 14:13:21.893246926 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = strLen - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:13:32.057176056 +0200\n+++ /tmp/tmpk3iv14gi.java\t2022-07-12 14:13:32.057176056 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = strLen - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:13:41.337111346 +0200\n+++ /tmp/tmpc86q4she.java\t2022-07-12 14:13:41.337111346 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = thisBuf.length - startIndex;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:13:50.641046468 +0200\n+++ /tmp/tmpww777nrg.java\t2022-07-12 14:13:50.641046468 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - startIndex;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:13:59.828982394 +0200\n+++ /tmp/tmpyzq1f2rz.java\t2022-07-12 14:13:59.828982394 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = buffer.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:14:09.016918317 +0200\n+++ /tmp/tmp55vaii35.java\t2022-07-12 14:14:09.020918291 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = buffer.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = startIndex + thisBuf.length - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:14:18.276853738 +0200\n+++ /tmp/tmp598av98y.java\t2022-07-12 14:14:18.276853738 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = startIndex + thisBuf.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:14:27.532789183 +0200\n+++ /tmp/tmpsgnyi0jf.java\t2022-07-12 14:14:27.536789155 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = startIndex + thisBuf.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = i - strLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:14:36.724725073 +0200\n+++ /tmp/tmpjv9b20p1.java\t2022-07-12 14:14:36.724725073 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = i - strLen;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = buffer.length - thisBuf.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-61/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 14:14:38.412713298 +0200\n+++ /tmp/tmpk7ua0byj.java\t2022-07-12 14:14:38.412713298 +0200\n@@ -1771,11 +1771,11 @@\n         }\n         if (strLen > size) {\n             return -1;\n         }\n         char[] thisBuf = buffer;\n-        int len = thisBuf.length - strLen;\n+int len = buffer.length - thisBuf.length;\n         outer:\n         for (int i = startIndex; i < len; i++) {\n             for (int j = 0; j < strLen; j++) {\n                 if (str.charAt(j) != thisBuf[i + j]) {\n                     continue outer;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = thisBuf.length - strLen;",
        "fixed_line": "int len = size - strLen + 1;"
    },
    "Closure-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (isWordChar(c) || c == '\\\\') {",
                "patch_diff": "// if (isWordChar(c) || c == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// else if (isWordChar(c) || c == '\\\\') {",
                "patch_diff": "// else if (isWordChar(c) || c == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// else if (isWordChar(c) && isWordChar())) {",
                "patch_diff": "// else if (isWordChar(c) && isWordChar())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// else if (isNaN || c == '\\\\') {",
                "patch_diff": "// else if (isNaN || c == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (isNaN || c == '\\\\') {",
                "patch_diff": "// if (isNaN || c == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// else if (isWordChar(c) && c == '\\\\') {",
                "patch_diff": "// else if (isWordChar(c) && c == '\\\\') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// if (isWordChar(c) || c == '\\\\') && isWordChar())) {",
                "patch_diff": "// if (isWordChar(c) || c == '\\\\') && isWordChar())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (isWordChar(c) && isWordChar())) {",
                "patch_diff": "// if (isWordChar(c) && isWordChar())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// else if (isWordChar(c) || c == '\\\\') && isWordChar())) {",
                "patch_diff": "// else if (isWordChar(c) || c == '\\\\') && isWordChar())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (isWordChar(c) || c == '\\\\') && isWordChar(",
                "patch_diff": "// if (isWordChar(c) || c == '\\\\') && isWordChar(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (c == '/' && getLastChar() == '/') { // Do not allow a forward slash to appear after a DIV. // For example, // REGEXP DIV REGEXP // is valid and should print like // / // / / append(\" \");"
    },
    "Math-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (entry.compareTo(this.entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:14:49.760634146 +0200\n+++ /tmp/tmpjdr_9k1f.java\t2022-07-12 14:14:49.824633700 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(this.entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (entry.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:14:52.792612997 +0200\n+++ /tmp/tmp2tmnqmcz.java\t2022-07-12 14:14:52.796612969 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (font.compareTo(this.entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:14:55.000597596 +0200\n+++ /tmp/tmpjcy6tlye.java\t2022-07-12 14:14:55.000597596 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (font.compareTo(this.entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (mCol.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:14:57.120582808 +0200\n+++ /tmp/tmpcsa753hl.java\t2022-07-12 14:14:57.120582808 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (mCol.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (entry.compareTo(this.entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:14:59.156568606 +0200\n+++ /tmp/tmp18j9gjy7.java\t2022-07-12 14:14:59.156568606 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(this.entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (entry.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:15:01.212554264 +0200\n+++ /tmp/tmpzo_wnndq.java\t2022-07-12 14:15:01.212554264 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (entry.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ret.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:15:03.276539866 +0200\n+++ /tmp/tmp3rr15471.java\t2022-07-12 14:15:03.280539840 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (ret.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ret.compareTo(entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:15:05.424524883 +0200\n+++ /tmp/tmpxrusjlc8.java\t2022-07-12 14:15:05.424524883 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (ret.compareTo(entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (mCol.compareTo(entry, 0d, maximalIterationCount) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:15:07.368511323 +0200\n+++ /tmp/tmpifgjynt5.java\t2022-07-12 14:15:07.368511323 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (mCol.compareTo(entry, 0d, maximalIterationCount) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (font.compareTo(this.entry, 0d, 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-33/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\t2022-07-12 14:15:09.440496870 +0200\n+++ /tmp/tmprt9_k98j.java\t2022-07-12 14:15:09.440496870 +0200\n@@ -333,11 +333,11 @@\n         columnsToDrop.add(0);\n \n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+if (font.compareTo(this.entry, 0d, 0) {\n                 columnsToDrop.add(i);\n             }\n         }\n \n         // non-basic artificial variables\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
        "fixed_line": "if (Precision.compareTo(entry, 0d, epsilon) > 0) {"
    },
    "Time-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// out isize = iChronology + isize; i = partial.getField(iChronology).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "type dates = values[i]; i = partial.getField(iChronology).getField(iChronology);",
                "patch_diff": "type dates = values[i]; i = partial.getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(iChronology).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "iChronology = partial.getFieldType(i).getField(iChronology).getField(iChronology);",
                "patch_diff": "iChronology = partial.getFieldType(i).getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(iChronology).getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// out isize = iChronology + isize; i = partial.getField(iChronology).getField(iChronology).getField(iChronology);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getField(iChronology).getField(iChronology).getField(iChronology);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).set(instant);",
                "patch_diff": "// out isize = iChronology + isize; i = partial.getFieldType(i).getField(iChronology).set(instant);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (partial.size() > 0 && partial.getFieldType(0).equals(DateTimeFieldType.monthOfYear()) && fieldIndex == 0) { // month is largest field and being added to, such as month-day int curMonth0 = partial.getValue(0) - 1; int newMonth = ((curMonth0 + (valueToAdd % 12) + 12) % 12) + 1; return set(partial, 0, values, newMonth); }"
    },
    "JacksonXml-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "_initWithRootName((jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:13.612467765 +0200\n+++ /tmp/tmp_djliu8t.java\t2022-07-12 14:15:13.680467292 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_initWithRootName((jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:15.660453480 +0200\n+++ /tmp/tmp1qqhr9rj.java\t2022-07-12 14:15:15.660453480 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_initWithRootName((jgen, rootName, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:17.172442931 +0200\n+++ /tmp/tmp7u2ufb02.java\t2022-07-12 14:15:17.172442931 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:18.728432078 +0200\n+++ /tmp/tmpo9evdwqr.java\t2022-07-12 14:15:18.744431967 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:20.524419549 +0200\n+++ /tmp/tmp4rv2jro7.java\t2022-07-12 14:15:20.528419521 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_initWithRootName((jgen, rootName) jgen, ROOT_NAME_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:29.836354587 +0200\n+++ /tmp/tmp8a5b6alk.java\t2022-07-12 14:15:29.836354587 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName) jgen, ROOT_NAME_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_initWithRootName((jgen, rootName) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:31.392343731 +0200\n+++ /tmp/tmpkxtorcht.java\t2022-07-12 14:15:31.392343731 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_initWithRootName((jgen, rootName, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:32.992332569 +0200\n+++ /tmp/tmp57agvqrh.java\t2022-07-12 14:15:32.992332569 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_initWithRootName((jgen, rootName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:34.540321770 +0200\n+++ /tmp/tmp009pylk5.java\t2022-07-12 14:15:34.540321770 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen, rootName);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_initWithRootName((jgen) jgen, ROOT_FOR_NULL);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-4/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 14:15:36.116310776 +0200\n+++ /tmp/tmp8zt57_fc.java\t2022-07-12 14:15:36.116310776 +0200\n@@ -200,11 +200,11 @@\n     protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n     {\n         // 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n         //    configured root name...\n         if (jgen instanceof ToXmlGenerator) {\n-            _initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n+_initWithRootName((jgen) jgen, ROOT_FOR_NULL);\n         }\n         super.serializeValue(jgen, null);\n     }\n     \n     protected void _startRootArray(ToXmlGenerator xgen, QName rootName) throws IOException\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);",
        "fixed_line": "QName rootName = _rootNameFromConfig(); if (rootName == null) { rootName = ROOT_NAME_FOR_NULL; } if (jgen instanceof ToXmlGenerator) { _initWithRootName((ToXmlGenerator) jgen, rootName);"
    },
    "JacksonDatabind-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate()', but null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J':':",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J':':",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J'\");",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J'\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\")\");",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\")\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\");",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'getDelegateType()'\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate() +\")\");",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingDelegate() +\")\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J'",
                "patch_diff": "throw new IllegalArgumentException(\"Invalid delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'J'",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (_valueInstantiator.canCreateUsingArrayDelegate()) { JavaType delegateType = _valueInstantiator.getArrayDelegateType(ctxt.getConfig()); if (delegateType == null) { throw new IllegalArgumentException(\"Invalid array-delegate-creator definition for \"+_collectionType +\": value instantiator (\"+_valueInstantiator.getClass().getName() +\") returned true for 'canCreateUsingArrayDelegate()', but null for 'getArrayDelegateType()'\"); } delegateDeser = findDeserializer(ctxt, delegateType, property);"
    },
    "Lang-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c1 == null || cs2 == null) { return false; }",
                "patch_diff": "if (c1 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (c1 == null || cs2 == null) { return false; }",
                "patch_diff": "} else if (c1 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (check2 == null || cs2 == null) { return false; }",
                "patch_diff": "} else if (check2 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (bits1 == null || cs2 == null) { return false; }",
                "patch_diff": "if (bits1 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ch1 == null || cs2 == null) { return false; }",
                "patch_diff": "if (ch1 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c1!= null && cs2 == null) { return false; }",
                "patch_diff": "if (c1!= null && cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c1 == null || cs2 == null) { return false; } return cs1.equals(",
                "patch_diff": "if (c1 == null || cs2 == null) { return false; } return cs1.equals(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (bits1 == null || cs2 == null) { return false; } return cs1.equals(",
                "patch_diff": "if (bits1 == null || cs2 == null) { return false; } return cs1.equals(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value1 == null || cs2 == null) { return false; }",
                "patch_diff": "if (value1 == null || cs2 == null) { return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c1 == null || cs2 == null) {",
                "patch_diff": "if (c1 == null || cs2 == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));"
    },
    "Cli-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"--\")) {",
                "patch_diff": "if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return str.startsWith(\"--\")) {",
                "patch_diff": "return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) {",
                "patch_diff": "} else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str; } else if (str.startsWith(\"--\")) { return str.length()); } else if (str.startsWith(\"--\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (str == null) { return null; }"
    },
    "JacksonDatabind-98": {
        "fixes": [
            {
                "k": 1,
                "patch": "buffer.assignParameter(typeProp, beanClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:15:43.740257586 +0200\n+++ /tmp/tmplklv1tlr.java\t2022-07-12 14:15:43.768257390 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanClass);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "buffer.assignParameter(typeId, id);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:15:46.276239894 +0200\n+++ /tmp/tmpv0012idw.java\t2022-07-12 14:15:46.276239894 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeId, id);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "buffer.assignParameter(typeId, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:15:48.052227503 +0200\n+++ /tmp/tmp7amy9n6n.java\t2022-07-12 14:15:48.052227503 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeId, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "buffer.assignParameter(typeProp, beanProp);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:15:49.876214779 +0200\n+++ /tmp/tmpmx90bq8p.java\t2022-07-12 14:15:49.880214750 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanProp);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "buffer.assignParameter(typeProp, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:15:51.600202748 +0200\n+++ /tmp/tmpnme9jjky.java\t2022-07-12 14:15:51.604202723 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "buffer.assignParameter(typeProp, bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:16:52.179780052 +0200\n+++ /tmp/tmposadl_wu.java\t2022-07-12 14:16:52.183780024 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, bean;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "buffer.assignParameter(typeProp, bean);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:16:53.755769054 +0200\n+++ /tmp/tmpzlszumvj.java\t2022-07-12 14:16:53.755769054 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, bean);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "buffer.assignParameter(typeProp, typeId;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:16:55.479757024 +0200\n+++ /tmp/tmp1nwxd61y.java\t2022-07-12 14:16:55.479757024 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, typeId;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "buffer.assignParameter(typeProp, beanProp;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:16:57.091745774 +0200\n+++ /tmp/tmp0e20w7cu.java\t2022-07-12 14:16:57.091745774 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeProp, beanProp;\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "buffer.assignParameter(typeIdReader, typeId);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-98/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java\t2022-07-12 14:16:58.803733828 +0200\n+++ /tmp/tmpze_t2qjn.java\t2022-07-12 14:16:58.803733828 +0200\n@@ -293,11 +293,11 @@\n                 SettableBeanProperty typeProp = extProp.getTypeProperty();\n                 // for now, should only be needed for creator properties, too\n                 if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n                     // 31-May-2018, tatu: [databind#1328] if id is NOT plain `String`, need to\n                     //    apply deserializer... fun fun.\n-                    buffer.assignParameter(typeProp, typeId);\n+buffer.assignParameter(typeIdReader, typeId);\n                 }\n             }\n         }\n         Object bean = creator.build(ctxt, buffer);\n         // third: assign non-creator properties\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "buffer.assignParameter(typeProp, typeId);",
        "fixed_line": "final Object v; if (typeProp.getType().hasRawClass(String.class)) { v = typeId; } else { TokenBuffer tb = new TokenBuffer(p, ctxt); tb.writeString(typeId); v = typeProp.getValueDeserializer().deserialize(tb.asParserOnFirstToken(), ctxt); tb.close(); } buffer.assignParameter(typeProp, v);"
    },
    "Cli-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:00.847719563 +0200\n+++ /tmp/tmp8zgg2lrd.java\t2022-07-12 14:17:00.911719117 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1);\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:02.775706110 +0200\n+++ /tmp/tmp59kn8l7l.java\t2022-07-12 14:17:02.775706110 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:04.367694997 +0200\n+++ /tmp/tmpyzp0qgba.java\t2022-07-12 14:17:04.367694997 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return options.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:05.915684196 +0200\n+++ /tmp/tmpbhjrouen.java\t2022-07-12 14:17:05.935684057 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() > 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:07.667671971 +0200\n+++ /tmp/tmpgkif9_dw.java\t2022-07-12 14:17:07.667671971 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1);\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:09.303660552 +0200\n+++ /tmp/tmpybgv371b.java\t2022-07-12 14:17:09.303660552 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:10.827649918 +0200\n+++ /tmp/tmpfypiy2qp.java\t2022-07-12 14:17:10.827649918 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption;token.substring(1, tokenBegin));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:12.415638837 +0200\n+++ /tmp/tmpvwkieqam.java\t2022-07-12 14:17:12.419638808 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenLen));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:14.127626888 +0200\n+++ /tmp/tmpw3aouigp.java\t2022-07-12 14:17:14.127626888 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption;token.substring(1, tokenLen));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-37/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 14:17:15.679616057 +0200\n+++ /tmp/tmp3irs1766.java\t2022-07-12 14:17:15.683616029 +0200\n@@ -297,11 +297,11 @@\n      * @param token\n      */\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n+return options.startsWith(\"-\") || token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n         // remove leading \"-\" and \"=value\"\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));",
        "fixed_line": "if (!token.startsWith(\"-\") || token.length() == 1) { return false; } // remove leading \"-\" and \"=value\" int pos = token.indexOf(\"=\"); String optName = pos == -1 ? token.substring(1) : token.substring(1, pos); return options.hasShortOption(optName);"
    },
    "Math-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final double DEFAULT_EPSILON = 10e609;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:17.483603466 +0200\n+++ /tmp/tmpfzqx8o77.java\t2022-07-12 14:17:17.503603328 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e609;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final double DEFAULT_EPSILON = 10eRET;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:21.331576614 +0200\n+++ /tmp/tmpq5g3k3zl.java\t2022-07-12 14:17:21.335576586 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10eRET;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final double DEFAULT_EPSILON = 10e-9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:24.483554616 +0200\n+++ /tmp/tmpevi5hfks.java\t2022-07-12 14:17:24.483554616 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e-9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final double DEFAULT_EPSILON = 10e;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:34.367485636 +0200\n+++ /tmp/tmp660wfb_9.java\t2022-07-12 14:17:34.367485636 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final double DEFAULT_EPSILON = 10e\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:37.459464055 +0200\n+++ /tmp/tmpgb5shx8v.java\t2022-07-12 14:17:37.459464055 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e\";\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final double DEFAULT_EPSILON = 10e Replace;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:40.527442644 +0200\n+++ /tmp/tmp4scdd17u.java\t2022-07-12 14:17:40.527442644 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10e Replace;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final double DEFAULT_EPSILON = 1024;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:43.627421007 +0200\n+++ /tmp/tmp9n7_6w3_.java\t2022-07-12 14:17:43.631420978 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 1024;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final double DEFAULT_EPSILON = 10eNames;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:52.183361292 +0200\n+++ /tmp/tmpornf3xl5.java\t2022-07-12 14:17:52.183361292 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 10eNames;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final double DEFAULT_EPSILON = 8;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:17:55.279339685 +0200\n+++ /tmp/tmpm6_meh5o.java\t2022-07-12 14:17:55.279339685 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 8;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final double DEFAULT_EPSILON = 9;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-104/src/java/org/apache/commons/math/special/Gamma.java\t2022-07-12 14:18:03.823280050 +0200\n+++ /tmp/tmpv8r3iva2.java\t2022-07-12 14:18:03.823280050 +0200\n@@ -32,11 +32,11 @@\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;\n \n     /** Maximum allowed numerical error. */\n-    private static final double DEFAULT_EPSILON = 10e-9;\n+private static final double DEFAULT_EPSILON = 9;\n \n     /** Lanczos coefficients */\n     private static double[] lanczos =\n     {\n         0.99999999999999709182,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final double DEFAULT_EPSILON = 10e-9;",
        "fixed_line": "private static final double DEFAULT_EPSILON = 10e-15;"
    },
    "Closure-77": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = i; i < charCount; i++) {",
                "patch_diff": "for (int i = i; i < charCount; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < charCount; i++) {",
                "patch_diff": "for (int i = 0; i < charCount; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = i; i < charCount; ++i) {",
                "patch_diff": "for (int i = i; i < charCount; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(\"\\\\t': sb.append(i); break; case '\\\\': sb.append",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(\"\\\\t': sb.append(i); break; case '\\\\': sb.append",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(\"\\\\t': sb.append",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(\"\\\\t': sb.append",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(s.charAt(i",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(s.charAt(i",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(s.charAt(i++) {",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(s.charAt(i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "break; case '\\n': sb = s.charAt(i;",
                "patch_diff": "break; case '\\n': sb = s.charAt(i;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(\"\\\\t': sb.append(s.charAt(i++) {",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(\"\\\\t': sb.append(s.charAt(i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(\"\\\\n': sb.append",
                "patch_diff": "break; case '\\n': sb = s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(c); break; case '\\\\': sb.append(\"\\\\t': sb.append(c); break; case '\\\\': sb.append(\"\\\\n\"); break; case '\\\\': sb.append(s.charAt(i); break; case '\\\\': sb.append(i); break; case '\\\\': sb.append(\"\\\\n': sb.append",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '\\0': sb.append(\"\\\\0\"); break;"
    },
    "Time-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof Separator) {",
                "patch_diff": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new PeriodFormatter(elementPairs.get(0) instanceof Separator;",
                "patch_diff": "return new PeriodFormatter(elementPairs.get(0) instanceof Separator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new PeriodFormatter(elementPairs.get(0) instanceof Separator) {",
                "patch_diff": "return new PeriodFormatter(elementPairs.get(0) instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (elementPairs.length >= 2 && elementPairs.get(0) instanceof Separator) {",
                "patch_diff": "if (elementPairs.length >= 2 && elementPairs.get(0) instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (elementPairs.length == 2 && elementPairs.get(0);",
                "patch_diff": "if (elementPairs.length == 2 && elementPairs.get(0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (element instanceof Separator) {",
                "patch_diff": "if (element instanceof Separator) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof Separator;",
                "patch_diff": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof Separator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof WildcardFormatter) {",
                "patch_diff": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof WildcardFormatter) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new PeriodFormatterFormatter(elementPairs.get(0) instanceof Separator;",
                "patch_diff": "return new PeriodFormatterFormatter(elementPairs.get(0) instanceof Separator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof DateTimeParser) {",
                "patch_diff": "if (elementPairs.length == 2 && elementPairs.get(0) instanceof DateTimeParser) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (sep.iAfterParser == null && sep.iAfterPrinter == null) { PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser); sep = sep.finish(f.getPrinter(), f.getParser()); return new PeriodFormatter(sep, sep); }"
    },
    "Closure-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (objType!= null &&constraint.isRecordType = objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:16.543191265 +0200\n+++ /tmp/tmpl6da2sic.java\t2022-07-12 14:18:16.571191071 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (objType!= null &&constraint.isRecordType = objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (typeToInfer!= null && objType instanceof ObjectType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:21.307158015 +0200\n+++ /tmp/tmpqh8wl7na.java\t2022-07-12 14:18:21.307158015 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType instanceof ObjectType) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (typeToInfer!= null && objType instanceofUndefined) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:25.107131491 +0200\n+++ /tmp/tmp9t9t89u8.java\t2022-07-12 14:18:25.107131491 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType instanceofUndefined) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (objType!= null &&constraint.isRecordType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:28.387108595 +0200\n+++ /tmp/tmpk1d52l79.java\t2022-07-12 14:18:28.391108567 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (objType!= null &&constraint.isRecordType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (typeToInfer!= null && objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:31.883084191 +0200\n+++ /tmp/tmp77724xqb.java\t2022-07-12 14:18:31.883084191 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if ( constraintType!= null && objType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:35.207060991 +0200\n+++ /tmp/tmprv8qovza.java\t2022-07-12 14:18:35.211060963 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if ( constraintType!= null && objType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if ( constraintType!= null && objType = objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:38.579037453 +0200\n+++ /tmp/tmppnzdezhk.java\t2022-07-12 14:18:38.579037453 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if ( constraintType!= null && objType = objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (typeToInfer == null || typeToInfer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:42.003013552 +0200\n+++ /tmp/tmpp7abjf0_.java\t2022-07-12 14:18:42.003013552 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer == null || typeToInfer) {\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (typeToInfer)!= null && objType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:45.830986829 +0200\n+++ /tmp/tmpemk_uver.java\t2022-07-12 14:18:45.830986829 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer)!= null && objType;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (typeToInfer!= null && objType = objType.castByNotNullOrUndefined;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-35/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 14:18:49.174963489 +0200\n+++ /tmp/tmplyecarj7.java\t2022-07-12 14:18:49.174963489 +0200\n@@ -1116,25 +1116,11 @@\n       return;\n     }\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+if (typeToInfer!= null && objType = objType.castByNotNullOrUndefined;\n     }\n   }\n \n   /**\n    * If we access a property of a symbol, then that symbol is not\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } }",
        "fixed_line": "if (constraintObj != null) { type.matchConstraint(constraintObj);"
    },
    "JacksonDatabind-99": {
        "fixes": [
            {
                "k": 1,
                "patch": "return sb.append(_referencedType.getName()); return sb.append(_referencedType.toString();",
                "patch_diff": "return sb.append(_referencedType.getName()); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// sb.append(_referencedType.getName()); return sb.append(_referencedType.toString();",
                "patch_diff": "// sb.append(_referencedType.getName()); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return sb.append(_referencedType.getName()); return sb.toString();",
                "patch_diff": "return sb.append(_referencedType.getName()); return sb.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return sb.append(_referencedType.getName()); return sb.append(_referencedType.toString());",
                "patch_diff": "return sb.append(_referencedType.getName()); return sb.append(_referencedType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuilder sb = new StringBuilder(referencedType.getName()); return sb.append(_referencedType.toString();",
                "patch_diff": "StringBuilder sb = new StringBuilder(referencedType.getName()); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return sb.append(_referencedType.getName()); return sb.toCanonical());",
                "patch_diff": "return sb.append(_referencedType.getName()); return sb.toCanonical());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// sb.append(_referencedType.getName()); return sb.append(_referencedType.toString());",
                "patch_diff": "// sb.append(_referencedType.getName()); return sb.append(_referencedType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return sb.append(_referencedType.getName()); return sb.toCanonical()); return sb.append(_referencedType.toString();",
                "patch_diff": "return sb.append(_referencedType.getName()); return sb.toCanonical()); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// sb.append(_referencedType.getName()); return sb.toString();",
                "patch_diff": "// sb.append(_referencedType.getName()); return sb.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// sb.append(_referencedType.getName()); return sb.toCanonical()); return sb.append(_referencedType.toString();",
                "patch_diff": "// sb.append(_referencedType.getName()); return sb.toCanonical()); return sb.append(_referencedType.toString();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "sb.append('>');"
    },
    "Math-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "return solve(min, max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:18:54.442926716 +0200\n+++ /tmp/tmp4vcuvvvk.java\t2022-07-12 14:18:54.474926491 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return solve(min, max, f);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:02.842868077 +0200\n+++ /tmp/tmp5_7a9t3z.java\t2022-07-12 14:19:02.842868077 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max, f);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return solve(min, max;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:04.954853333 +0200\n+++ /tmp/tmpevp65lc6.java\t2022-07-12 14:19:04.954853333 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return solve;min = max;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:06.882839875 +0200\n+++ /tmp/tmpw10b2b6h.java\t2022-07-12 14:19:06.882839875 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min = max;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return solve;min > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:08.946825466 +0200\n+++ /tmp/tmprzyzsrs6.java\t2022-07-12 14:19:08.946825466 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min > 0;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return solve(min, max = f;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:10.882811949 +0200\n+++ /tmp/tmpqpcnz9x7.java\t2022-07-12 14:19:10.886811924 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max = f;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return solve;minmin, max);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:12.794798603 +0200\n+++ /tmp/tmponr26xnk.java\t2022-07-12 14:19:12.798798573 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;minmin, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return solve(min, initial);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:14.774784782 +0200\n+++ /tmp/tmpkejr2aco.java\t2022-07-12 14:19:14.774784782 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, initial);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return solve;min);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:21.830735523 +0200\n+++ /tmp/tmpr2huiwpl.java\t2022-07-12 14:19:21.830735523 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve;min);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return solve(min, max, f;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-70/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\t2022-07-12 14:19:23.770721980 +0200\n+++ /tmp/tmpek74fm71.java\t2022-07-12 14:19:23.770721980 +0200\n@@ -67,11 +67,11 @@\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+return solve(min, max, f;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return solve(min, max);",
        "fixed_line": "return solve(f, min, max);"
    },
    "Cli-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (stopAtNonOption) {",
                "patch_diff": "if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (stopAtNonOption) {",
                "patch_diff": "} else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "else if (stopAtNonOption) { process(token.substring(i)); break; } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) { process(token.substring(i)); break; } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "patch_diff": "} else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) { break; } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "else if (stopAtNonOption) { process(token.substring(i)); break; } else if (stopAtNonOption) {",
                "patch_diff": "else if (stopAtNonOption) { process(token.substring(i)); break; } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) {",
                "patch_diff": "} else if (stopAtNonOption) { process(token.substring(i)); } else if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (stopAtNonOption) {",
                "patch_diff": "// if (stopAtNonOption) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "break;"
    },
    "Closure-111": {
        "fixes": [
            {
                "k": 1,
                "patch": "return thisType topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:27.734694306 +0200\n+++ /tmp/tmp_8q9q3b_.java\t2022-07-12 14:19:27.762694110 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return topType.NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:33.854651579 +0200\n+++ /tmp/tmpsritbhx_.java\t2022-07-12 14:19:33.854651579 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType.NONE;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return thisType topType.NONE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:37.658625024 +0200\n+++ /tmp/tmpbc3zticg.java\t2022-07-12 14:19:37.658625024 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType.NONE;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return thisType topType.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:40.978601847 +0200\n+++ /tmp/tmp36t7df9x.java\t2022-07-12 14:19:40.978601847 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType topType.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return thisType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:44.234579115 +0200\n+++ /tmp/tmppsy0ppa8.java\t2022-07-12 14:19:44.250579001 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return thisType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this.topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:47.990552890 +0200\n+++ /tmp/tmpzyv594gm.java\t2022-07-12 14:19:47.990552890 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return topType.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:51.458528681 +0200\n+++ /tmp/tmpa0tyov00.java\t2022-07-12 14:19:51.458528681 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return topType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:19:55.110503184 +0200\n+++ /tmp/tmpzzpp9pv6.java\t2022-07-12 14:19:55.110503184 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return topType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this.rightType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:20:47.878134758 +0200\n+++ /tmp/tmp2ftoe410.java\t2022-07-12 14:20:47.878134758 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.rightType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return this.bottomType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-111/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java\t2022-07-12 14:20:51.446109845 +0200\n+++ /tmp/tmpln5ui3cj.java\t2022-07-12 14:20:51.450109817 +0200\n@@ -49,11 +49,11 @@\n    */\n   private final Visitor<JSType> restrictToArrayVisitor =\n       new RestrictByTrueTypeOfResultVisitor() {\n         @Override\n         protected JSType caseTopType(JSType topType) {\n-          return topType;\n+return this.bottomType;\n         }\n \n         @Override\n         public JSType caseObjectType(ObjectType type) {\n           JSType arrayType = getNativeType(ARRAY_TYPE);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return topType;",
        "fixed_line": "return topType.isAllType() ? getNativeType(ARRAY_TYPE) : topType;"
    },
    "Csv-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:20:55.346082613 +0200\n+++ /tmp/tmpg3cjfyej.java\t2022-07-12 14:20:55.414082138 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:20:57.306068927 +0200\n+++ /tmp/tmpxx5qk2md.java\t2022-07-12 14:20:57.310068897 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:20:59.050056747 +0200\n+++ /tmp/tmpc34xzdsx.java\t2022-07-12 14:20:59.050056747 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:02.174034937 +0200\n+++ /tmp/tmpc0e2ragk.java\t2022-07-12 14:21:02.174034937 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE)\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:03.726024097 +0200\n+++ /tmp/tmp11tx7qn9.java\t2022-07-12 14:21:03.726024097 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap, Integer.MAX_VALUE;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new LinkedHashMap<String, Integer>(this.headerMap);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:05.246013487 +0200\n+++ /tmp/tmprk7ngy0g.java\t2022-07-12 14:21:05.246013487 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:07.993994295 +0200\n+++ /tmp/tmppi0yre24.java\t2022-07-12 14:21:07.993994295 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:09.469983992 +0200\n+++ /tmp/tmpyy4iafv4.java\t2022-07-12 14:21:09.469983992 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap;\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:11.077972763 +0200\n+++ /tmp/tmpe6ta_dj5.java\t2022-07-12 14:21:11.077972763 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(parent.headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new LinkedHashMap<String, Integer>(headerMap, Integer.MAX_VALUE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-4/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 14:21:12.673961618 +0200\n+++ /tmp/tmp44zsghkk.java\t2022-07-12 14:21:12.673961618 +0200\n@@ -283,11 +283,11 @@\n      * The map keys are column names. The map values are 0-based indices.\n      * </p>\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+return new LinkedHashMap<String, Integer>(headerMap, Integer.MAX_VALUE);\n     }\n \n     /**\n      * Returns the current record number in the input stream.\n      * <p/>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new LinkedHashMap<String, Integer>(this.headerMap);",
        "fixed_line": "return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);"
    },
    "Jsoup-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return abs.toExternalForm(base, rel);",
                "patch_diff": "return abs.toExternalForm(base, rel);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return abs.toExternalForm(base, relUrl);",
                "patch_diff": "return abs.toExternalForm(base, relUrl);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return abs = new URL(base, relUrl);",
                "patch_diff": "return abs = new URL(base, relUrl);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return abs.toExternalForm(base, relUrl).util.toExternalForm(base, relUrl);",
                "patch_diff": "return abs.toExternalForm(base, relUrl).util.toExternalForm(base, relUrl);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return abs.toExternalForm(base, rel = new PADA.toExternalForm(base, relUrl);",
                "patch_diff": "return abs.toExternalForm(base, rel = new PADA.toExternalForm(base, relUrl);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return abs.toExternalForm(base, rel = new Double(base, relUrl);",
                "patch_diff": "return abs.toExternalForm(base, rel = new Double(base, relUrl);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return abs.toExternalForm(base, relUrl) {",
                "patch_diff": "return abs.toExternalForm(base, relUrl) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return abs.toExternalForm(base, rel.toExternalForm) {",
                "patch_diff": "return abs.toExternalForm(base, rel.toExternalForm) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return abs.toExternalForm(base, rel.class) {",
                "patch_diff": "return abs.toExternalForm(base, rel.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return abs.toExternalForm(base, rel.toExternalForm);",
                "patch_diff": "return abs.toExternalForm(base, rel.toExternalForm);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (relUrl.startsWith(\"?\")) relUrl = base.getPath() + relUrl;"
    },
    "JacksonDatabind-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class = _hasAnnotation;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:21:16.293936341 +0200\n+++ /tmp/tmp2l1g5n1_.java\t2022-07-12 14:21:16.317936176 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class = _hasAnnotation;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class == JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:21:18.737919275 +0200\n+++ /tmp/tmp271ccoag.java\t2022-07-12 14:21:18.737919275 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class == JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class!= JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:21:20.421907517 +0200\n+++ /tmp/tmpavr090qj.java\t2022-07-12 14:21:20.425907488 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class!= JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:21:21.989896568 +0200\n+++ /tmp/tmpsc4vf1yq.java\t2022-07-12 14:21:21.989896568 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class = _hasArg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:00.473627830 +0200\n+++ /tmp/tmp7u9ygt9q.java\t2022-07-12 14:22:00.473627830 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class = _hasArg;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "|| _hasAnnotation(a, JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:02.017617048 +0200\n+++ /tmp/tmpq_oa7zdi.java\t2022-07-12 14:22:02.021617020 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation(a, JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class = _hasAnnotation;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:03.625605819 +0200\n+++ /tmp/tmpi5u3zrlh.java\t2022-07-12 14:22:03.625605819 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class = _hasAnnotation;\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:05.221594673 +0200\n+++ /tmp/tmp_u5f1jg1.java\t2022-07-12 14:22:05.221594673 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class)) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class == JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:06.781583779 +0200\n+++ /tmp/tmp7it9ojid.java\t2022-07-12 14:22:06.781583779 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class == JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| _hasAnnotation;a, JsonRawValue.class!= JsonRawValue.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-33/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java\t2022-07-12 14:22:08.393572522 +0200\n+++ /tmp/tmp0heubxmx.java\t2022-07-12 14:22:08.393572522 +0200\n@@ -743,11 +743,11 @@\n                  *   it's actually bit tricky to do it more efficiently (meta-annotations\n                  *   add more lookups; AnnotationMap costs etc)\n                  */\n             } else if (_hasAnnotation(a, JsonSerialize.class)\n                     || _hasAnnotation(a, JsonView.class)\n-                    || _hasAnnotation(a, JsonRawValue.class)) {\n+|| _hasAnnotation;a, JsonRawValue.class!= JsonRawValue.class) {\n                 name = \"\";\n             } else {\n                 return null;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "|| _hasAnnotation(a, JsonRawValue.class)) {",
        "fixed_line": "|| _hasAnnotation(a, JsonRawValue.class) || _hasAnnotation(a, JsonUnwrapped.class) || _hasAnnotation(a, JsonBackReference.class) || _hasAnnotation(a, JsonManagedReference.class)) {"
    },
    "Closure-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (mockedType == null) {",
                "patch_diff": "if (mockedType == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType.getImplicitPrototype();",
                "patch_diff": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType.getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType;",
                "patch_diff": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (name.isEquivalentTo(paramType, but shouldn't crash = interfaceType.getImplicitPrototype();",
                "patch_diff": "if (name.isEquivalentTo(paramType, but shouldn't crash = interfaceType.getImplicitPrototype();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (mockedType instanceof ObjectType) {",
                "patch_diff": "if (mockedType instanceof ObjectType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (mockedType!= null) {",
                "patch_diff": "if (mockedType!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType.getImplicitPrototype;",
                "patch_diff": "if (name.isEquivalentTo(functionType, but shouldn't crash = interfaceType.getImplicitPrototype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == null) {",
                "patch_diff": "if (type == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (name.isEquivalentTo(paramType, but shouldn't crash = interfaceType;",
                "patch_diff": "if (name.isEquivalentTo(paramType, but shouldn't crash = interfaceType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (implicitProto == null) { // This can be the case if interfaceType is proxy to a non-existent // object (which is a bad type annotation, but shouldn't crash). currentPropertyNames = ImmutableSet.of(); } else { currentPropertyNames = implicitProto.getOwnPropertyNames(); }"
    },
    "JacksonDatabind-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:12.065546879 +0200\n+++ /tmp/tmph0gmi9os.java\t2022-07-12 14:22:12.137546377 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer, propName);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:13.925533889 +0200\n+++ /tmp/tmpyn2969gc.java\t2022-07-12 14:22:13.925533889 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:15.485522994 +0200\n+++ /tmp/tmp1wx16czm.java\t2022-07-12 14:22:15.485522994 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:17.305510286 +0200\n+++ /tmp/tmpxmpi9d5e.java\t2022-07-12 14:22:17.305510286 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:19.113497659 +0200\n+++ /tmp/tmpoyqq1ay_.java\t2022-07-12 14:22:19.113497659 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:20.681486710 +0200\n+++ /tmp/tmp2wfmi5mz.java\t2022-07-12 14:22:20.681486710 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer, propName);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, buffer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:22.225475926 +0200\n+++ /tmp/tmp5214zwzb.java\t2022-07-12 14:22:22.225475926 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, buffer) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ext.handlePropertyValue(jp, ctxt, propName, bean);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:23.781465060 +0200\n+++ /tmp/tmph1ov5l0c.java\t2022-07-12 14:22:23.785465032 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (ext.handlePropertyValue(jp, ctxt, propName, bean);\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (externsPropertyValue(jp, ctxt, propName, buffer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:25.305454417 +0200\n+++ /tmp/tmpah1ap7_2.java\t2022-07-12 14:22:25.305454417 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsPropertyValue(jp, ctxt, propName, buffer) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-27/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 14:22:26.821443829 +0200\n+++ /tmp/tmpj0hyhroa.java\t2022-07-12 14:22:26.821443829 +0200\n@@ -789,11 +789,11 @@\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+if (externsRoot.handlePropertyValue(jp, ctxt, propName, buffer)) {\n                     ;\n                 } else {\n                     // Last creator property to set?\n                     if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) {\n                         t = p.nextToken(); // to move to following FIELD_NAME/END_OBJECT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
        "fixed_line": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {"
    },
    "JacksonDatabind-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (format == JsonFormat.Shape.OBJECT || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:28.701430701 +0200\n+++ /tmp/tmprlk6j0zg.java\t2022-07-12 14:22:28.733430477 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.OBJECT || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (m == JsonFormat.Shape.OBJECT || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:30.777416202 +0200\n+++ /tmp/tmp7nbs4tra.java\t2022-07-12 14:22:30.781416173 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.OBJECT || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (m == JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:32.293405616 +0200\n+++ /tmp/tmp2_2semha.java\t2022-07-12 14:22:32.293405616 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (m!= JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:33.861394665 +0200\n+++ /tmp/tmpozc3ojo2.java\t2022-07-12 14:22:33.861394665 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m!= JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (format == JsonFormat.Shape.OBJECT || format.hasPattern) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:35.361384189 +0200\n+++ /tmp/tmpb6pmuzob.java\t2022-07-12 14:22:35.361384189 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.OBJECT || format.hasPattern) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (format == JsonFormat.Shape.STRING) && format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:36.905373405 +0200\n+++ /tmp/tmp7x3us54c.java\t2022-07-12 14:22:36.905373405 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) && format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format == JsonFormat.Shape.STRING) || format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:38.433362735 +0200\n+++ /tmp/tmp_uyum5nf.java\t2022-07-12 14:22:38.433362735 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) || format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (m == JsonFormat.Shape.STRING) && format.hasPattern;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:40.005351757 +0200\n+++ /tmp/tmpq26m9xpa.java\t2022-07-12 14:22:40.005351757 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.STRING) && format.hasPattern;\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (m == JsonFormat.Shape.OBJECT || format.hasPattern) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:41.581340749 +0200\n+++ /tmp/tmp29aq45bq.java\t2022-07-12 14:22:41.585340723 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (m == JsonFormat.Shape.OBJECT || format.hasPattern) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (format == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-85/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 14:22:43.089330218 +0200\n+++ /tmp/tmphcrl3zgd.java\t2022-07-12 14:22:43.089330218 +0200\n@@ -62,38 +62,11 @@\n             return withFormat(Boolean.TRUE, null);\n         }\n \n         // 08-Jun-2017, tatu: With [databind#1648], this gets bit tricky..\n         // First: custom pattern will override things\n-                if ((shape == JsonFormat.Shape.STRING) || format.hasPattern()\n-                                || format.hasLocale() || format.hasTimeZone()) {\n-                    TimeZone tz = format.getTimeZone();\n-                    final String pattern = format.hasPattern()\n-                                    ? format.getPattern()\n-                                    : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n-            final Locale loc = format.hasLocale()\n-                            ? format.getLocale()\n-                            : serializers.getLocale();\n-                    SimpleDateFormat df = new SimpleDateFormat(pattern, loc);\n-                    if (tz == null) {\n-                        tz = serializers.getTimeZone();\n-                    }\n-            df.setTimeZone(tz);\n-            return withFormat(Boolean.FALSE, df);\n-        }\n-\n-        // Otherwise, need one of these changes:\n-\n-\n-        // Jackson's own `StdDateFormat` is quite easy to deal with...\n-\n-        // 08-Jun-2017, tatu: Unfortunately there's no generally usable\n-        //    mechanism for changing `DateFormat` instances (or even clone()ing)\n-        //    So: require it be `SimpleDateFormat`; can't config other types\n-//            serializers.reportBadDefinition(handledType(), String.format(\n-            // Ugh. No way to change `Locale`, create copy; must re-crete completely:\n-        return this;\n+if (format == JsonFormat.Shape.STRING) {\n     }\n \n     /*\n     /**********************************************************\n     /* Accessors\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: // Jackson's own `StdDateFormat` is quite easy to deal with... // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types // serializers.reportBadDefinition(handledType(), String.format( // Ugh. No way to change `Locale`, create copy; must re-crete completely: return this;",
        "fixed_line": "if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } // Otherwise, need one of these changes: final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); // Jackson's own `StdDateFormat` is quite easy to deal with... if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } // 08-Jun-2017, tatu: Unfortunately there's no generally usable // mechanism for changing `DateFormat` instances (or even clone()ing) // So: require it be `SimpleDateFormat`; can't config other types if (!(df0 instanceof SimpleDateFormat)) { // serializers.reportBadDefinition(handledType(), String.format( serializers.reportMappingProblem( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; can not configure `Locale` or `TimeZone`\", df0.getClass().getName()); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { // Ugh. No way to change `Locale`, create copy; must re-crete completely: df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);"
    },
    "JxPath-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "return aNode = node.getValueParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:44.853317900 +0200\n+++ /tmp/tmp214p8ds0.java\t2022-07-12 14:22:44.961317145 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return aNode = aNode.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:47.177301669 +0200\n+++ /tmp/tmp6rcc5nby.java\t2022-07-12 14:22:47.177301669 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return aNode = node.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:48.781290466 +0200\n+++ /tmp/tmpea1qcuui.java\t2022-07-12 14:22:48.785290438 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return aNode = aNode.getValueParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:50.325279683 +0200\n+++ /tmp/tmpglasrngn.java\t2022-07-12 14:22:50.325279683 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getValueParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return aNode = node.getParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:51.937268426 +0200\n+++ /tmp/tmp_4rnvnns.java\t2022-07-12 14:22:51.937268426 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return aNode = aNode.getParentNode; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:53.469257726 +0200\n+++ /tmp/tmpeqmfkz28.java\t2022-07-12 14:22:53.469257726 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getParentNode; }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return aNode = node.getValueParentNode.getParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:55.117246216 +0200\n+++ /tmp/tmp37wa_bzn.java\t2022-07-12 14:22:55.117246216 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode.getParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return aNode = node.getValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:56.637235601 +0200\n+++ /tmp/tmp6abp2d6v.java\t2022-07-12 14:22:56.665235405 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValue(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return aNode = node.getValueParentNode(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:58.189224761 +0200\n+++ /tmp/tmpgap7mmv0.java\t2022-07-12 14:22:58.189224761 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = node.getValueParentNode(); }\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return aNode = aNode.getParentNode();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-22/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 14:22:59.761213783 +0200\n+++ /tmp/tmp8axcagw_.java\t2022-07-12 14:22:59.761213783 +0200\n@@ -684,18 +684,11 @@\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n                     if (attr != null) {\n-                        return attr.getValue();\n-                    }\n-                }\n-                aNode = aNode.getParentNode();\n-            }\n-            return null;\n-        }\n-        return uri;\n+return aNode = aNode.getParentNode();\n     }\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return attr.getValue(); } } aNode = aNode.getParentNode(); } return null; } return uri;",
        "fixed_line": "uri = attr.getValue(); break; } } aNode = aNode.getParentNode(); } } return \"\".equals(uri) ? null : uri;"
    },
    "JacksonDatabind-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (t == JsonToken.FIELD_NAME) {",
                "patch_diff": "// if (t == JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// if (tatu:: declaredType.isAssignableFromCanonical(tatu:",
                "patch_diff": "// if (tatu:: declaredType.isAssignableFromCanonical(tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (tatu:: declaredType.isAssignableFrom(tatu:",
                "patch_diff": "// if (tatu:: declaredType.isAssignableFrom(tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a method",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a method",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JavaType t = tf.constructFromCanonical(tatu: As.",
                "patch_diff": "JavaType t = tf.constructFromCanonical(tatu: As.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for EnumMap",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for EnumMap",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (tatu:: declaredType.isAssignableFromCanonical(tatu: As.",
                "patch_diff": "// if (tatu:: declaredType.isAssignableFromCanonical(tatu: As.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!t.isTypeOrSubTypeOf(_baseType.getRawClass())) { // Probably cleaner to have a method in `TypeFactory` but can't add in patch throw new IllegalArgumentException(String.format( \"Class %s not subtype of %s\", t.getRawClass().getName(), _baseType)); }"
    },
    "Lang-54": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z') {",
                "patch_diff": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (ch3 == 'A' || ch3 < 'Z' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 == 'A' || ch3 < 'Z' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ch3 == 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 == 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ch3 == 'A' || ch3 == 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 == 'A' || ch3 == 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ch3 == 'A' || ch3 < 'Z' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "patch_diff": "if (ch3 == 'A' || ch3 < 'Z' || ch4 > 'Z' || ch4 < 'A' || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (ch3 == 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + ch4); }",
                "patch_diff": "if (ch3 == 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') { throw new IllegalArgumentException(\"Invalid locale format: \" + ch4); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z') || ch4 > 'Z') {",
                "patch_diff": "if (ch3 < 0 || ch3 > 'A' || ch4 < 'Z') || ch4 > 'Z') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ch3 == '_') { return new Locale(str.substring(0, 2), \"\", str.substring(4)); }"
    },
    "Math-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:23:05.029176993 +0200\n+++ /tmp/tmpf3qag18g.java\t2022-07-12 14:23:05.057176795 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:23:54.568830990 +0200\n+++ /tmp/tmp2tfbv6gx.java\t2022-07-12 14:23:54.568830990 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (double) ('Successes()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:23:57.896807745 +0200\n+++ /tmp/tmpy938ky_6.java\t2022-07-12 14:23:57.896807745 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) ('Successes()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (double) // no getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:00.884786874 +0200\n+++ /tmp/tmpg6ws8_pr.java\t2022-07-12 14:24:00.884786874 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) // no getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (double) (getSampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:04.048764774 +0200\n+++ /tmp/tmpthr31r27.java\t2022-07-12 14:24:04.048764774 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (double) (getSampleSize * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:06.848745218 +0200\n+++ /tmp/tmpu30i5ob1.java\t2022-07-12 14:24:06.848745218 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) (getSampleSize * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:10.276721274 +0200\n+++ /tmp/tmpycl75kfb.java\t2022-07-12 14:24:10.280721245 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:12.996702277 +0200\n+++ /tmp/tmpf30sb4zi.java\t2022-07-12 14:24:13.008702192 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double)sig.getSampleSize() * getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (double) ('Successes * getNumberOfSuccesses()) / (double) getPopulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:16.104680567 +0200\n+++ /tmp/tmp32ujb95p.java\t2022-07-12 14:24:16.108680539 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) ('Successes * getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (double) // no getNumberOfSuccesses()) / (double) -1opulationSize();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-2/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\t2022-07-12 14:24:18.812661653 +0200\n+++ /tmp/tmpsvo6vxbn.java\t2022-07-12 14:24:18.812661653 +0200\n@@ -263,11 +263,11 @@\n      *\n      * For population size {@code N}, number of successes {@code m}, and sample\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+return (double) // no getNumberOfSuccesses()) / (double) -1opulationSize();\n     }\n \n     /**\n      * {@inheritDoc}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
        "fixed_line": "return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());"
    },
    "Closure-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isExpressionNode(parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:21.724641315 +0200\n+++ /tmp/tmp8yf35u9o.java\t2022-07-12 14:24:22.000639388 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isExpressionNode(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:27.160603344 +0200\n+++ /tmp/tmpo8lw2mkp.java\t2022-07-12 14:24:27.164603316 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isExpressionNode(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:30.632579091 +0200\n+++ /tmp/tmpgk7p35e3.java\t2022-07-12 14:24:30.632579091 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(n;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isExpressionNode(parent, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:33.812556880 +0200\n+++ /tmp/tmp_84gumao.java\t2022-07-12 14:24:33.816556852 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent, n);\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isExpressionNode( return n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:37.592530477 +0200\n+++ /tmp/tmp351y0auh.java\t2022-07-12 14:24:37.592530477 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return n;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isExpressionNode(parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:40.860507650 +0200\n+++ /tmp/tmp3kso3uti.java\t2022-07-12 14:24:40.864507622 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent) {\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:44.164484572 +0200\n+++ /tmp/tmp70euz5zv.java\t2022-07-12 14:24:44.168484544 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode(parent;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isExpressionNode(parent) && n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:47.644460264 +0200\n+++ /tmp/tmp64r5qyi1.java\t2022-07-12 14:24:47.644460264 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent) && n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:51.116436010 +0200\n+++ /tmp/tmp3g2xm58c.java\t2022-07-12 14:24:51.180435569 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode( return NodeUtil.isExpressionNode;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isExpressionNode(parent, n.hasOneChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-87/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:24:54.416412961 +0200\n+++ /tmp/tmpacw32onw.java\t2022-07-12 14:24:54.444412765 +0200\n@@ -528,11 +528,11 @@\n           // into other expressions.\n \n             // We only have to worry about methods with an implicit 'this'\n             // param, or this doesn't happen.\n \n-          return NodeUtil.isExpressionNode(maybeExpr);\n+return NodeUtil.isExpressionNode(parent, n.hasOneChild;\n       }\n     }\n \n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isExpressionNode(maybeExpr);",
        "fixed_line": "if (maybeExpr.getType() == Token.EXPR_RESULT) { // IE has a bug where event handlers behave differently when // their return value is used vs. when their return value is in // an EXPR_RESULT. It's pretty freaking weird. See: // http://code.google.com/p/closure-compiler/issues/detail?id=291 // We try to detect this case, and not fold EXPR_RESULTs // into other expressions. if (maybeExpr.getFirstChild().getType() == Token.CALL) { Node calledFn = maybeExpr.getFirstChild().getFirstChild(); // We only have to worry about methods with an implicit 'this' // param, or this doesn't happen. if (calledFn.getType() == Token.GETELEM) { return false; } else if (calledFn.getType() == Token.GETPROP && calledFn.getLastChild().getString().startsWith(\"on\")) { return false; } } return true; } return false;"
    },
    "Mockito-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject(fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:24:57.348392483 +0200\n+++ /tmp/tmpdu7apb62.java\t2022-07-12 14:24:57.416392006 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject(fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:00.040373676 +0200\n+++ /tmp/tmpbwute3_d.java\t2022-07-12 14:25:00.040373676 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:02.832354174 +0200\n+++ /tmp/tmprtk9w20k.java\t2022-07-12 14:25:02.836354146 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:04.724340958 +0200\n+++ /tmp/tmp9q9npa6d.java\t2022-07-12 14:25:04.728340930 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject());\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject(fieldInstance).\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:06.548328217 +0200\n+++ /tmp/tmpfqppnui_.java\t2022-07-12 14:25:06.548328217 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject(fieldInstance).\");\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectAccessor();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:08.316315867 +0200\n+++ /tmp/tmpeg2tqerx.java\t2022-07-12 14:25:08.316315867 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectAccessor();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:10.712299130 +0200\n+++ /tmp/tmpfz3hrmm9.java\t2022-07-12 14:25:10.712299130 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext);\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockCandidateFilter.filterCandidate( fieldInstance, objInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:12.480286781 +0200\n+++ /tmp/tmp_pad21sf.java\t2022-07-12 14:25:12.480286781 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate( fieldInstance, objInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:14.944269569 +0200\n+++ /tmp/tmpo5emx3f6.java\t2022-07-12 14:25:14.944269569 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInjectContext();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-28/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\t2022-07-12 14:25:17.368252637 +0200\n+++ /tmp/tmpymu0dvy8.java\t2022-07-12 14:25:17.368252637 +0200\n@@ -88,11 +88,11 @@\n         }\n     }\n \n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+mockCandidateFilter.filterCandidate(mocks, objInstance).thenInject();\n         }\n     }\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
        "fixed_line": "Object injected = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); mocks.remove(injected);"
    },
    "Mockito-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new UnsupportedOperationException(addVarargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:25:19.852235291 +0200\n+++ /tmp/tmpc942l5dk.java\t2022-07-12 14:25:19.892235009 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVarargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new UnsupportedOperationException(matcherss;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:25:33.236141793 +0200\n+++ /tmp/tmpsgskp4se.java\t2022-07-12 14:25:33.236141793 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(matcherss;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new UnsupportedOperationException(addVararg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:25:40.976087726 +0200\n+++ /tmp/tmpynjaw2to.java\t2022-07-12 14:25:40.976087726 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVararg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new UnsupportedOperationException(textVararg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:25:48.844032762 +0200\n+++ /tmp/tmpb3a8y8ea.java\t2022-07-12 14:25:48.844032762 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(textVararg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new UnsupportedOperationException(\"Vararg\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:25:56.783977298 +0200\n+++ /tmp/tmpctt2ke0c.java\t2022-07-12 14:25:56.791977243 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(\"Vararg\");\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new UnsupportedOperationException(matcherss) isVararg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:27:24.651363460 +0200\n+++ /tmp/tmpt1jav_bc.java\t2022-07-12 14:27:24.655363432 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(matcherss) isVararg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new UnsupportedOperationException(addVarargargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:27:32.479308773 +0200\n+++ /tmp/tmpvhd5cr33.java\t2022-07-12 14:27:32.479308773 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(addVarargargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new UnsupportedOperationException(text);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:27:40.207254780 +0200\n+++ /tmp/tmpjijx_nqz.java\t2022-07-12 14:27:40.207254780 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(text);\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new UnsupportedOperationException(m_MAX_VALUE)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:27:48.851194392 +0200\n+++ /tmp/tmpfhazp1fw.java\t2022-07-12 14:27:48.851194392 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(m_MAX_VALUE)\");\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new UnsupportedOperationException(textVarargarg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-1/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 14:27:56.583140374 +0200\n+++ /tmp/tmp9miuue87.java\t2022-07-12 14:27:56.583140374 +0200\n@@ -118,11 +118,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+throw new UnsupportedOperationException(textVarargarg;\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {\n                 Matcher m = matchers.get(position);\n                 if (m instanceof CapturesArguments) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new UnsupportedOperationException();",
        "fixed_line": "for (int position = 0; position < indexOfVararg; position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } for (int position = indexOfVararg; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getRawArguments()[position - indexOfVararg]); } }"
    },
    "Lang-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "return out.write(start + (end - start) + (isHex? 1 : 0); }",
                "patch_diff": "return out.write(start + (end - start) + (isHex? 1 : 0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return out.write(start + (end - start) + (isHex? 1 : 0; }",
                "patch_diff": "return out.write(start + (end - start) + (isHex? 1 : 0; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return out.write(start + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return out.write(start + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return index + (end - start) + (isHex? 1 : 0); }",
                "patch_diff": "return index + (end - start) + (isHex? 1 : 0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return true + (end - start) + (isHex? 1 : 0); }",
                "patch_diff": "return true + (end - start) + (isHex? 1 : 0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (start + (end - start) + (isHex? 1 : 0); }",
                "patch_diff": "return (start + (end - start) + (isHex? 1 : 0); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return index + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return index + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return index + (end - start) + (isHex? 1 : 0; }",
                "patch_diff": "return index + (end - start) + (isHex? 1 : 0; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return; }",
                "patch_diff": "return; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (start + (end - start) + (isHex? 1 : 0) + 1; }",
                "patch_diff": "return (start + (end - start) + (isHex? 1 : 0) + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(entityValue > 0xFFFF) { char[] chrs = Character.toChars(entityValue); out.write(chrs[0]); out.write(chrs[1]); } else { out.write(entityValue); }"
    },
    "Mockito-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; }",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments; }",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments;",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (generic!= null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "} else if (generic!= null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "} else if (generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (wanted instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "} else if (wanted instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (generic instanceof ParameterizedType && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "patch_diff": "} else if (generic instanceof ParameterizedType && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (generic!= null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments; }",
                "patch_diff": "if (generic!= null && generic instanceof ParameterizedType) { Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0]; return (ParameterizedType) generic).getActualTypeArguments; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (actual instanceof Class) { return (Class) actual; } else if (actual instanceof ParameterizedType) { //in case of nested generics we don't go deep return (Class) ((ParameterizedType) actual).getRawType(); }"
    },
    "JacksonDatabind-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:08.339058244 +0200\n+++ /tmp/tmpgcn2d1ek.java\t2022-07-12 14:28:08.431057599 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:10.571042646 +0200\n+++ /tmp/tmpcaqjbx5s.java\t2022-07-12 14:28:10.571042646 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:12.227031077 +0200\n+++ /tmp/tmplv7c3w40.java\t2022-07-12 14:28:12.227031077 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _createEnumKeyDeserializer(ctxt, type = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:13.779027165 +0200\n+++ /tmp/tmpk4d2zffq.java\t2022-07-12 14:28:13.779027165 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:15.411029284 +0200\n+++ /tmp/tmp9vpyxqjx.java\t2022-07-12 14:28:15.415029290 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:17.039031363 +0200\n+++ /tmp/tmpmrm81zzj.java\t2022-07-12 14:28:17.039031363 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type,\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:18.703033448 +0200\n+++ /tmp/tmpuv7asw6r.java\t2022-07-12 14:28:18.703033448 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:20.315035426 +0200\n+++ /tmp/tmpocj_vs1z.java\t2022-07-12 14:28:20.319035432 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:21.927037371 +0200\n+++ /tmp/tmphrw_evvm.java\t2022-07-12 14:28:21.931037376 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(ctxt, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, deser);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-67/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 14:28:23.555039296 +0200\n+++ /tmp/tmp9latwe9s.java\t2022-07-12 14:28:23.559039303 +0200\n@@ -1398,13 +1398,11 @@\n             }\n         }\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n-            }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n+return _createEnumKeyDeserializer(enumRes, type, deser = StdKeyDeserializers.findStringBasedKeyDeserializer(type, _factoryConfigConfig);\n         }\n         // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return _createEnumKeyDeserializer(ctxt, type); } deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);",
        "fixed_line": "deser = _createEnumKeyDeserializer(ctxt, type); } else { deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);"
    },
    "JacksonDatabind-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:25.355041383 +0200\n+++ /tmp/tmplerzjfzq.java\t2022-07-12 14:28:25.383041413 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler() == null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:27.323043611 +0200\n+++ /tmp/tmp7xk5787r.java\t2022-07-12 14:28:27.323043611 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler() == null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler)!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:28.891045347 +0200\n+++ /tmp/tmphdfcpjry.java\t2022-07-12 14:28:28.895045350 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler)!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (ct.getValueHandler!= null) || (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:30.759047369 +0200\n+++ /tmp/tmpugg_rodo.java\t2022-07-12 14:28:30.759047369 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null) || (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:32.467049175 +0200\n+++ /tmp/tmpt5367m72.java\t2022-07-12 14:28:32.471049182 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (ct.getValueHandler!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:34.203050974 +0200\n+++ /tmp/tmp6w26wf39.java\t2022-07-12 14:28:34.203050974 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:28:35.887052675 +0200\n+++ /tmp/tmprmdk1q74.java\t2022-07-12 14:28:35.891052678 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler()!= null) || (ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (ct.getValueHandler!= null && (ct.getTypeHandler!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:29:21.195084162 +0200\n+++ /tmp/tmpw4to4_3s.java\t2022-07-12 14:29:21.195084162 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null && (ct.getTypeHandler!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (ct.getValueHandler!= null &&ct.getTypeHandler()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:29:22.731084761 +0200\n+++ /tmp/tmp7if3zj0z.java\t2022-07-12 14:29:22.731084761 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null &&ct.getTypeHandler()!= null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (ct.getValueHandler!= null &&ct.getTypeHandler() == null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-91/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\t2022-07-12 14:29:24.487085410 +0200\n+++ /tmp/tmppe4ade_5.java\t2022-07-12 14:29:24.491085411 +0200\n@@ -536,11 +536,11 @@\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+return (ct.getValueHandler!= null &&ct.getTypeHandler() == null);\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n             }\n         }\n         return false;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);",
        "fixed_line": "if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) { return true; } } // Second: map(-like) types may have value handler for key (but not type; keys are untyped) if (t.isMapLikeType()) { JavaType kt = t.getKeyType(); if (kt.getValueHandler() != null) { return true; }"
    },
    "JacksonCore-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ctxt == null) {",
                "patch_diff": "if (ctxt == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (ctxt == null) {",
                "patch_diff": "// if (ctxt == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (AtStart!= null) {",
                "patch_diff": "if (AtStart!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (type == TYPE_ALLALL) {",
                "patch_diff": "if (type == TYPE_ALLALL) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (type == TYPE_ALLALL_NAME) {",
                "patch_diff": "if (type == TYPE_ALLALL_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (AtPos!= null) {",
                "patch_diff": "if (AtPos!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (curr == null) {",
                "patch_diff": "// if (curr == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nameBytes == null) {",
                "patch_diff": "if (nameBytes == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// if (ctxt.isAssignableContext ctxt) {",
                "patch_diff": "// if (ctxt.isAssignableContext ctxt) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(!_allowMultipleMatches && _currToken != null && _exposedContext == null){ //if not scalar and ended successfully, then return null if((_currToken.isStructEnd() && _headContext.isStartHandled()) ){ return (_currToken = null); } //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null else if(_currToken.isScalarValue() && !_headContext.isStartHandled() && !_includePath && _itemFilter == TokenFilter.INCLUDE_ALL) { return (_currToken = null); } }"
    },
    "Closure-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return allResultsMatch(lhs, n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:28.099086623 +0200\n+++ /tmp/tmpeeqolhqg.java\t2022-07-12 14:29:28.131086632 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 0, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:33.075088028 +0200\n+++ /tmp/tmpjtvff693.java\t2022-07-12 14:29:33.079088031 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return 0, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return allResultsMatch(lhs, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:36.539088827 +0200\n+++ /tmp/tmpqdigv5i8.java\t2022-07-12 14:29:36.539088827 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return allResultsMatch( n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:40.371089536 +0200\n+++ /tmp/tmpj7dza2nm.java\t2022-07-12 14:29:40.371089536 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch( n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return allResultsMatch(file, n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:43.935090038 +0200\n+++ /tmp/tmpp6s_kb48.java\t2022-07-12 14:29:43.935090038 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(file, n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return allResultsMatch( can, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:47.479090382 +0200\n+++ /tmp/tmpjcdhg_co.java\t2022-07-12 14:29:47.479090382 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch( can, n);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return quadrantMatch(n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:51.247090584 +0200\n+++ /tmp/tmpr8f07_lg.java\t2022-07-12 14:29:51.251090584 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return quadrantMatch(n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return allResultsMatch(n, recurse);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:54.935090604 +0200\n+++ /tmp/tmpmmweyhk8.java\t2022-07-12 14:29:54.935090604 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse);\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return allResultsMatch(n, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:29:58.435090496 +0200\n+++ /tmp/tmpcrn9p8nd.java\t2022-07-12 14:29:58.435090496 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(n, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return allResultsMatch(lhs, n, recurse;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-10/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 14:30:01.835090245 +0200\n+++ /tmp/tmpkn_2k46w.java\t2022-07-12 14:30:01.835090245 +0200\n@@ -1412,11 +1412,11 @@\n     return mayBeString(n, true);\n   }\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+return allResultsMatch(lhs, n, recurse;\n     } else {\n       return mayBeStringHelper(n);\n     }\n   }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return allResultsMatch(n, MAY_BE_STRING_PREDICATE);",
        "fixed_line": "return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);"
    },
    "JacksonCore-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:05.735089792 +0200\n+++ /tmp/tmp77_3oo55.java\t2022-07-12 14:30:05.839089778 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:11.091088881 +0200\n+++ /tmp/tmpfx28cl3u.java\t2022-07-12 14:30:11.091088881 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:15.659087841 +0200\n+++ /tmp/tmp41ipta9s.java\t2022-07-12 14:30:15.659087841 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:17.255087422 +0200\n+++ /tmp/tmpk1wo121f.java\t2022-07-12 14:30:17.255087422 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:18.759087003 +0200\n+++ /tmp/tmp1uoqn5p3.java\t2022-07-12 14:30:18.759087003 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:23.571085484 +0200\n+++ /tmp/tmp9ixav69n.java\t2022-07-12 14:30:23.571085484 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:28.203083780 +0200\n+++ /tmp/tmpkn2_rxwx.java\t2022-07-12 14:30:28.203083780 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_type == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:29.851083114 +0200\n+++ /tmp/tmphp0vuakf.java\t2022-07-12 14:30:29.851083114 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (_currentSegment.length == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:31.407082459 +0200\n+++ /tmp/tmpm6fxseeu.java\t2022-07-12 14:30:31.407082459 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN? (MAX_SEGMENT_LEN + 1) : Math.min(MAX_SEGMENT_LEN, len + (len % 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-4/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:30:32.923081796 +0200\n+++ /tmp/tmpn466x12n.java\t2022-07-12 14:30:32.923081796 +0200\n@@ -581,11 +581,11 @@\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+int newLen = (len == MAX_SEGMENT_LEN)? (MAX_SEGMENT_LEN + 5) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n     /**\n      * Method called to expand size of the current segment, to\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));",
        "fixed_line": "int newLen = len + (len >> 1); // but above intended maximum, slow to increase by 25% if (newLen > MAX_SEGMENT_LEN) { newLen = len + (len >> 2); }"
    },
    "Mockito-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_o1 == null || o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:30:37.747079514 +0200\n+++ /tmp/tmpbnqohd9x.java\t2022-07-12 14:30:37.779079494 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (_o1 == null || o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_o1 == null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:30:41.371077636 +0200\n+++ /tmp/tmph5pta36v.java\t2022-07-12 14:30:41.371077636 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (_o1 == null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_o1 == null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:30:44.103076124 +0200\n+++ /tmp/tmpv6o89rxv.java\t2022-07-12 14:30:44.103076124 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (_o1 == null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (o1 == null &&o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:30:46.791074558 +0200\n+++ /tmp/tmp8nherg67.java\t2022-07-12 14:30:46.795074557 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null &&o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (o1 == null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:31:24.051045086 +0200\n+++ /tmp/tmplw7zwfyx.java\t2022-07-12 14:31:24.055045084 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (o1 == null &&o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:31:58.651005331 +0200\n+++ /tmp/tmpioc94dcm.java\t2022-07-12 14:31:58.651005331 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null &&o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (o1 == null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:32:33.350954282 +0200\n+++ /tmp/tmp2utjjyqb.java\t2022-07-12 14:32:33.350954282 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (o1 == null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if(o1 == null && o2!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:33:07.598893639 +0200\n+++ /tmp/tmpvx3l7tck.java\t2022-07-12 14:33:07.598893639 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if(o1 == null && o2!= null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if(o1 == null && o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:33:42.474822096 +0200\n+++ /tmp/tmphj31didg.java\t2022-07-12 14:33:42.474822096 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if(o1 == null && o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_o1 == null &&o2 == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-22/src/org/mockito/internal/matchers/Equality.java\t2022-07-12 14:34:17.062742024 +0200\n+++ /tmp/tmpcjldx77k.java\t2022-07-12 14:34:17.062742024 +0200\n@@ -8,11 +8,11 @@\n \n //stolen from hamcrest because I didn't want to have more dependency than Matcher class \n public class Equality {\n \n     public static boolean areEqual(Object o1, Object o2) {\n-        if (o1 == null || o2 == null) {\n+if (_o1 == null &&o2 == null) {\n             return o1 == null && o2 == null;\n         } else if (isArray(o1)) {\n             return isArray(o2) && areArraysEqual(o1, o2);\n         } else {\n             return o1.equals(o2);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (o1 == null || o2 == null) {",
        "fixed_line": "if (o1 == o2 ) { return true; } else if (o1 == null || o2 == null) {"
    },
    "Math-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < lhsWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:19.890735097 +0200\n+++ /tmp/tmp8ilpsqsn.java\t2022-07-12 14:34:19.982734870 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < lhsWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < accumWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:23.274726731 +0200\n+++ /tmp/tmps_xh321_.java\t2022-07-12 14:34:23.278726720 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accumWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < accum.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:25.370721506 +0200\n+++ /tmp/tmprepkzua1.java\t2022-07-12 14:34:25.370721506 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accum.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < paddingWts.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:27.486716205 +0200\n+++ /tmp/tmp_zbswqoa.java\t2022-07-12 14:34:27.486716205 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < paddingWts.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < accumWts.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:29.586710911 +0200\n+++ /tmp/tmp7g0k24je.java\t2022-07-12 14:34:29.586710911 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < accumWts.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < paddingWts; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:31.678705606 +0200\n+++ /tmp/tmp40fstb0a.java\t2022-07-12 14:34:31.678705606 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < paddingWts; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < totalAnchor.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:33.838700097 +0200\n+++ /tmp/tmpdhdbujmt.java\t2022-07-12 14:34:33.842700090 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < totalAnchor.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < weights.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:35.934694724 +0200\n+++ /tmp/tmpoob2pr88.java\t2022-07-12 14:34:35.934694724 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i <Prefix.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:56.742639752 +0200\n+++ /tmp/tmpezz9pg54.java\t2022-07-12 14:34:56.746639738 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i <Prefix.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < name.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-41/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\t2022-07-12 14:34:58.834634063 +0200\n+++ /tmp/tmpcw9zense.java\t2022-07-12 14:34:58.834634063 +0200\n@@ -515,11 +515,11 @@\n                     accum += weights[i] * (dev * dev);\n                     accum2 += weights[i] * dev;\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+for (int i = 0; i < name.length; i++) {\n                     sumWts += weights[i];\n                 }\n \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < weights.length; i++) {",
        "fixed_line": "for (int i = begin; i < begin + length; i++) {"
    },
    "Chart-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "// if (this.shape == null) {",
                "patch_diff": "// if (this.shape == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.shape == A boolean.class || this.shape.isArray()) {",
                "patch_diff": "this.shape == A boolean.class || this.shape.isArray()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.shape = A boolean. * this.shapeCount;",
                "patch_diff": "this.shape = A boolean. * this.shapeCount;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.shape == A boolean.class || this.shape.FALSE) {",
                "patch_diff": "this.shape == A boolean.class || this.shape.FALSE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.shape. * this.shape.millisecond;",
                "patch_diff": "this.shape. * this.shape.millisecond;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_CENTER || this.shape.isArray())",
                "patch_diff": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_CENTER || this.shape.isArray())",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_CENTER;",
                "patch_diff": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_CENTER;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.shape = A boolean. * this.shape;",
                "patch_diff": "this.shape = A boolean. * this.shape;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_RIGHT;",
                "patch_diff": "this.shape == A boolean.class || this.shape == TextAnchor.BOTTOM_RIGHT;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.shape == A boolean.class || this.shapeAnchor == null) {",
                "patch_diff": "this.shape == A boolean.class || this.shapeAnchor == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof MinMaxCategoryRenderer)) { return false; } MinMaxCategoryRenderer that = (MinMaxCategoryRenderer) obj; if (this.plotLines != that.plotLines) { return false; } if (!PaintUtilities.equal(this.groupPaint, that.groupPaint)) { return false; } if (!this.groupStroke.equals(that.groupStroke)) { return false; } return super.equals(obj); }"
    },
    "Math-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // } else if (f = new UnivariateRealFunction() {",
                "patch_diff": "// // } else if (f = new UnivariateRealFunction() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // } else if (f = new UnivariateRealFunction) {",
                "patch_diff": "// // } else if (f = new UnivariateRealFunction) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // [JACKSON-139] = new UnivariateRealFunction() {",
                "patch_diff": "// // [JACKSON-139] = new UnivariateRealFunction() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // } else if (f = new UnivariateRealFunction() == 0) {",
                "patch_diff": "// // } else if (f = new UnivariateRealFunction() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for 2;",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for 2;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for the same",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for the same",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // [JACKSON-139] = new UnivariateRealFunction;",
                "patch_diff": "// // [JACKSON-139] = new UnivariateRealFunction;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ga * gb > 0) { // this is a corner case: // - there was an event near ta, // - there is another event between ta and tb // - when ta was computed, convergence was reached on the \"wrong side\" of the interval // this implies that the real sign of ga is the same as gb, so we need to slightly // shift ta to make sure ga and gb get opposite signs and the solver won't complain // about bracketing final double epsilon = (forward ? 0.25 : -0.25) * convergence; for (int k = 0; (k < 4) && (ga * gb > 0); ++k) { ta += epsilon; interpolator.setInterpolatedTime(ta); ga = handler.g(ta, interpolator.getInterpolatedState()); } if (ga * gb > 0) { // this should never happen throw MathRuntimeException.createInternalError(null); } }"
    },
    "Math-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "double[] prodHigh = new double[len];",
                "patch_diff": "double[] prodHigh = new double[len];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < len; i++) {",
                "patch_diff": "for (int i = 0; i < len; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double[] prodLowSum = new double[len];",
                "patch_diff": "double[] prodLowSum = new double[len];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (len!= b.length) {",
                "patch_diff": "if (len!= b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new DimensionMismatchException(len, b.length) {",
                "patch_diff": "throw new DimensionMismatchException(len, b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new DimensionMismatchException(len, b.length;",
                "patch_diff": "throw new DimensionMismatchException(len, b.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new DimensionMismatchException(len, b.length + len;",
                "patch_diff": "throw new DimensionMismatchException(len, b.length + len;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// Revert to scalar = new double[len];",
                "patch_diff": "// Revert to scalar = new double[len];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double[] prodHigh = new double[len]; if (len!= b.length) {",
                "patch_diff": "double[] prodHigh = new double[len]; if (len!= b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (len == b.length) {",
                "patch_diff": "if (len == b.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (len == 1) { // Revert to scalar multiplication. return a[0] * b[0]; }"
    },
    "Lang-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:06.454613111 +0200\n+++ /tmp/tmp8e16ihkg.java\t2022-07-12 14:35:06.502612980 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:08.358607818 +0200\n+++ /tmp/tmpc40v5ts7.java\t2022-07-12 14:35:08.358607818 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:09.918603464 +0200\n+++ /tmp/tmp08rd4tpv.java\t2022-07-12 14:35:09.918603464 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:19.930575149 +0200\n+++ /tmp/tmpwqi5zvdd.java\t2022-07-12 14:35:19.930575149 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0, Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:21.422570873 +0200\n+++ /tmp/tmp3sjs7v1y.java\t2022-07-12 14:35:21.422570873 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:22.970566428 +0200\n+++ /tmp/tmpeipbbu1u.java\t2022-07-12 14:35:22.970566428 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:24.538561905 +0200\n+++ /tmp/tmp1nl9v7f_.java\t2022-07-12 14:35:24.538561905 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:26.042557554 +0200\n+++ /tmp/tmpiqwdn0b9.java\t2022-07-12 14:35:26.042557554 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:27.578553096 +0200\n+++ /tmp/tmp7wvsyy39.java\t2022-07-12 14:35:27.578553096 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-58/src/java/org/apache/commons/lang/math/NumberUtils.java\t2022-07-12 14:35:29.090548692 +0200\n+++ /tmp/tmpinienha1.java\t2022-07-12 14:35:29.090548692 +0200\n@@ -449,12 +449,11 @@\n             switch (lastChar) {\n                 case 'l' :\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+&& isDigits(numeric.substring(1 || (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0.0 & Character.numericnumeric.charAt(0)))) {\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {\n                             //Too big for a long\n                         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "&& isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {",
        "fixed_line": "&& (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {"
    },
    "Math-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:30.958543234 +0200\n+++ /tmp/tmp159ojd7h.java\t2022-07-12 14:35:31.010543084 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:34.774532014 +0200\n+++ /tmp/tmpxyn9bmr4.java\t2022-07-12 14:35:34.774532014 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:37.902522753 +0200\n+++ /tmp/tmppoa26fny.java\t2022-07-12 14:35:37.902522753 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:41.022513455 +0200\n+++ /tmp/tmpn_kw679v.java\t2022-07-12 14:35:41.022513455 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:44.066504325 +0200\n+++ /tmp/tmpq6lu51zm.java\t2022-07-12 14:35:44.066504325 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sum sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:47.154495009 +0200\n+++ /tmp/tmpsbv32v8_.java\t2022-07-12 14:35:47.154495009 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sum sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return sumYY - sum.0, sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:50.246485626 +0200\n+++ /tmp/tmpv_cii38z.java\t2022-07-12 14:35:50.246485626 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sum.0, sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:53.298476307 +0200\n+++ /tmp/tmpjz278_4h.java\t2022-07-12 14:35:53.298476307 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY * sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY / sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:56.442466650 +0200\n+++ /tmp/tmp8itv97bb.java\t2022-07-12 14:35:56.442466650 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXY / sumXY / sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-105/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\t2022-07-12 14:35:59.598456897 +0200\n+++ /tmp/tmpljq6qpe0.java\t2022-07-12 14:35:59.598456897 +0200\n@@ -259,11 +259,11 @@\n      * </li></ul>\n      *\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return sumYY - sumXY * sumXY / sumXX; return sumYY - sumXY * sumXX;\n     }\n \n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return sumYY - sumXY * sumXY / sumXX;",
        "fixed_line": "return Math.max(0d, sumYY - sumXY * sumXY / sumXX);"
    },
    "Jsoup-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "reindexChildren(in = rep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:02.842446814 +0200\n+++ /tmp/tmpmnj1__pa.java\t2022-07-12 14:36:02.870446726 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = rep;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "reindexChildren(lastJump = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:04.678441079 +0200\n+++ /tmp/tmpquxwwz_c.java\t2022-07-12 14:36:04.678441079 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = 0;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "reindexChildren(in = NO_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:06.222436242 +0200\n+++ /tmp/tmpgyyd5s33.java\t2022-07-12 14:36:06.226436230 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = NO_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "reindexChildren(index);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:07.722431529 +0200\n+++ /tmp/tmpxe6a4lsf.java\t2022-07-12 14:36:07.722431529 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(index);\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "reindexChildren(lastJump = rep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:11.642419154 +0200\n+++ /tmp/tmpj7hwx9sb.java\t2022-07-12 14:36:11.642419154 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = rep;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "reindexChildren(in;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:13.154414358 +0200\n+++ /tmp/tmpe5ckwile.java\t2022-07-12 14:36:13.154414358 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "reindexChildren(lastJump = NO_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:14.678409508 +0200\n+++ /tmp/tmpna0op76z.java\t2022-07-12 14:36:14.678409508 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(lastJump = NO_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "reindexChildren(in = L_NODE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:16.238404536 +0200\n+++ /tmp/tmpgh9f87r7.java\t2022-07-12 14:36:16.238404536 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = L_NODE;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "reindexChildren(in = rep.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:17.826399454 +0200\n+++ /tmp/tmp4y4e9oga.java\t2022-07-12 14:36:17.826399454 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in = rep.length;\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "reindexChildren(in);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-49/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 14:36:19.366394517 +0200\n+++ /tmp/tmp96ii5jkm.java\t2022-07-12 14:36:19.366394517 +0200\n@@ -441,11 +441,11 @@\n         for (int i = children.length - 1; i >= 0; i--) {\n             Node in = children[i];\n             reparentChild(in);\n             childNodes.add(index, in);\n         }\n-        reindexChildren(index);\n+reindexChildren(in);\n     }\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {\n             childNodes = new ArrayList<Node>(4);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "reindexChildren(index);",
        "fixed_line": "reindexChildren(index);"
    },
    "Math-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (meanImpl instanceof Mean; meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:21.198388621 +0200\n+++ /tmp/tmptrfcj910.java\t2022-07-12 14:36:21.234388509 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean; meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (meanImpl instanceof Mean; double meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:24.110379218 +0200\n+++ /tmp/tmp19sorhbz.java\t2022-07-12 14:36:24.114379202 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean; double meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (meanImpl.increment(meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:26.082372820 +0200\n+++ /tmp/tmp_vqf3scw.java\t2022-07-12 14:36:26.082372820 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment(meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (meanImpl!= null) meanImpl.increment) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:28.146366103 +0200\n+++ /tmp/tmpvlzy3xr9.java\t2022-07-12 14:36:28.146366103 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl!= null) meanImpl.increment) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (meanImpl instanceof Mean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:30.194359414 +0200\n+++ /tmp/tmptwzsyvsd.java\t2022-07-12 14:36:30.194359414 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (meanImpl.increment(meanImpl instanceof Mean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:49.870294001 +0200\n+++ /tmp/tmpic_xigk1.java\t2022-07-12 14:36:49.870294001 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment(meanImpl instanceof Mean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (meanImpl instanceof Mean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:52.050286629 +0200\n+++ /tmp/tmpjvxsxwei.java\t2022-07-12 14:36:52.050286629 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean)) {\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (meanImpl instanceof Mean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:54.086279719 +0200\n+++ /tmp/tmpyiemxjk_.java\t2022-07-12 14:36:54.086279719 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean;\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (meanImpl instanceof Mean) { meanImpl.increment; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:56.166272639 +0200\n+++ /tmp/tmp_3k9a6z1.java\t2022-07-12 14:36:56.166272639 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl instanceof Mean) { meanImpl.increment; }\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (meanImpl.increment) { meanImpl.increment; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-43/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\t2022-07-12 14:36:58.122265959 +0200\n+++ /tmp/tmpk_oumhah.java\t2022-07-12 14:36:58.122265959 +0200\n@@ -153,17 +153,11 @@\n         maxImpl.increment(value);\n         sumLogImpl.increment(value);\n         secondMoment.increment(value);\n         // If mean, variance or geomean have been overridden,\n         // need to increment these\n-        if (!(meanImpl instanceof Mean)) {\n-            meanImpl.increment(value);\n-        }\n-        if (!(varianceImpl instanceof Variance)) {\n-            varianceImpl.increment(value);\n-        }\n-        if (!(geoMeanImpl instanceof GeometricMean)) {\n+if (meanImpl.increment) { meanImpl.increment; }\n             geoMeanImpl.increment(value);\n         }\n         n++;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!(meanImpl instanceof Mean)) { meanImpl.increment(value); } if (!(varianceImpl instanceof Variance)) { varianceImpl.increment(value); } if (!(geoMeanImpl instanceof GeometricMean)) {",
        "fixed_line": "if (meanImpl != mean) { meanImpl.increment(value); } if (varianceImpl != variance) { varianceImpl.increment(value); } if (geoMeanImpl != geoMean) {"
    },
    "Jsoup-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < childNodes.length; i++) {",
                "patch_diff": "for (int i = 0; i < childNodes.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int i = 0; i < childNodes.length; i++) {",
                "patch_diff": "// for (int i = 0; i < childNodes.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Node furthestBlock = furthestBlock.getBaseUri());",
                "patch_diff": "for (Node furthestBlock = furthestBlock.getBaseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < childNodes.length;",
                "patch_diff": "for (int i = 0; i < childNodes.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (furthestBlock.getBaseUri());",
                "patch_diff": "if (furthestBlock.getBaseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int i = 0; i < childNodes.length;",
                "patch_diff": "// for (int i = 0; i < childNodes.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int c = 0; i < childNodes.length; i++) {",
                "patch_diff": "for (int c = 0; i < childNodes.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (Node furthestBlock = furthestBlock.getBaseUri();",
                "patch_diff": "for (Node furthestBlock = furthestBlock.getBaseUri();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (Node furthestBlock = furthestBlock;",
                "patch_diff": "for (Node furthestBlock = furthestBlock;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (furthestBlock.removeBaseUri) {",
                "patch_diff": "if (furthestBlock.removeBaseUri) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "adopter.attributes().addAll(formatEl.attributes());"
    },
    "Closure-127": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nextCfgNode!= field) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:37:02.038252527 +0200\n+++ /tmp/tmp5dome1ud.java\t2022-07-12 14:37:02.090252349 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= field) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nextCfgNode!= nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:37:06.978235470 +0200\n+++ /tmp/tmpohnnm5e6.java\t2022-07-12 14:37:06.978235470 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (nextCfgNode!= child) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:37:54.470065330 +0200\n+++ /tmp/tmpj7w8amgo.java\t2022-07-12 14:37:54.470065330 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= child) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (nextCfgNode!= childCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:37:58.014052200 +0200\n+++ /tmp/tmp17cj1o73.java\t2022-07-12 14:37:58.014052200 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= childCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (nextCfgNode == nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:38:01.498039239 +0200\n+++ /tmp/tmpfbc7gxj4.java\t2022-07-12 14:38:01.502039222 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode == nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nextCfgNode!= firstCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:38:46.921865300 +0200\n+++ /tmp/tmpn2ziwfqs.java\t2022-07-12 14:38:46.925865285 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= firstCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nextCfgNode instanceof fallThrough) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:38:50.389851656 +0200\n+++ /tmp/tmp1b_f9ya2.java\t2022-07-12 14:38:50.389851656 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode instanceof fallThrough) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (nextCfgNode!= 10) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:38:53.769838311 +0200\n+++ /tmp/tmpr4ionk9_.java\t2022-07-12 14:38:53.773838295 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= 10) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nextCfgNode!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:38:57.365824058 +0200\n+++ /tmp/tmpadesx43n.java\t2022-07-12 14:38:57.369824042 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= null) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (nextCfgNode!= field && nextCfgNode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-127/src/com/google/javascript/jscomp/UnreachableCodeElimination.java\t2022-07-12 14:39:42.197642056 +0200\n+++ /tmp/tmptutc_ps6.java\t2022-07-12 14:39:42.197642056 +0200\n@@ -165,11 +165,11 @@\n \n             Preconditions.checkState(\n                 outEdges.get(0).getValue() == Branch.UNCOND);\n             Node fallThrough = computeFollowing(n);\n             Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n-            if (nextCfgNode == fallThrough) {\n+if (nextCfgNode!= field && nextCfgNode) {\n               removeNode(n);\n             }\n           }\n       }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (nextCfgNode == fallThrough) {",
        "fixed_line": "if (nextCfgNode == fallThrough && !inFinally(n.getParent(), n)) { removeNode(n); } } } } private boolean inFinally(Node parent, Node child) { if (parent == null || parent.isFunction()) { return false; } else if (NodeUtil.isTryFinallyNode(parent, child)) { return true; } else { return inFinally(parent.getParent(), parent); } }"
    },
    "Closure-120": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (block!= null) {",
                "patch_diff": "if (block!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (block == null) {",
                "patch_diff": "if (block == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (block!= null) {",
                "patch_diff": "} else if (block!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (block!= null && block.isFunction) {",
                "patch_diff": "if (block!= null && block.isFunction) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (block.isFunction) {",
                "patch_diff": "} else if (block.isFunction) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (block.isLoop) {",
                "patch_diff": "if (block.isLoop) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (block == null; block = parent.getParent()) {",
                "patch_diff": "if (block == null; block = parent.getParent()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (block == null) {",
                "patch_diff": "} else if (block == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (block.isLoop()) {",
                "patch_diff": "if (block.isLoop()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// block == null; block = block.getBasicBlock();",
                "patch_diff": "// block == null; block = block.getBasicBlock();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (ref.getSymbol().getScope() != ref.scope) { return false; }"
    },
    "Cli-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:47.461620179 +0200\n+++ /tmp/tmpqo4xi272.java\t2022-07-12 14:39:47.493620046 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.validateLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:49.233612791 +0200\n+++ /tmp/tmp5ypsmq9b.java\t2022-07-12 14:39:49.237612775 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validateLine;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option.validatevalidate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:50.857606010 +0200\n+++ /tmp/tmpefgly_p9.java\t2022-07-12 14:39:50.857606010 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validatevalidate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:52.345599788 +0200\n+++ /tmp/tmplmgxz96u.java\t2022-07-12 14:39:52.345599788 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option ) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (option.validate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:53.889593325 +0200\n+++ /tmp/tmph12n_1ka.java\t2022-07-12 14:39:53.889593325 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (option.validate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:55.401586987 +0200\n+++ /tmp/tmpp9w3a6i2.java\t2022-07-12 14:39:55.401586987 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (option ==validate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:56.957580455 +0200\n+++ /tmp/tmpx3vmohkq.java\t2022-07-12 14:39:56.957580455 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option ==validate) {\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (option.validateLine++commandLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:39:58.533573829 +0200\n+++ /tmp/tmpx6p0lvx2.java\t2022-07-12 14:39:58.533573829 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validateLine++commandLine;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (option.validatevalidate(option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:40:00.041567482 +0200\n+++ /tmp/tmptutzvn6f.java\t2022-07-12 14:40:00.041567482 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validatevalidate(option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (option.validate(option.validate(option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-14/src/java/org/apache/commons/cli2/option/GroupImpl.java\t2022-07-12 14:40:01.553561108 +0200\n+++ /tmp/tmp6geeef_r.java\t2022-07-12 14:40:01.553561108 +0200\n@@ -245,13 +245,11 @@\n         for (final Iterator i = options.iterator(); i.hasNext();) {\n             final Option option = (Option) i.next();\n \n             // needs validation?\n             boolean validate = option.isRequired() || option instanceof Group;\n-            if (validate) {\n-                option.validate(commandLine);\n-            }\n+if (option.validate(option.validate(option;\n \n             // if the child option is present then validate it\n             if (commandLine.hasOption(option)) {\n                 if (++present > maximum) {\n                     unexpected = option;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (validate) { option.validate(commandLine); }",
        "fixed_line": "validate = true; } if (validate) {"
    },
    "Chart-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:03.469553021 +0200\n+++ /tmp/tmplqr4d42a.java\t2022-07-12 14:40:03.525552785 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:05.725543482 +0200\n+++ /tmp/tmprwy5pw44.java\t2022-07-12 14:40:05.725543482 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:07.357536569 +0200\n+++ /tmp/tmp829sk44g.java\t2022-07-12 14:40:07.357536569 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:09.009529564 +0200\n+++ /tmp/tmper7wpqyq.java\t2022-07-12 14:40:09.009529564 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - v;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:10.697522393 +0200\n+++ /tmp/tmpscq_m8i3.java\t2022-07-12 14:40:10.697522393 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:12.313515520 +0200\n+++ /tmp/tmpcnkwl2lu.java\t2022-07-12 14:40:12.337515418 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) / (this.upperBound - this.lowerBound);\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:13.953508535 +0200\n+++ /tmp/tmp89x6awmc.java\t2022-07-12 14:40:13.953508535 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:15.529501814 +0200\n+++ /tmp/tmpu420cp3e.java\t2022-07-12 14:40:15.529501814 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.upperBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:17.157494862 +0200\n+++ /tmp/tmpedsgx2v4.java\t2022-07-12 14:40:17.157494862 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound)) * (this.upperBound - this.upperBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - this.lowerBound;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-24/source/org/jfree/chart/renderer/GrayPaintScale.java\t2022-07-12 14:40:18.881487490 +0200\n+++ /tmp/tmpq9sluy8s.java\t2022-07-12 14:40:18.881487490 +0200\n@@ -121,11 +121,11 @@\n      * @return A paint for the specified value.\n      */\n     public Paint getPaint(double value) {\n         double v = Math.max(value, this.lowerBound);\n         v = Math.min(v, this.upperBound);\n-        int g = (int) ((value - this.lowerBound) / (this.upperBound \n+int g = (int) ((value - this.lowerBound) / (this.upperBound - this.lowerBound) * (this.upperBound - this.lowerBound;\n                 - this.lowerBound) * 255.0);\n         return new Color(g, g, g);\n     }\n     \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int g = (int) ((value - this.lowerBound) / (this.upperBound",
        "fixed_line": "int g = (int) ((v - this.lowerBound) / (this.upperBound"
    },
    "Closure-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "parameters.hasNext force') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:20.581480208 +0200\n+++ /tmp/tmpf0ksftw6.java\t2022-07-12 14:40:20.637479968 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext force') {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "parameters.hasNextCall) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:22.609471512 +0200\n+++ /tmp/tmpc9n6vru8.java\t2022-07-12 14:40:22.613471494 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextCall) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "parameters.hasNext()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:24.505463367 +0200\n+++ /tmp/tmp3wmo5gm1.java\t2022-07-12 14:40:24.509463352 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext()) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "parameters.hasNextProcessing) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:49.033356906 +0200\n+++ /tmp/tmp6vbesl75.java\t2022-07-12 14:40:49.037356889 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextProcessing) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "parameters.hasNextItemCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:50.749349381 +0200\n+++ /tmp/tmpghawww31.java\t2022-07-12 14:40:50.753349364 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextItemCount;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "parameters.hasNext;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:52.337342410 +0200\n+++ /tmp/tmp2lqm57sc.java\t2022-07-12 14:40:52.341342394 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "parameters.hasNextCall {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:53.953335308 +0200\n+++ /tmp/tmpf7ulv7z5.java\t2022-07-12 14:40:53.953335308 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNextCall {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "parameters.hasNext]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:55.585328127 +0200\n+++ /tmp/tmpco6nbyo7.java\t2022-07-12 14:40:55.589328110 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext]) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "parameters.hasNext Dis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:57.137321290 +0200\n+++ /tmp/tmpuut61ghc.java\t2022-07-12 14:40:57.141321273 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext Dis;\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "parameters.hasNext();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-96/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 14:40:58.753314160 +0200\n+++ /tmp/tmp23_khhrk.java\t2022-07-12 14:40:58.757314143 +0200\n@@ -1404,11 +1404,11 @@\n     Iterator<Node> parameters = functionType.getParameters().iterator();\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n     while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+parameters.hasNext();\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n         parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "parameters.hasNext()) {",
        "fixed_line": "(parameters.hasNext() || parameter != null && parameter.isVarArgs())) { // If there are no parameters left in the list, then the while loop // above implies that this must be a var_args function. if (parameters.hasNext()) { parameter = parameters.next(); }"
    },
    "Time-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static long safeMultiply(val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "patch_diff": "private static long safeMultiply(val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static long safeMultiply(val1, int val2) {",
                "patch_diff": "private static long safeMultiply(val1, int val2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "patch_diff": "static long safeMultiply(long val1, int val2; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L; case 1: return 0L;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val1 == Long.MIN_VALUE) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); }"
    },
    "JacksonDatabind-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JDK.add(\"com/#1737];",
                "patch_diff": "JDK.add(\"com/#1737];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FILE_NAMES; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FILE_NAMES; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int k = 0; i < MAX_DESERIALIZERS; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int k = 0; i < MAX_DESERIALIZERS; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < n; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < n; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; ++i) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < nGroups; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < nGroups; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS;",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "Closure-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "return node; processForInLoop loopNode.getIterator()), transformBlock;",
                "patch_diff": "return node; processForInLoop loopNode.getIterator()), transformBlock;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return node; processForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "patch_diff": "return node; processForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return node; processForInLoop loopNode) {",
                "patch_diff": "return node; processForInLoop loopNode) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock;",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return newNode; processForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "patch_diff": "return newNode; processForInLoop loopNode.getIterator()), transformBlock(loopNode);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return newNode; processForInLoop loopNode.getIterator()), transformBlock;",
                "patch_diff": "return newNode; processForInLoop loopNode.getIterator()), transformBlock;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false);",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return node; processForInLoop loopNode.FOR, transformBlock);",
                "patch_diff": "return node; processForInLoop loopNode.FOR, transformBlock);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false) {",
                "patch_diff": "return newNodeForInLoop loopNode.getIterator()), transformBlock(loopNode.getIteratedObject()), false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (loopNode.isForEach()) { errorReporter.error( \"unsupported language extension: for each\", sourceName, loopNode.getLineno(), \"\", 0); // Return the bare minimum to put the AST in a valid state. return newNode(Token.EXPR_RESULT, Node.newNumber(0)); }"
    },
    "Closure-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return resultEqualsValue && ctorType.isSubtype(typetype)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:06.453280082 +0200\n+++ /tmp/tmp302acpks.java\t2022-07-12 14:41:06.489279923 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(typetype)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:11.277258638 +0200\n+++ /tmp/tmpw_6xod5g.java\t2022-07-12 14:41:11.277258638 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return ctorType && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:14.785242996 +0200\n+++ /tmp/tmphxr_h2lq.java\t2022-07-12 14:41:14.789242978 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return ctorType && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type, ctorType? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:18.301227281 +0200\n+++ /tmp/tmppdgxoxlo.java\t2022-07-12 14:41:18.301227281 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type, ctorType? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type == null? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:21.545212746 +0200\n+++ /tmp/tmpm1bz67dv.java\t2022-07-12 14:41:21.545212746 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type == null? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return ctorType && ctorType.isSubtype(typetype)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:24.969197372 +0200\n+++ /tmp/tmp0dwdar1a.java\t2022-07-12 14:41:24.969197372 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return ctorType && ctorType.isSubtype(typetype)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:41:28.621180933 +0200\n+++ /tmp/tmpq55gg5c3.java\t2022-07-12 14:41:28.621180933 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type)? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return resultEqualsValue && ctorType.isSubtype(typeOfType? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:42:17.436957397 +0200\n+++ /tmp/tmplzk57_9o.java\t2022-07-12 14:42:17.440957380 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(typeOfType? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:42:20.772941874 +0200\n+++ /tmp/tmpxpj_2rhp.java\t2022-07-12 14:42:20.776941854 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type))? ctorType : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return resultEqualsValue && ctorType.isSubtype(type : null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-7/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\t2022-07-12 14:42:24.032926673 +0200\n+++ /tmp/tmpg_1dwovu.java\t2022-07-12 14:42:24.032926673 +0200\n@@ -608,11 +608,11 @@\n \n     @Override\n     public JSType caseObjectType(ObjectType type) {\n       if (value.equals(\"function\")) {\n         JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n-        return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;\n+return resultEqualsValue && ctorType.isSubtype(type : null;\n           // Objects are restricted to \"Function\", subtypes are left\n           // Only filter out subtypes of \"function\"\n       }\n       return matchesExpectation(\"object\") ? type : null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : null;",
        "fixed_line": "if (resultEqualsValue) { // Objects are restricted to \"Function\", subtypes are left return ctorType.getGreatestSubtype(type); } else { // Only filter out subtypes of \"function\" return type.isSubtype(ctorType) ? null : type; }"
    },
    "Math-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return multiply(100 instanceof multiply(100);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:27.484910545 +0200\n+++ /tmp/tmpgh6qm6mv.java\t2022-07-12 14:42:27.512910413 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100 instanceof multiply(100);\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return b.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:31.024893972 +0200\n+++ /tmp/tmpnpm9y3p0.java\t2022-07-12 14:42:31.024893972 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return b.doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "returnnot(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:33.384882907 +0200\n+++ /tmp/tmphycn6ken.java\t2022-07-12 14:42:33.384882907 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+returnnot(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return multiply(100.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:35.556872708 +0200\n+++ /tmp/tmpy550c1g8.java\t2022-07-12 14:42:35.556872708 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100.doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return multiply(100 instanceof multiply(100;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:37.676862742 +0200\n+++ /tmp/tmp3qco7oo8.java\t2022-07-12 14:42:37.676862742 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100 instanceof multiply(100;\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return multiply(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:42:39.688853272 +0200\n+++ /tmp/tmpe79b67f9.java\t2022-07-12 14:42:39.688853272 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return neg(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:43:14.376688352 +0200\n+++ /tmp/tmp4m5r5057.java\t2022-07-12 14:43:14.376688352 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return neg(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return multiply(100);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:43:16.492678193 +0200\n+++ /tmp/tmpu_5sfwhs.java\t2022-07-12 14:43:16.492678193 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100);\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return numerator(100).doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:43:18.572668196 +0200\n+++ /tmp/tmp7hj41xe_.java\t2022-07-12 14:43:18.576668177 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return numerator(100).doubleValue();\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return multiply(100;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-27/src/main/java/org/apache/commons/math3/fraction/Fraction.java\t2022-07-12 14:43:20.792657514 +0200\n+++ /tmp/tmpd0_yf0do.java\t2022-07-12 14:43:20.796657496 +0200\n@@ -592,11 +592,11 @@\n      * </p>\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+return multiply(100;\n     }\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts\n      * of a fraction Y/Z.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return multiply(100).doubleValue();",
        "fixed_line": "return 100 * doubleValue();"
    },
    "Closure-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (var == null || var.getString()!= null &&!blacklistedVars.contains(var);",
                "patch_diff": "if (var == null || var.getString()!= null &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return var.getString()); return var.getScope() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "return var.getString()); return var.getScope() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (var == null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "} else if (var == null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (var == null && var.getString() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "if (var == null && var.getString() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return var!= null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "return var!= null && var.getScope() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (var == null || var.getScope() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "if (var == null || var.getScope() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var;",
                "patch_diff": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (var == null || var.getString() == s &&!blacklistedVars.contains(var);",
                "patch_diff": "if (var == null || var.getString() == s &&!blacklistedVars.contains(var);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var) {",
                "patch_diff": "if (var == null && var.getScope() == s &&!blacklistedVars.contains(var) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "&& !isNamedParameter(var) && !blacklistedVars.contains(var); } } private boolean isNamedParameter(Var v) { return v.getParentNode().isParamList(); }"
    },
    "Jsoup-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (doc.outputSettings == null) {",
                "patch_diff": "if (doc.outputSettings == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (doc.outputSettings!= null) {",
                "patch_diff": "if (doc.outputSettings!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (doc.outputSettings == null) {",
                "patch_diff": "} else if (doc.outputSettings == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (doc.parseInput(text, offset, length);",
                "patch_diff": "if (doc.parseInput(text, offset, length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (doc.parseInput(text, offset, len);",
                "patch_diff": "if (doc.parseInput(text, offset, len);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (doc == null) {",
                "patch_diff": "if (doc == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (doc.outputSettings().is a spurious byte-order",
                "patch_diff": "if (doc.outputSettings().is a spurious byte-order",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (doc.parseInput(text, offset, length) {",
                "patch_diff": "if (doc.parseInput(text, offset, length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (doc.outputSettings().charset;",
                "patch_diff": "if (doc.outputSettings().charset;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (doc.outputSettings().is a spurious byte-order;",
                "patch_diff": "if (doc.outputSettings().is a spurious byte-order;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (docData.charAt(0) == 65279) docData = docData.substring(1);"
    },
    "Math-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (f0 *= (f1 / (f1 + fx); break;",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (f0 *= (f1 / (f1 + fx) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx) * DateTimeConstants.MILLIS_PER_HOUR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (f0 *= (f1 / (f1 + fx);",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new Math Math(f1 * (f1 + fx); break;",
                "patch_diff": "throw new Math Math(f1 * (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (f0 *= (f1 / (f1 + fx;",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// f0 *= (f1 / (f1 + fx); break;",
                "patch_diff": "// f0 *= (f1 / (f1 + fx); break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSI:",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSI:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSI: //",
                "patch_diff": "if (f0 *= (f1 / (f1 + fx); break; case REGULA_FALSI: //",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// f0 *= (f1 / (f1 + fx);",
                "patch_diff": "// f0 *= (f1 / (f1 + fx);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new Math Math(f1 * (f1 + fx);",
                "patch_diff": "throw new Math Math(f1 * (f1 + fx);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x == x1) { throw new ConvergenceException(); }"
    },
    "Closure-145": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "patch_diff": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "patch_diff": "if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] EASTER = n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "patch_diff": "private static final /*day*/int[] EASTER = n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// else if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "patch_diff": "// else if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] EASTER = n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "patch_diff": "private static final /*day*/int[] EASTER = n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "patch_diff": "return n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] EASTER = (n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "patch_diff": "private static final /*day*/int[] EASTER = (n.getType() == Token.FUNCTION || n.getType() == Token.DO;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = (n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "patch_diff": "private static final /*day*/int[] EASTER = (n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.FOR) {",
                "patch_diff": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.FOR) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "patch_diff": "} else if (n.getType() == Token.FUNCTION || n.getType() == Token.FOR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.LABEL) { Node labeledStatement = n.getLastChild(); if (labeledStatement.getType() != Token.BLOCK) { return isOneExactlyFunctionOrDo(labeledStatement); } else { // For labels with block children, we need to ensure that a // labeled FUNCTION or DO isn't generated when extraneous BLOCKs // are skipped. if (getNonEmptyChildCount(n, 2) == 1) { return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n)); } else { // Either a empty statement or an block with more than one child, // way it isn't a FUNCTION or DO. return false; } } } else { return (n.getType() == Token.FUNCTION || n.getType() == Token.DO); }"
    },
    "Closure-36": {
        "fixes": [
            {
                "k": 1,
                "patch": "// canMoveAggressively(initialization, reference);",
                "patch_diff": "// canMoveAggressively(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // canMoveAggressively(initialization, reference);",
                "patch_diff": "// // canMoveAggressively(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return canMoveAggressively(value) || canMoveModerately(initialization, reference);",
                "patch_diff": "return canMoveAggressively(value) || canMoveModerately(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_MEMBERS;",
                "patch_diff": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_MEMBERS;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return canMoveAggressively(value) && canMoveModerately(initialization, reference);",
                "patch_diff": "return canMoveAggressively(value) && canMoveModerately(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_MEMBER_DEPRECATED;",
                "patch_diff": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_MEMBER_DEPRECATED;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// canMoveAggressively(value) && canMoveAggressively(initialization, reference);",
                "patch_diff": "// canMoveAggressively(value) && canMoveAggressively(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return canMoveAggressively(initialization, reference);",
                "patch_diff": "return canMoveAggressively(initialization, reference);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return canMoveAggressively(value) || canMoveModerately_PROTOTYPE_MEMBERS;",
                "patch_diff": "return canMoveAggressively(value) || canMoveModerately_PROTOTYPE_MEMBERS;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_INTERFACES;",
                "patch_diff": "return canMoveAggressively(value) && canMoveModerately_PROTOTYPE_INTERFACES;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (convention.getSingletonGetterClassName(callNode) != null) { return false; }"
    },
    "Chart-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (entities!= null && hotspot!= null) {",
                "patch_diff": "if (entities!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return this.labelToolTip, this.labelToolTip, this.labelURL);",
                "patch_diff": "return this.labelToolTip, this.labelToolTip, this.labelURL);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this.labelToolTip, this.labelURL;",
                "patch_diff": "return this.labelToolTip, this.labelURL;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL);",
                "patch_diff": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return this.labelToolTip, this.labelToolTip, this.labelURL;",
                "patch_diff": "return this.labelToolTip, this.labelToolTip, this.labelURL;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (this.labelToolTip!= null && hotspot!= null) {",
                "patch_diff": "if (this.labelToolTip!= null && hotspot!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL));",
                "patch_diff": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this.labelToolTip, this.labelToolTip, this.labelURL));",
                "patch_diff": "return this.labelToolTip, this.labelToolTip, this.labelURL));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL;",
                "patch_diff": "return this.labelToolTip, this.labelURL, this.labelToolTip, this.labelURL;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return this.labelURL, hotspot, this.labelToolTip, this.labelURL);",
                "patch_diff": "return this.labelURL, hotspot, this.labelToolTip, this.labelURL);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (owner != null) { EntityCollection entities = owner.getEntityCollection(); if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } }"
    },
    "Chart-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:33.616595579 +0200\n+++ /tmp/tmpxantpqlz.java\t2022-07-12 14:43:33.644595443 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:43.456547784 +0200\n+++ /tmp/tmp1pkf_sfi.java\t2022-07-12 14:43:43.456547784 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:45.128539641 +0200\n+++ /tmp/tmp25_ncz3b.java\t2022-07-12 14:43:45.132539621 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:46.888531063 +0200\n+++ /tmp/tmpadvk7ugc.java\t2022-07-12 14:43:46.888531063 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:48.668522378 +0200\n+++ /tmp/tmp9jauuu_g.java\t2022-07-12 14:43:48.672522359 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:50.412513863 +0200\n+++ /tmp/tmpo9c5mg18.java\t2022-07-12 14:43:50.412513863 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(DEFAULT_TIME_ZONE, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:43:58.380474870 +0200\n+++ /tmp/tmptx5rmdsy.java\t2022-07-12 14:43:58.380474870 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(DEFAULT_TIME_ZONE, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:44:00.204465922 +0200\n+++ /tmp/tmpf7z09ou3.java\t2022-07-12 14:44:00.204465922 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timetime, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:44:02.028456969 +0200\n+++ /tmp/tmpv2j52_ud.java\t2022-07-12 14:44:02.028456969 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeToTimePeriod, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-8/source/org/jfree/data/time/Week.java\t2022-07-12 14:44:03.804448242 +0200\n+++ /tmp/tmpx1yplru2.java\t2022-07-12 14:44:03.808448223 +0200\n@@ -170,11 +170,11 @@\n      *\n      * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+this(timeZone, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault().getDefault());\n     }\n \n     /**\n      * Creates a time period for the week in which the specified date/time\n      * falls, calculated relative to the specified time zone.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
        "fixed_line": "this(time, zone, Locale.getDefault());"
    },
    "Closure-104": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (result == null) { // should never be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:44:05.788438488 +0200\n+++ /tmp/tmp0weuohgf.java\t2022-07-12 14:44:05.856438152 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (result == null) { // can be null if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:44:25.768339749 +0200\n+++ /tmp/tmp80yqibn6.java\t2022-07-12 14:44:25.768339749 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (result == null) { // should never be null if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:44:44.228247760 +0200\n+++ /tmp/tmp32rwjrkp.java\t2022-07-12 14:44:44.228247760 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // should never be null if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (result == null) { // block == null; return result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:45:02.684155080 +0200\n+++ /tmp/tmp7a8_jjei.java\t2022-07-12 14:45:02.684155080 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; return result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (result == null) { // block only override if the type in result; caller should never be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:45:21.412060334 +0200\n+++ /tmp/tmp6jnwwxju.java\t2022-07-12 14:45:21.412060334 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block only override if the type in result; caller should never be null!\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (result == null) { // block == null; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:45:39.935965954 +0200\n+++ /tmp/tmpyvg42i34.java\t2022-07-12 14:45:39.935965954 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (result == null) { // can be null if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:45:58.395871265 +0200\n+++ /tmp/tmpp29n_8tl.java\t2022-07-12 14:45:58.395871265 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // can be null if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (result == null) { // block == null; return result; caller should never be null; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:46:16.875775858 +0200\n+++ /tmp/tmpgkyc07hj.java\t2022-07-12 14:46:16.875775858 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block == null; return result; caller should never be null; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (result == null) { // block only override if the type in result; caller should never be null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:46:35.411679563 +0200\n+++ /tmp/tmp1clptv77.java\t2022-07-12 14:46:35.411679563 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) { // block only override if the type in result; caller should never be null)\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (result == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-104/src/com/google/javascript/rhino/jstype/UnionType.java\t2022-07-12 14:46:54.047582174 +0200\n+++ /tmp/tmp1ak833mh.java\t2022-07-12 14:46:54.047582174 +0200\n@@ -286,11 +286,11 @@\n       }\n     } else if (that.isSubtype(this)) {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+if (result == null) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n     } else {\n       return getNativeType(JSTypeNative.NO_TYPE);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (result != null) {",
        "fixed_line": "if (!result.isNoType()) {"
    },
    "Closure-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "return VariableLhsBeforeKill(n, n.getString())) {",
                "patch_diff": "return VariableLhsBeforeKill(n, n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return VariableLhsBefore(n, parent.getString())) {",
                "patch_diff": "return VariableLhsBefore(n, parent.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return VariableLhsBefore(n.getString())) {",
                "patch_diff": "return VariableLhsBefore(n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return VariableLhs;",
                "patch_diff": "return VariableLhs;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return VariableLhsBefore(n, n.getString())) {",
                "patch_diff": "return VariableLhsBefore(n, n.getString())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return VariableLhsBefore(n, parent) {",
                "patch_diff": "return VariableLhsBefore(n, parent) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return VariableLhsBeforeKill(n, parent).getParent())) {",
                "patch_diff": "return VariableLhsBeforeKill(n, parent).getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return VariableLhsBefore(n, parent).getParent())) {",
                "patch_diff": "return VariableLhsBefore(n, parent).getParent())) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return VariableLhsBeforeKill;",
                "patch_diff": "return VariableLhsBeforeKill;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (n.isLhs) {",
                "patch_diff": "} else if (n.isLhs) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Preconditions.checkState(n.getParent().getType() == Token.ASSIGN); // The expression to which the assignment is made is evaluated before // the RHS is evaluated (normal left to right evaluation) but the KILL // occurs after the RHS is evaluated. Node rhs = n.getNext(); VariableLiveness state = isVariableReadBeforeKill(rhs, variable); if (state == VariableLiveness.READ) { return state; }"
    },
    "Jsoup-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "r.advance = r.advance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:14.491474692 +0200\n+++ /tmp/tmpi7bfpob0.java\t2022-07-12 14:47:14.523474523 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "r.advance = r.advance value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:16.723462914 +0200\n+++ /tmp/tmpl78iopz0.java\t2022-07-12 14:47:16.723462914 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance value;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "r.advance = r.advanceCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:18.223454997 +0200\n+++ /tmp/tmpmudc6oy4.java\t2022-07-12 14:47:18.223454997 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceCount;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "r.advance = r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:19.971445766 +0200\n+++ /tmp/tmpj22bkpjn.java\t2022-07-12 14:47:19.971445766 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "r.advance = r.advanceIs;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:21.639436954 +0200\n+++ /tmp/tmpf_a1li4e.java\t2022-07-12 14:47:21.639436954 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceIs;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "r.advance = t;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:23.375427778 +0200\n+++ /tmp/tmpzczh49no.java\t2022-07-12 14:47:23.379427757 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = t;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "r.advance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:25.087418723 +0200\n+++ /tmp/tmpbio_hn37.java\t2022-07-12 14:47:25.091418702 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "r.advance = r.advanceInstant;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:26.535411060 +0200\n+++ /tmp/tmp6alzjbuv.java\t2022-07-12 14:47:26.535411060 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advanceInstant;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "r.advance = r.advance();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:28.239402040 +0200\n+++ /tmp/tmpcycuxtoi.java\t2022-07-12 14:47:28.239402040 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance();\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "r.advance = r.advance = r;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-24/src/main/java/org/jsoup/parser/TokeniserState.java\t2022-07-12 14:47:29.979392827 +0200\n+++ /tmp/tmp_j81rs6c.java\t2022-07-12 14:47:29.979392827 +0200\n@@ -553,11 +553,11 @@\n         void read(Tokeniser t, CharacterReader r) {\n             if (r.matchesLetter()) {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+r.advance = r.advance = r;\n                 return;\n             }\n \n             if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n                 char c = r.consume();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "r.advance();",
        "fixed_line": ""
    },
    "JacksonCore-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:47:31.879382759 +0200\n+++ /tmp/tmpcyr5qj5l.java\t2022-07-12 14:47:31.915382567 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte/allowed chars\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i <= maxCode) { // don't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:47:40.935334701 +0200\n+++ /tmp/tmp6_b8uanr.java\t2022-07-12 14:47:40.939334680 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // don't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i <= maxCode) { // yup, skip for now",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:47:49.475289270 +0200\n+++ /tmp/tmpg0yc5req.java\t2022-07-12 14:47:49.475289270 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // yup, skip for now\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 byte output",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:47:58.315242131 +0200\n+++ /tmp/tmpfdjipg5x.java\t2022-07-12 14:47:58.319242110 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 byte output\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i <= maxCode) { // identifier, skip for now",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:07.031195545 +0200\n+++ /tmp/tmpmoem1s_8.java\t2022-07-12 14:48:07.031195545 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, skip for now\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i <= maxCode) { // identifier, just needs 2 triplets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:15.623149518 +0200\n+++ /tmp/tmpkdesijpj.java\t2022-07-12 14:48:15.623149518 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, just needs 2 triplets\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i <= maxCode) { // identifier, skip for a digit after the end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:24.283103024 +0200\n+++ /tmp/tmpuunx7eds.java\t2022-07-12 14:48:24.283103024 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // identifier, skip for a digit after the end\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i <= maxCode) { // followed by other number; return",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:32.791057247 +0200\n+++ /tmp/tmp7bqoudex.java\t2022-07-12 14:48:32.791057247 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // followed by other number; return\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i <= maxCode) { // '9't really need 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:41.595009775 +0200\n+++ /tmp/tmp2qcpilti.java\t2022-07-12 14:48:41.599009754 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i <= maxCode) { // '9't really need 6\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i < maxCode) { // identifier, just needs 2 byte/allowed chars",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-25/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\t2022-07-12 14:48:50.310962680 +0200\n+++ /tmp/tmpfgfsa0r3.java\t2022-07-12 14:48:50.310962680 +0200\n@@ -1958,11 +1958,11 @@\n                     break;\n                 }\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+if (i < maxCode) { // identifier, just needs 2 byte/allowed chars\n                 if (codes[i] != 0) {\n                     break;\n                 }\n             } else if (!Character.isJavaIdentifierPart(c)) {\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (i <= maxCode) {",
        "fixed_line": "if (i < maxCode) {"
    },
    "Closure-166": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == t.isRecordType) {",
                "patch_diff": "if (type == t.isRecordType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (type == TYPE_ARRAY) {",
                "patch_diff": "} else if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this. recordType = prop.isRecordType;",
                "patch_diff": "this. recordType = prop.isRecordType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (type.isRecordType) {",
                "patch_diff": "if (type.isRecordType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if ( constraint.isRecordType) {",
                "patch_diff": "if ( constraint.isRecordType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this. record and trying to match;",
                "patch_diff": "this. record and trying to match;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (type == Token.ASSIGN) {",
                "patch_diff": "} else if (type == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == t.isRecordType()) {",
                "patch_diff": "if (type == t.isRecordType()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if ( constraint.isRecordType()) {",
                "patch_diff": "if ( constraint.isRecordType()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (constraint.isUnionType()) { for (JSType alt : constraint.toMaybeUnionType().getAlternates()) { if (alt.isRecordType()) { matchRecordTypeConstraint(alt.toObjectType()); } }"
    },
    "JacksonDatabind-106": {
        "fixes": [
            {
                "k": 1,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode;",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return node = (NumericNode) currentNumericNode;",
                "patch_diff": "return node = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return node;",
                "patch_diff": "return node;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.intValue();",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final NumericNode node = (NumericNode) node;",
                "patch_diff": "final NumericNode node = (NumericNode) node;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.intValue;",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.intValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int getIntValue = (NumericNode) currentNumericNode;",
                "patch_diff": "int getIntValue = (NumericNode) currentNumericNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return node = (NumericNode) currentNumericNode.intValue();",
                "patch_diff": "return node = (NumericNode) currentNumericNode.intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "patch_diff": "final NumericNode node = (NumericNode) currentNumericNode.longValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return node = (NumericNode) node;",
                "patch_diff": "return node = (NumericNode) node;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!node.canConvertToInt()) { reportOverflowInt(); } return node.intValue(); } @Override public long getLongValue() throws IOException { final NumericNode node = (NumericNode) currentNumericNode(); if (!node.canConvertToInt()) { reportOverflowLong(); }"
    },
    "Math-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "currentEvent.stepAcceptedParser = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:02.550896376 +0200\n+++ /tmp/tmpu57msl8y.java\t2022-07-12 14:49:02.570896268 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedParser = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:05.750879011 +0200\n+++ /tmp/tmpweerbgz5.java\t2022-07-12 14:49:05.750879011 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartX;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "currentEvent.stepAcceptedComponent(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:07.750868152 +0200\n+++ /tmp/tmptfj6015d.java\t2022-07-12 14:49:07.754868131 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedComponent(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "currentEvent.stepAcceptedT(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:09.706857526 +0200\n+++ /tmp/tmpxx0ziy0o.java\t2022-07-12 14:49:09.706857526 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedT(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "currentEvent.stepAccepted vec = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:11.810846093 +0200\n+++ /tmp/tmpz5hv27xn.java\t2022-07-12 14:49:11.810846093 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAccepted vec = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:13.866834912 +0200\n+++ /tmp/tmpvnvt76m9.java\t2022-07-12 14:49:13.866834912 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "currentEvent.stepAcceptedClassName = remainingStep;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:15.866824032 +0200\n+++ /tmp/tmpnpe0xfi0.java\t2022-07-12 14:49:15.866824032 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedClassName = remainingStep;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtPos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:17.854813213 +0200\n+++ /tmp/tmp5mm2j3i7.java\t2022-07-12 14:49:17.858813194 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtPos;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:19.902802062 +0200\n+++ /tmp/tmpksqpyxiz.java\t2022-07-12 14:49:19.902802062 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedAllUnknown, remainingStep = state.stopAtStartY;\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "currentEvent.stepAcceptedTag(x, y) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-7/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\t2022-07-12 14:49:21.926791037 +0200\n+++ /tmp/tmpylq79gho.java\t2022-07-12 14:49:21.926791037 +0200\n@@ -341,37 +341,11 @@\n                 // get state at event time\n                 interpolator.setInterpolatedTime(eventT);\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n-\n-                if (isLastStep) {\n-                    // the event asked to stop integration\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n-                    return eventT;\n-                }\n-\n-                boolean needReset = currentEvent.reset(eventT, eventY);\n-                if (needReset) {\n-                    // some event handler has triggered changes that\n-                    // invalidate the derivatives, we need to recompute them\n-                    System.arraycopy(eventY, 0, y, 0, y.length);\n-                    computeDerivatives(eventT, y, yDot);\n-                    resetOccurred = true;\n-                    for (final EventState remaining : occuringEvents) {\n-                        remaining.stepAccepted(eventT, eventY);\n-                    }\n+currentEvent.stepAcceptedTag(x, y) {\n                     return eventT;\n                 }\n \n                 // prepare handling of the remaining part of the step\n                 previousT = eventT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "currentEvent.stepAccepted(eventT, eventY); isLastStep = currentEvent.stop(); // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); } return eventT; } boolean needReset = currentEvent.reset(eventT, eventY); if (needReset) { // some event handler has triggered changes that // invalidate the derivatives, we need to recompute them System.arraycopy(eventY, 0, y, 0, y.length); computeDerivatives(eventT, y, yDot); resetOccurred = true; for (final EventState remaining : occuringEvents) { remaining.stepAccepted(eventT, eventY); }",
        "fixed_line": "for (final EventState state : eventsStates) { state.stepAccepted(eventT, eventY); isLastStep = isLastStep || state.stop(); } // handle the first part of the step, up to the event for (final StepHandler handler : stepHandlers) { handler.handleStep(interpolator, isLastStep); } if (isLastStep) { // the event asked to stop integration System.arraycopy(eventY, 0, y, 0, y.length); return eventT; } boolean needReset = false; for (final EventState state : eventsStates) { needReset = needReset || state.reset(eventT, eventY); }"
    },
    "Lang-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lhs.length == rhs.class) {",
                "patch_diff": "if (lhs.length == rhs.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < this.setEquals; i++) {",
                "patch_diff": "for (int i = 0; i < this.setEquals; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (lhs.getClass()!= rhs.getClass()) {",
                "patch_diff": "} else if (lhs.getClass()!= rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lhs.length == 0) {",
                "patch_diff": "if (lhs.length == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lhs.length!= rhs.getClass()) {",
                "patch_diff": "if (lhs.length!= rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lhs.length == 2) {",
                "patch_diff": "if (lhs.length == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (lhs.isEquals(rhs, rhs.getClass()) {",
                "patch_diff": "if (lhs.isEquals(rhs, rhs.getClass()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lhs.length == rhs.length) {",
                "patch_diff": "if (lhs.length == rhs.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (lhs.length == 0) {",
                "patch_diff": "} else if (lhs.length == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (lhs.getClass()!= this.setEquals;",
                "patch_diff": "} else if (lhs.getClass()!= this.setEquals;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lhs instanceof java.math.BigDecimal) { isEquals = (((java.math.BigDecimal)lhs).compareTo(rhs) == 0); } else { // The simple case, not an array, just test the element isEquals = lhs.equals(rhs); }"
    },
    "Cli-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:25.818769825 +0200\n+++ /tmp/tmp3gvgp9dk.java\t2022-07-12 14:49:25.854769625 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (option.hasArg() && (option.getArgName()!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:27.662759764 +0200\n+++ /tmp/tmpnfzm1xa7.java\t2022-07-12 14:49:27.662759764 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (option.hasArgName && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:29.182751470 +0200\n+++ /tmp/tmpyd5kn8jt.java\t2022-07-12 14:49:29.182751470 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArgName && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (option.hasArgName && (option.getArgName()!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:30.630743567 +0200\n+++ /tmp/tmpwcc31srb.java\t2022-07-12 14:49:30.630743567 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArgName && (option.getArgName()!= null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (option.hasArg() && (option.getArgName!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:32.194735028 +0200\n+++ /tmp/tmpojt2ev85.java\t2022-07-12 14:49:32.194735028 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (option.hasArg() && (option.getArgName()!= null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:33.650727078 +0200\n+++ /tmp/tmpbadp2guc.java\t2022-07-12 14:49:33.650727078 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null);\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (option.hasArg() && (option.getArgName()!= null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:35.166718793 +0200\n+++ /tmp/tmpc6ksgale.java\t2022-07-12 14:49:35.166718793 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName()!= null)\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (option.hasArg() && (option.getArgName!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:36.734710225 +0200\n+++ /tmp/tmpy08qqwhu.java\t2022-07-12 14:49:36.734710225 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName!= null) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (option.hasArg) && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:38.206702177 +0200\n+++ /tmp/tmpclvhcwft.java\t2022-07-12 14:49:38.234702023 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg) && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (option.hasArgName) && (option.getArgName()!= null)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-11/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:49:39.834693273 +0200\n+++ /tmp/tmp5mhuo80o.java\t2022-07-12 14:49:39.862693120 +0200\n@@ -627,11 +627,11 @@\n         {\n             buff.append(\"--\").append(option.getLongOpt());\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArgName) && (option.getArgName()!= null)) {\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }\n \n         // if the Option is not a required option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (option.hasArg() && (option.getArgName() != null))",
        "fixed_line": "if (option.hasArg() && option.hasArgName())"
    },
    "Math-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.ONEerance;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:41.714682988 +0200\n+++ /tmp/tmpin5horhk.java\t2022-07-12 14:49:41.742682835 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.ONEerance;\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final double[] scale = new double[y0.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:44.726666504 +0200\n+++ /tmp/tmp3gcr3vg0.java\t2022-07-12 14:49:44.726666504 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final double[] scale = new double[y0.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:46.738655482 +0200\n+++ /tmp/tmp0wepbqu0.java\t2022-07-12 14:49:46.738655482 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final double[] scale = new double[y0.util.Arrays.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:48.714644658 +0200\n+++ /tmp/tmprjinxic7.java\t2022-07-12 14:49:48.714644658 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.util.Arrays.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final double[] scale = new double[y0.0.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:50.814633146 +0200\n+++ /tmp/tmp9329ret8.java\t2022-07-12 14:49:50.818633126 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final double[] scale = new double[y0.0.util.Arrays. == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:52.842622028 +0200\n+++ /tmp/tmpaobh2a71.java\t2022-07-12 14:49:52.842622028 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays. == null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final double[] scale = new double[y0. specified.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:54.854610987 +0200\n+++ /tmp/tmpi35ibpot.java\t2022-07-12 14:49:54.854610987 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0. specified.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.length];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:56.806600275 +0200\n+++ /tmp/tmpzr7ts370.java\t2022-07-12 14:49:56.806600275 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.length];\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final double[] scale = new double[y0. specified.length]; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:49:58.814589250 +0200\n+++ /tmp/tmp17zqicwb.java\t2022-07-12 14:49:58.814589250 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0. specified.length]; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final double[] scale = new double[y0.0.util.Arrays.ONEerance; } else if (scaleAbsoluteTolerance!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-74/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\t2022-07-12 14:50:00.910577737 +0200\n+++ /tmp/tmprxm5pngy.java\t2022-07-12 14:50:00.910577737 +0200\n@@ -240,16 +240,11 @@\n           // first stage\n           computeDerivatives(stepStart, y, yDotK[0]);\n         }\n \n         if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n+final double[] scale = new double[y0.0.util.Arrays.ONEerance; } else if (scaleAbsoluteTolerance!= null) {\n             }\n           hNew = initializeStep(equations, forward, getOrder(), scale,\n                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);\n           firstTime = false;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final double[] scale; if (vecAbsoluteTolerance == null) { scale = new double[y0.length]; java.util.Arrays.fill(scale, scalAbsoluteTolerance); } else { scale = vecAbsoluteTolerance;",
        "fixed_line": "final double[] scale = new double[y0.length]; if (vecAbsoluteTolerance == null) { for (int i = 0; i < scale.length; ++i) { scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * Math.abs(y[i]); } } else { for (int i = 0; i < scale.length; ++i) { scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * Math.abs(y[i]); }"
    },
    "Cli-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "nextLineTabStop = charCount - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:03.162565362 +0200\n+++ /tmp/tmpo1hgidlx.java\t2022-07-12 14:50:03.194565189 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = charCount - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "nextLineTabStop = maxLine - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:05.226554015 +0200\n+++ /tmp/tmpeqzk5klg.java\t2022-07-12 14:50:05.230553996 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = maxLine - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "nextLineTabStop = width - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:06.874544952 +0200\n+++ /tmp/tmpwgmt2z__.java\t2022-07-12 14:50:06.874544952 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = width - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "nextLineTabStop = startPos - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:09.470530669 +0200\n+++ /tmp/tmpwbx6of_b.java\t2022-07-12 14:50:09.474530649 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = startPos - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "nextLineTabStop = pad + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:11.102521688 +0200\n+++ /tmp/tmphx6uk5sb.java\t2022-07-12 14:50:11.102521688 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pad + 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "nextLineTabStop = padding - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:12.714512810 +0200\n+++ /tmp/tmpmzxbw_ac.java\t2022-07-12 14:50:12.718512791 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = padding - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "nextLineTabStop = pos - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:14.466503163 +0200\n+++ /tmp/tmp7ycna6gd.java\t2022-07-12 14:50:14.466503163 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = pos - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "nextLineTabStop = maxElements - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:16.934489561 +0200\n+++ /tmp/tmpdrbdaghf.java\t2022-07-12 14:50:16.934489561 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = maxElements - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "nextLineTabStop = y - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:18.690479884 +0200\n+++ /tmp/tmp_7xf457h.java\t2022-07-12 14:50:18.690479884 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = y - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "nextLineTabStop = x - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-25/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:20.406470419 +0200\n+++ /tmp/tmprrk94k_k.java\t2022-07-12 14:50:20.406470419 +0200\n@@ -820,11 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            nextLineTabStop = width - 1;\n+nextLineTabStop = x - 1;\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "nextLineTabStop = width - 1;",
        "fixed_line": "nextLineTabStop = 1;"
    },
    "Cli-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(\"-\" + ch ch); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:22.190460579 +0200\n+++ /tmp/tmpmhh6nsc8.java\t2022-07-12 14:50:22.218460426 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(\"-\" + ch ch; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:24.014450512 +0200\n+++ /tmp/tmp9t4h56mz.java\t2022-07-12 14:50:24.014450512 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(\"-\" + chType); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:25.654441462 +0200\n+++ /tmp/tmpp7nyqnxl.java\t2022-07-12 14:50:25.654441462 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + chType); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(\"-\" + ch00, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:27.142433245 +0200\n+++ /tmp/tmpl9k710nv.java\t2022-07-12 14:50:27.142433245 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch00, }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(\"-\" + ch; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:28.622425071 +0200\n+++ /tmp/tmpflsoaq47.java\t2022-07-12 14:50:28.622425071 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(\"-\" + ch0; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:30.258416033 +0200\n+++ /tmp/tmp_2xmz24n.java\t2022-07-12 14:50:30.258416033 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch0; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(\"-\" + ch ch = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:31.798407521 +0200\n+++ /tmp/tmpi1axlzjp.java\t2022-07-12 14:50:31.802407497 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch ch = str; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(\"-\" + ch, tokens); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:33.378398785 +0200\n+++ /tmp/tmp35xilion.java\t2022-07-12 14:50:33.378398785 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch, tokens); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(\"-\" + ch = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:34.858390603 +0200\n+++ /tmp/tmpw_xf9f5w.java\t2022-07-12 14:50:34.858390603 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch = str; }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(\"-\" + ch); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-2/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 14:50:36.390382128 +0200\n+++ /tmp/tmptiztz3bi.java\t2022-07-12 14:50:36.394382104 +0200\n@@ -300,10 +300,6 @@\n             {\n                 process(token.substring(i));\n             }\n             else\n             {\n-                tokens.add(\"-\" + ch);\n-            }\n-        }\n-    }\n-}\n+tokens.add(\"-\" + ch); }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(\"-\" + ch); } } } }",
        "fixed_line": "tokens.add(token); break; } } } }"
    },
    "Lang-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]);",
                "patch_diff": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // we didn't really modify it.addRegex;",
                "patch_diff": "// // we didn't really modify it.addRegex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "currentFormatField= nextFormatField= nextStrategy;",
                "patch_diff": "currentFormatField= nextFormatField= nextStrategy;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]); }",
                "patch_diff": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "currentFormatField= nextFormatField;",
                "patch_diff": "currentFormatField= nextFormatField;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (orientation == nextFormatField= collector.toArray;",
                "patch_diff": "} else if (orientation == nextFormatField= collector.toArray;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "currentFormatField= nextFormatField= collector.addRegex;",
                "patch_diff": "currentFormatField= nextFormatField= collector.addRegex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (orientation == nextFormatField= collector.toArray) {",
                "patch_diff": "} else if (orientation == nextFormatField= collector.toArray) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]));",
                "patch_diff": "// // we didn't really modify it.addRegex(new Strategy[collector.size()]));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (orientation == nextFormatField= collector.size) {",
                "patch_diff": "} else if (orientation == nextFormatField= collector.size) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (patternMatcher.regionStart() != patternMatcher.regionEnd()) { throw new IllegalArgumentException(\"Failed to parse \\\"\"+pattern+\"\\\" ; gave up at index \"+patternMatcher.regionStart()); }"
    },
    "Cli-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:39.762363466 +0200\n+++ /tmp/tmpy_db7kvw.java\t2022-07-12 14:50:39.794363291 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int lastPos = padding + text.substring(pos).trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:41.614353214 +0200\n+++ /tmp/tmpyegja5ym.java\t2022-07-12 14:50:41.630353123 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = padding + text.substring(pos).trim();\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int lastPos = padding + text.substring(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:43.114344906 +0200\n+++ /tmp/tmp_d_h87zh.java\t2022-07-12 14:50:43.114344906 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = padding + text.substring(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int lastPos = pos + text.substring(pos).trim();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:44.626336530 +0200\n+++ /tmp/tmpcxr02mkn.java\t2022-07-12 14:50:44.626336530 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim();\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int lastPos = text + width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:46.278327374 +0200\n+++ /tmp/tmpxmk6t2yp.java\t2022-07-12 14:50:46.278327374 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = text + width;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int lastPos = pos + charno;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:47.738319279 +0200\n+++ /tmp/tmpk50361n8.java\t2022-07-12 14:50:47.738319279 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + charno;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:49.222311050 +0200\n+++ /tmp/tmppc_l5vih.java\t2022-07-12 14:50:49.222311050 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos)) {\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos).trim(pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:50.806302267 +0200\n+++ /tmp/tmpa_hidtxw.java\t2022-07-12 14:50:50.806302267 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos).trim(pos);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int lastPos = pos + padding;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:52.306293946 +0200\n+++ /tmp/tmp78ny7zw_.java\t2022-07-12 14:50:52.310293923 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + padding;\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int lastPos = pos + text.substring(pos).trim(pos - padding);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-23/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:50:53.790285710 +0200\n+++ /tmp/tmp9ugwtz3f.java\t2022-07-12 14:50:53.790285710 +0200\n@@ -819,23 +819,11 @@\n         // characters\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n-            int lastPos = pos;\n-            text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, 0);\n-\n-            if (pos == -1)\n-            {\n-                sb.append(text);\n-\n-                return sb;\n-            } else\n-            if (pos == lastPos)\n-            {\n-                throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n+int lastPos = pos + text.substring(pos).trim(pos - padding);\n             }\n \n             sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int lastPos = pos; text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } else if (pos == lastPos) { throw new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);",
        "fixed_line": "} if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { sb.append(text); return sb;"
    },
    "Closure-150": {
        "fixes": [
            {
                "k": 1,
                "patch": "attachLiteralTypes(parent.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:50:55.478276339 +0200\n+++ /tmp/tmphi1rv6dl.java\t2022-07-12 14:50:55.530276050 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "attachLiteralTypes(scope.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:50:57.502265099 +0200\n+++ /tmp/tmpkza4ivzm.java\t2022-07-12 14:50:57.506265080 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(scope.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "attachLiteralTypes( n.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:50:59.146255967 +0200\n+++ /tmp/tmpa58f4_20.java\t2022-07-12 14:50:59.150255948 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes( n.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "attachLiteralTypes(parent.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:00.722247212 +0200\n+++ /tmp/tmpi7xajzi9.java\t2022-07-12 14:51:00.722247212 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "attachLiteralTypes(parent, n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:02.262238654 +0200\n+++ /tmp/tmp8tt2mr3n.java\t2022-07-12 14:51:02.262238654 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "attachLiteralTypes( n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:03.786230181 +0200\n+++ /tmp/tmpq9tp661e.java\t2022-07-12 14:51:03.790230156 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes( n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "attachLiteralTypes(scope.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:05.374221350 +0200\n+++ /tmp/tmpfdy4k0zy.java\t2022-07-12 14:51:05.374221350 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(scope.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "attachLiteralTypes(parent, n.getType = Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:07.010212250 +0200\n+++ /tmp/tmpzmhhbzqd.java\t2022-07-12 14:51:07.014212226 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType = Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "attachLiteralTypes(parent, n.getType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:08.646203148 +0200\n+++ /tmp/tmpf1ezzowd.java\t2022-07-12 14:51:08.646203148 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(parent, n.getType()) {\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "attachLiteralTypes(n.getType() == Token.FUNCTION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-150/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 14:51:10.222194376 +0200\n+++ /tmp/tmp05cfkh47.java\t2022-07-12 14:51:10.222194376 +0200\n@@ -1446,25 +1446,11 @@\n       if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n         handleFunctionInputs(parent);\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+attachLiteralTypes(n.getType() == Token.FUNCTION;\n     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; }",
        "fixed_line": "super.visit(t, n, parent);"
    },
    "Closure-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:51:12.250183085 +0200\n+++ /tmp/tmpno_b1nd2.java\t2022-07-12 14:51:12.338182592 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "boolean isOverride = t.inGlobalScope() && parentType == getprop;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:51:48.297981736 +0200\n+++ /tmp/tmpxtnd0qal.java\t2022-07-12 14:51:48.297981736 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && parentType == getprop;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:51:50.769967883 +0200\n+++ /tmp/tmpm9rqko87.java\t2022-07-12 14:51:50.769967883 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "boolean isOverride = t.inGlobalScope() && elseAssign;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:52:23.381784636 +0200\n+++ /tmp/tmp3_gg1kd9.java\t2022-07-12 14:52:23.385784614 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && elseAssign;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:52:25.917770347 +0200\n+++ /tmp/tmpjgf90zhu.java\t2022-07-12 14:52:25.917770347 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property-inGlobalScope;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:52:58.433586673 +0200\n+++ /tmp/tmp6upwh47v.java\t2022-07-12 14:52:58.433586673 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "boolean isOverride = t.inGlobalScope() &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:53:31.277400298 +0200\n+++ /tmp/tmp9guqpzm0.java\t2022-07-12 14:53:31.277400298 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() &&\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:54:04.153212937 +0200\n+++ /tmp/tmpo90brsmj.java\t2022-07-12 14:54:04.153212937 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "boolean isOverride = t.inGlobalScope() && parentType == getprop; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:54:36.781026245 +0200\n+++ /tmp/tmp2xkzn6qp.java\t2022-07-12 14:54:36.781026245 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && parentType == getprop; // Make sure that we're not handling object literals being // assigned to a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-71/src/com/google/javascript/jscomp/CheckAccessControls.java\t2022-07-12 14:54:39.353011498 +0200\n+++ /tmp/tmpktny66i6.java\t2022-07-12 14:54:39.353011498 +0200\n@@ -411,11 +411,11 @@\n     String propertyName = getprop.getLastChild().getString();\n \n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+boolean isOverride = t.inGlobalScope() && // Make sure that we're not handling object literals being // assigned to check whether a prototype, as per RFC 46 property name;\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n \n       // Find the lowest property defined on a class with visibility\n       // information.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "boolean isOverride = t.inGlobalScope() &&",
        "fixed_line": "boolean isOverride = parent.getJSDocInfo() != null &&"
    },
    "Cli-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:12.124823230 +0200\n+++ /tmp/tmpu8ddne71.java\t2022-07-12 14:55:12.156823046 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:14.088811926 +0200\n+++ /tmp/tmp7pr9yi7w.java\t2022-07-12 14:55:14.092811903 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:17.156794262 +0200\n+++ /tmp/tmpy68w1s60.java\t2022-07-12 14:55:17.156794262 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop;\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos = findWrapOffset(text, width, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:18.644785695 +0200\n+++ /tmp/tmphtzinfq7.java\t2022-07-12 14:55:18.644785695 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapOffset(text, width, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos = findWrapPos(text, padding, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:20.196776755 +0200\n+++ /tmp/tmpc7eiuh0o.java\t2022-07-12 14:55:20.196776755 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, padding, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop = padding);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:21.912766870 +0200\n+++ /tmp/tmpzqn1g2i1.java\t2022-07-12 14:55:21.912766870 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop = padding);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos = findWrapOffset(text, width, nextLineTabStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:23.568757329 +0200\n+++ /tmp/tmpsq3qhxdu.java\t2022-07-12 14:55:23.572757306 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapOffset(text, width, nextLineTabStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos = findWrapPos(text, width, nextLineTabStop)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:25.296747372 +0200\n+++ /tmp/tmpb9w9rtv8.java\t2022-07-12 14:55:25.300747349 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStop)) {\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos = findWrapPos(text, width, nextLineTabStopStop);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:26.756738958 +0200\n+++ /tmp/tmpy0rmijij.java\t2022-07-12 14:55:26.756738958 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, width, nextLineTabStopStop);\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos = findWrapPos(text, padding, nextLineTabStop));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-8/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:55:28.352729758 +0200\n+++ /tmp/tmpwj9gv1g8.java\t2022-07-12 14:55:28.352729758 +0200\n@@ -807,11 +807,11 @@\n         final String padding = createPadding(nextLineTabStop);\n \n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+pos = findWrapPos(text, padding, nextLineTabStop));\n \n             if (pos == -1)\n             {\n                 sb.append(text);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "pos = findWrapPos(text, width, nextLineTabStop);",
        "fixed_line": "pos = findWrapPos(text, width, 0);"
    },
    "Closure-132": {
        "fixes": [
            {
                "k": 1,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:30.676716360 +0200\n+++ /tmp/tmp543e862j.java\t2022-07-12 14:55:30.760715875 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:35.432688929 +0200\n+++ /tmp/tmpd18y0d1j.java\t2022-07-12 14:55:35.432688929 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:38.760669729 +0200\n+++ /tmp/tmpt9ykrpyt.java\t2022-07-12 14:55:38.764669703 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:42.108650404 +0200\n+++ /tmp/tmpfok8lxv7.java\t2022-07-12 14:55:42.108650404 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!mayEffectMutableState = thenOp.removeChild;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:45.420631281 +0200\n+++ /tmp/tmp7yev1d0p.java\t2022-07-12 14:55:45.424631259 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = thenOp.removeChild;\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:49.108609980 +0200\n+++ /tmp/tmp6yjkqmvt.java\t2022-07-12 14:55:49.108609980 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:52.536590174 +0200\n+++ /tmp/tmp2nuyujmg.java\t2022-07-12 14:55:52.536590174 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don'",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:55.932570546 +0200\n+++ /tmp/tmpzvw8meln.java\t2022-07-12 14:55:55.932570546 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don'\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:55:59.324550935 +0200\n+++ /tmp/tmpcj798q3a.java\t2022-07-12 14:55:59.324550935 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-132/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 14:56:02.648531710 +0200\n+++ /tmp/tmpnq7xhklk.java\t2022-07-12 14:56:02.652531688 +0200\n@@ -777,11 +777,11 @@\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n               // if LHS has side effects, don't proceed [since the optimization\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+!mayEffectMutableState = has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are immutable, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there has side effects, don't proceed [since the optimization // evaluates LHS before cond] // NOTE - there are some circumstances where we can\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n             Node elseExpr = elseOp.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "!mayEffectMutableState(lhs)) {",
        "fixed_line": "!mayEffectMutableState(lhs) && (!mayHaveSideEffects(cond) || (thenOp.isAssign() && thenOp.getFirstChild().isName()))) {"
    },
    "Time-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (hoursOffset < 1 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:06.172511324 +0200\n+++ /tmp/tmph4se9n6j.java\t2022-07-12 14:56:06.220511046 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 1 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (minutesOffset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:09.140494147 +0200\n+++ /tmp/tmprt50xet3.java\t2022-07-12 14:56:09.140494147 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (minutesOffset < 4 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:11.732479144 +0200\n+++ /tmp/tmpnii3dmyp.java\t2022-07-12 14:56:11.736479121 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 4 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (hoursOffset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:14.280464391 +0200\n+++ /tmp/tmp26z5d8ym.java\t2022-07-12 14:56:14.280464391 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (offset < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:16.880449334 +0200\n+++ /tmp/tmpmbbpy0wb.java\t2022-07-12 14:56:16.884449311 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (offset < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (minutesOffset < 5 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:19.496434180 +0200\n+++ /tmp/tmpbtnnotq9.java\t2022-07-12 14:56:19.496434180 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 5 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (minutesOffset < 1 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:22.044419416 +0200\n+++ /tmp/tmp5pscr6sr.java\t2022-07-12 14:56:22.044419416 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (minutesOffset < 1 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (hoursOffset < 2 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:24.608404557 +0200\n+++ /tmp/tmpfia5xc6v.java\t2022-07-12 14:56:24.612404534 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 2 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (millis < 0 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:27.160389763 +0200\n+++ /tmp/tmpc_us8ybj.java\t2022-07-12 14:56:27.160389763 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (millis < 0 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (hoursOffset < 5 || minutesOffset > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-8/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 14:56:29.716374943 +0200\n+++ /tmp/tmpn63c4zrh.java\t2022-07-12 14:56:29.716374943 +0200\n@@ -274,18 +274,11 @@\n             return DateTimeZone.UTC;\n         }\n         if (hoursOffset < -23 || hoursOffset > 23) {\n             throw new IllegalArgumentException(\"Hours out of range: \" + hoursOffset);\n         }\n-        if (minutesOffset < 0 || minutesOffset > 59) {\n-            throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n-        }\n-        int offset = 0;\n-        try {\n-            int hoursInMinutes = hoursOffset * 60;\n-            if (hoursInMinutes < 0) {\n-                minutesOffset = hoursInMinutes - minutesOffset;\n+if (hoursOffset < 5 || minutesOffset > 59) {\n             } else {\n                 minutesOffset = hoursInMinutes + minutesOffset;\n             }\n             offset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n         } catch (ArithmeticException ex) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (minutesOffset < 0 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - minutesOffset;",
        "fixed_line": "if (minutesOffset < -59 || minutesOffset > 59) { throw new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset); } if (hoursOffset > 0 && minutesOffset < 0) { throw new IllegalArgumentException(\"Positive hours must not have negative minutes: \" + minutesOffset); } int offset = 0; try { int hoursInMinutes = hoursOffset * 60; if (hoursInMinutes < 0) { minutesOffset = hoursInMinutes - Math.abs(minutesOffset);"
    },
    "JacksonDatabind-84": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+_referencedType; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JavaType sb = new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "JavaType sb = new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _referencedType+\", new = \"+ref; }",
                "patch_diff": "return _referencedType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _referencedType;",
                "patch_diff": "return _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = _referencedType;",
                "patch_diff": "private static final /*day*/int[] EASTER = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref.referencedType; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref.referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref;",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "Jsoup-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return this!= o.u;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:34.104349492 +0200\n+++ /tmp/tmpekz34d26.java\t2022-07-12 14:56:34.128349352 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.u;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return this!= o.optionalClosing;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:36.476335730 +0200\n+++ /tmp/tmp0re7qaip.java\t2022-07-12 14:56:36.480335707 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.optionalClosing;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this.o == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:38.216325634 +0200\n+++ /tmp/tmp48kojzai.java\t2022-07-12 14:56:38.216325634 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this.o == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return this == o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:39.984315372 +0200\n+++ /tmp/tmp6y497uym.java\t2022-07-12 14:56:39.988315349 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return this!= o.i;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:44.264290525 +0200\n+++ /tmp/tmpbgakkjec.java\t2022-07-12 14:56:44.268290502 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.i;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this!= o.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:45.904281002 +0200\n+++ /tmp/tmps9_cwiqv.java\t2022-07-12 14:56:45.904281002 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.length;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this == o.i;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:47.628270990 +0200\n+++ /tmp/tmp9m1tx24f.java\t2022-07-12 14:56:47.628270990 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this == o.i;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this!= o.value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:49.316261185 +0200\n+++ /tmp/tmp5uldlbnh.java\t2022-07-12 14:56:49.316261185 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o.value;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this!= o. < o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:51.032251217 +0200\n+++ /tmp/tmp39a75aht.java\t2022-07-12 14:56:51.032251217 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o. < o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return this!= o;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-41/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 14:56:52.500242686 +0200\n+++ /tmp/tmpbgv09nx5.java\t2022-07-12 14:56:52.500242686 +0200\n@@ -1170,11 +1170,11 @@\n         if (o == null || getClass() != o.getClass()) return false;\n         if (!super.equals(o)) return false;\n \n         Element element = (Element) o;\n \n-        return this == o;\n+return this!= o;\n     }\n \n     @Override\n     public int hashCode() {\n         int result = super.hashCode();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "return this == o;",
        "fixed_line": "return tag.equals(element.tag);"
    },
    "Cli-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalStateException(\"Total width is less than the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:56:56.032222161 +0200\n+++ /tmp/tmpivitu2cx.java\t2022-07-12 14:56:56.060221998 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:56:59.004204885 +0200\n+++ /tmp/tmpq361poh4.java\t2022-07-12 14:56:59.008204862 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalStateException(\"Total width is less than the source of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:01.444190697 +0200\n+++ /tmp/tmpi7gehrox.java\t2022-07-12 14:57:01.444190697 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the source of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Total width is less than the end of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:03.888176484 +0200\n+++ /tmp/tmp6yx0ot0t.java\t2022-07-12 14:57:03.888176484 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the end of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new IllegalStateException( \"Total width is less than the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:06.236162827 +0200\n+++ /tmp/tmpdt2w9qs3.java\t2022-07-12 14:57:06.240162805 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException( \"Total width is less than the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalStateException( \"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:08.668148677 +0200\n+++ /tmp/tmpigb7t7ls.java\t2022-07-12 14:57:08.668148677 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException( \"Total width is less than the width of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalStateException(\"Total width is less than the size of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:11.056134783 +0200\n+++ /tmp/tmpasc8um7i.java\t2022-07-12 14:57:11.060134757 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the size of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalStateException(\"Total width is less than the startPos of the argument and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:13.460120790 +0200\n+++ /tmp/tmpaljwrqok.java\t2022-07-12 14:57:13.460120790 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the startPos of the argument and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalStateException(\"Total width is less than the EOF and indent \" + \"- no room for the description\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:15.840106936 +0200\n+++ /tmp/tmp3crbdid6.java\t2022-07-12 14:57:15.840106936 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the EOF and indent \" + \"- no room for the description\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalStateException(\"Total width is less than the argument.\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-24/src/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 14:57:18.240092962 +0200\n+++ /tmp/tmp4usj84c6.java\t2022-07-12 14:57:18.240092962 +0200\n@@ -820,12 +820,11 @@\n         sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n \n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+throw new IllegalStateException(\"Total width is less than the argument.\");\n         }\n \n         // all following lines must be padded with nextLineTabStop space \n         // characters\n         final String padding = createPadding(nextLineTabStop);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\");",
        "fixed_line": "nextLineTabStop = width - 1;"
    },
    "Math-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "return MIN_ langized_CHAR_STROKE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:20.804078028 +0200\n+++ /tmp/tmp3egim_3u.java\t2022-07-12 14:57:20.840077819 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return MIN_CHAR_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:24.024059271 +0200\n+++ /tmp/tmpagjez8ve.java\t2022-07-12 14:57:24.024059271 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_CHAR_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return MIN_ langized_CHAR_TO_END;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:26.344045756 +0200\n+++ /tmp/tmpt4gwqvbn.java\t2022-07-12 14:57:26.344045756 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_TO_END;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return MIN_ langized_CHAR_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:28.344034099 +0200\n+++ /tmp/tmp63w8vu5j.java\t2022-07-12 14:57:28.344034099 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return x;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:30.376022257 +0200\n+++ /tmp/tmpy6uweo69.java\t2022-07-12 14:57:30.376022257 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return x;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return w;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:32.592009340 +0200\n+++ /tmp/tmpenw8u4la.java\t2022-07-12 14:57:32.592009340 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return w;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return MIN_ langized_CHAR_STROKE_TO_END;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:34.839996233 +0200\n+++ /tmp/tmpd0b01nln.java\t2022-07-12 14:57:34.839996233 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE_TO_END;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return x; double x.serized",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:36.939983986 +0200\n+++ /tmp/tmph5ttt_01.java\t2022-07-12 14:57:36.939983986 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return x; double x.serized\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return MIN_ langized_CHAR_STROKE_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:38.967972158 +0200\n+++ /tmp/tmpyehm2nem.java\t2022-07-12 14:57:38.967972158 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MIN_ langized_CHAR_STROKE_OBJECT_ARRAY;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return MAX_ langized_CHAR_STROKE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-20/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\t2022-07-12 14:57:41.035960095 +0200\n+++ /tmp/tmp6trd51uu.java\t2022-07-12 14:57:41.035960095 +0200\n@@ -916,11 +916,11 @@\n         /**\n          * @param x Normalized objective variables.\n          * @return the original objective variables, possibly repaired.\n          */\n         public double[] repairAndDecode(final double[] x) {\n-            return\n+return MAX_ langized_CHAR_STROKE;\n                 decode(x);\n         }\n \n         /**\n          * @param x Normalized objective variables.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return",
        "fixed_line": "return boundaries != null && isRepairMode ? decode(repair(x)) :"
    },
    "JacksonCore-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (_hasSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:43.247947188 +0200\n+++ /tmp/tmpmdwtix82.java\t2022-07-12 14:57:43.275947026 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_currentSegment.length) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:48.735915161 +0200\n+++ /tmp/tmp0ey7j9p0.java\t2022-07-12 14:57:48.735915161 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_typeSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:50.347905750 +0200\n+++ /tmp/tmph4tfn4mi.java\t2022-07-12 14:57:50.347905750 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_typeSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_hasSegments) return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:51.983896199 +0200\n+++ /tmp/tmp2p33nlvi.java\t2022-07-12 14:57:51.983896199 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return 0;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (_lastSegments) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:53.619886648 +0200\n+++ /tmp/tmpsqmxnpz6.java\t2022-07-12 14:57:53.619886648 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_lastSegments) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_currentSegment.length) return _currentSegment.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:55.263877046 +0200\n+++ /tmp/tmpq4ea5vbe.java\t2022-07-12 14:57:55.263877046 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSegment.length;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_currentSegment) return _currentSegment;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:56.971867070 +0200\n+++ /tmp/tmpcbs3jk2w.java\t2022-07-12 14:57:56.975867047 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment) return _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_hasSegments) return _currentSegment.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:57:58.563857773 +0200\n+++ /tmp/tmpx8nj8ewv.java\t2022-07-12 14:57:58.567857747 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_hasSegments) return _currentSegment.length;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_currentSegment.length) return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:58:00.223848075 +0200\n+++ /tmp/tmplq6cm23l.java\t2022-07-12 14:58:00.223848075 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return 0;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_currentSegment.length) return _currentSize;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-8/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\t2022-07-12 14:58:01.803838842 +0200\n+++ /tmp/tmp7a0v4i_3.java\t2022-07-12 14:58:01.803838842 +0200\n@@ -302,11 +302,11 @@\n         if (_resultArray != null)  return _resultArray;\n         if (_resultString != null) {\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+if (_currentSegment.length) return _currentSize;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }\n \n     /*\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!_hasSegments) return _currentSegment;",
        "fixed_line": "if (!_hasSegments && _currentSegment != null) return _currentSegment;"
    },
    "JacksonDatabind-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (p.getCurrentToken()!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:58:03.631828160 +0200\n+++ /tmp/tmpt99qph5t.java\t2022-07-12 14:58:03.671827925 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken()!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (_currToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:58:40.087614836 +0200\n+++ /tmp/tmpdlcnoqn_.java\t2022-07-12 14:58:40.087614836 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_currToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:58:41.815604712 +0200\n+++ /tmp/tmpum7cm1zh.java\t2022-07-12 14:58:41.815604712 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (_tokens.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:15.507407055 +0200\n+++ /tmp/tmp2kzlg3zx.java\t2022-07-12 14:59:15.523406963 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (p.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:17.331396342 +0200\n+++ /tmp/tmplhp2484o.java\t2022-07-12 14:59:17.331396342 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (p.getCurrentToken!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:18.967386733 +0200\n+++ /tmp/tmp96mlu8yn.java\t2022-07-12 14:59:18.967386733 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (p.getCurrentToken() == JsonToken.START_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:20.635376935 +0200\n+++ /tmp/tmp985xqm7h.java\t2022-07-12 14:59:20.635376935 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (p.getCurrentToken() == JsonToken.START_OBJECT;\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_tokens.getCurrentToken!= JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:22.239367510 +0200\n+++ /tmp/tmpjcuqier_.java\t2022-07-12 14:59:22.239367510 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken!= JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (_tokens.getCurrentToken() == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:23.971357332 +0200\n+++ /tmp/tmpnpqial8w.java\t2022-07-12 14:59:23.971357332 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_tokens.getCurrentToken() == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_p.getCurrentToken == JsonToken.START_OBJECT) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-28/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\t2022-07-12 14:59:25.651347460 +0200\n+++ /tmp/tmpsd6cydid.java\t2022-07-12 14:59:25.651347460 +0200\n@@ -92,18 +92,11 @@\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n-            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n-                p.nextToken();\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n-            }\n-            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n-            //    if caller has advanced to the first token of Object, but for empty Object\n-            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n-                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n+if (_p.getCurrentToken == JsonToken.START_OBJECT) {\n             }\n             throw ctxt.mappingException(ObjectNode.class);\n          }\n     }\n         \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() == JsonToken.START_OBJECT) { p.nextToken(); return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.getCurrentToken() == JsonToken.FIELD_NAME) { return deserializeObject(p, ctxt, ctxt.getNodeFactory());",
        "fixed_line": "if (p.isExpectedStartObjectToken() || p.hasToken(JsonToken.FIELD_NAME)) { return deserializeObject(p, ctxt, ctxt.getNodeFactory()); } // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME), // if caller has advanced to the first token of Object, but for empty Object if (p.hasToken(JsonToken.END_OBJECT)) { return ctxt.getNodeFactory().objectNode();"
    },
    "Closure-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "return isNoType() || isNoObjectType || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:27.535336386 +0200\n+++ /tmp/tmpx_f8txjl.java\t2022-07-12 14:59:27.563336222 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return isNoType() && isNoObjectType || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:30.875316755 +0200\n+++ /tmp/tmpwqlyxkcm.java\t2022-07-12 14:59:30.875316755 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return isNoType() || isNoObjectType) && isNoToType();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:33.463301540 +0200\n+++ /tmp/tmpztpkbskt.java\t2022-07-12 14:59:33.463301540 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType) && isNoToType();\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return isNoType() || isNoObjectType() || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:35.935287003 +0200\n+++ /tmp/tmp60x5s6nq.java\t2022-07-12 14:59:35.935287003 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType() || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return isNoType && isNoObjectType || isNoType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:38.611271265 +0200\n+++ /tmp/tmpr2662f41.java\t2022-07-12 14:59:38.611271265 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType && isNoObjectType || isNoType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return isNoType() && isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:41.235255830 +0200\n+++ /tmp/tmp8g5n6a70.java\t2022-07-12 14:59:41.235255830 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() && isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return isNoType() || isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:43.675241478 +0200\n+++ /tmp/tmph2_hjuh0.java\t2022-07-12 14:59:43.675241478 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return isNoType() || isNoObjectType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:46.135227004 +0200\n+++ /tmp/tmpe_e5w0ej.java\t2022-07-12 14:59:46.139226978 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return isNoType() || isNoObjectType) && isNoToType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:48.811211253 +0200\n+++ /tmp/tmpilh7usg2.java\t2022-07-12 14:59:48.811211253 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType() || isNoObjectType) && isNoToType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return isNoType && isNoObjectType || isNo visibleType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-82/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 14:59:51.283196705 +0200\n+++ /tmp/tmpvbtv60ts.java\t2022-07-12 14:59:51.283196705 +0200\n@@ -158,11 +158,11 @@\n   public boolean isNoObjectType() {\n     return false;\n   }\n \n   public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n+return isNoType && isNoObjectType || isNo visibleType;\n   }\n \n   public boolean isNumberObjectType() {\n     return false;\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return isNoType() || isNoObjectType() || isNoResolvedType();",
        "fixed_line": "return isNoType() || isNoObjectType() || isNoResolvedType() || (registry.getNativeFunctionType( JSTypeNative.LEAST_FUNCTION_TYPE) == this);"
    },
    "Lang-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (hexDigits > 127) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 14:59:53.943181048 +0200\n+++ /tmp/tmpv5k7nsne.java\t2022-07-12 14:59:53.975180858 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 127) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (hexLen > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:08.571094893 +0200\n+++ /tmp/tmp83u0_tgv.java\t2022-07-12 15:00:08.575094872 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexLen > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (hexhex > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:10.267084899 +0200\n+++ /tmp/tmpu0nmqtik.java\t2022-07-12 15:00:10.271084876 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexhex > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (hexDigits > 31) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:11.927075117 +0200\n+++ /tmp/tmp33np_1h_.java\t2022-07-12 15:00:11.927075117 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 31) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (hexDigits > 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:25.386995763 +0200\n+++ /tmp/tmpgf3_1rtx.java\t2022-07-12 15:00:25.386995763 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (hexDigits > 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:38.750916916 +0200\n+++ /tmp/tmpshk77ppe.java\t2022-07-12 15:00:38.750916916 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 1) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (hexDigits < 16) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:00:52.494835766 +0200\n+++ /tmp/tmpx58i9187.java\t2022-07-12 15:00:52.494835766 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits < 16) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (hexLen > 16) { {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:01:05.846756877 +0200\n+++ /tmp/tmp11ccg__k.java\t2022-07-12 15:01:05.850756851 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexLen > 16) { {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (hexDigits > 18) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:01:07.426747536 +0200\n+++ /tmp/tmpecjkm56t.java\t2022-07-12 15:01:07.426747536 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexDigits > 18) {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (hexhex > 16) { {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-1/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:01:20.894667897 +0200\n+++ /tmp/tmpo4lp3ogz.java\t2022-07-12 15:01:20.894667897 +0200\n@@ -463,14 +463,11 @@\n                 break;\n             }\n         }\n         if (pfxLen > 0) { // we have a hex number\n             final int hexDigits = str.length() - pfxLen;\n-            if (hexDigits > 16) { // too many for Long\n-                return createBigInteger(str);\n-            }\n-            if (hexDigits > 8) { // too many for an int\n+if (hexhex > 16) { {\n                 return createLong(str);\n             }\n             return createInteger(str);\n         }\n         final char lastChar = str.charAt(str.length() - 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (hexDigits > 16) { // too many for Long return createBigInteger(str); } if (hexDigits > 8) { // too many for an int",
        "fixed_line": "char firstSigDigit = 0; // strip leading zeroes for(int i = pfxLen; i < str.length(); i++) { firstSigDigit = str.charAt(i); if (firstSigDigit == '0') { // count leading zeroes pfxLen++; } else { break; } } final int hexDigits = str.length() - pfxLen; if (hexDigits > 16 || (hexDigits == 16 && firstSigDigit > '7')) { // too many for Long return createBigInteger(str); } if (hexDigits > 8 || (hexDigits == 8 && firstSigDigit > '7')) { // too many for an int"
    },
    "JacksonCore-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public DefaultPrettyPrinter createInstance; { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance; { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter; }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "private DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this; }",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter; }",
                "patch_diff": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this; }",
                "patch_diff": "@Override public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this);",
                "patch_diff": "public DefaultPrettyPrinter createInstance() { return new DefaultPrettyPrinter(this);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (getClass() != DefaultPrettyPrinter.class) { // since 2.10 throw new IllegalStateException(\"Failed `createInstance()`: \"+getClass().getName() +\" does not override method; it has to\"); }"
    },
    "Closure-129": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (first.isGet(first)) {",
                "patch_diff": "if (first.isGet(first)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (first.getType() == Token.GETPROP) {",
                "patch_diff": "if (first.getType() == Token.GETPROP) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (first.isGet(first, false) {",
                "patch_diff": "if (first.isGet(first, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (first.getType()) {",
                "patch_diff": "if (first.getType()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (first.isGetProp(Node.FREE_CALL, false) {",
                "patch_diff": "if (first.isGetProp(Node.FREE_CALL, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (first.isGetProp(Node.FREE_CALL, true);",
                "patch_diff": "if (first.isGetProp(Node.FREE_CALL, true);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (first.isGet(first) {",
                "patch_diff": "if (first.isGet(first) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (first.isGetProp(t.getType() == Token.GETPROP) {",
                "patch_diff": "if (first.isGetProp(t.getType() == Token.GETPROP) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (first.isGetProp(Node.FREE_CALL) {",
                "patch_diff": "if (first.isGetProp(Node.FREE_CALL) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (first.isGetProp(Node.FREE_CALL, true;",
                "patch_diff": "if (first.isGetProp(Node.FREE_CALL, true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (first.isCast()) { first = first.getFirstChild(); }"
    },
    "Gson-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (TypeAdapter<T2>) typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:26.114637016 +0200\n+++ /tmp/tmpewsb14ks.java\t2022-07-12 15:01:26.150636806 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>) typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (TypeAdapter<T2>? typeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:31.098607527 +0200\n+++ /tmp/tmpvm6j_tl9.java\t2022-07-12 15:01:31.098607527 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (TypeAdapter<T2>? typeAdapterTypeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:32.630598460 +0200\n+++ /tmp/tmpokl2os20.java\t2022-07-12 15:01:32.654598315 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapterTypeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (TypeAdapter<T2> || typeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:34.418587877 +0200\n+++ /tmp/tmp3h3gnd_q.java\t2022-07-12 15:01:34.418587877 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> || typeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (TypeAdapter<T2>? typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:36.094577953 +0200\n+++ /tmp/tmpe714pipg.java\t2022-07-12 15:01:36.094577953 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (TypeAdapter<T2>): typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:37.670568624 +0200\n+++ /tmp/tmp_bh8c4s5.java\t2022-07-12 15:01:37.670568624 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>): typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (TypeAdapter<T2> = typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:39.378558512 +0200\n+++ /tmp/tmpch2394v7.java\t2022-07-12 15:01:39.382558489 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> = typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (TypeAdapter<T2> || typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:40.858549752 +0200\n+++ /tmp/tmp589tpli9.java\t2022-07-12 15:01:40.858549752 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2> || typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (TypeAdapter<T2>? typeAdapterTypeAdapter.T2>;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:42.434540418 +0200\n+++ /tmp/tmpgohu14bp.java\t2022-07-12 15:01:42.434540418 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>? typeAdapterTypeAdapter.T2>;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (TypeAdapter<T2>, typeAdapter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-2/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\t2022-07-12 15:01:44.026530993 +0200\n+++ /tmp/tmpwh_2zyw2.java\t2022-07-12 15:01:44.030530967 +0200\n@@ -828,11 +828,11 @@\n       public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\n         final Class<? super T2> requestedType = typeToken.getRawType();\n         if (!clazz.isAssignableFrom(requestedType)) {\n           return null;\n         }\n-        return (TypeAdapter<T2>) typeAdapter;\n+return (TypeAdapter<T2>, typeAdapter;\n \n       }\n       @Override public String toString() {\n         return \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (TypeAdapter<T2>) typeAdapter;",
        "fixed_line": "return (TypeAdapter<T2>) new TypeAdapter<T1>() { @Override public void write(JsonWriter out, T1 value) throws IOException { typeAdapter.write(out, value); } @Override public T1 read(JsonReader in) throws IOException { T1 result = typeAdapter.read(in); if (result != null && !requestedType.isInstance(result)) { throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \" + result.getClass().getName()); } return result; } };"
    },
    "Jsoup-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (attributeKey) {",
                "patch_diff": "if (attributeKey) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey; }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey(attributeKey; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasString(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasString(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasNull(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasNull(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasArray(attributeKey); }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasArray(attributeKey); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey; }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasKey; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasString(attributeKey; }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasString(attributeKey; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasNull(attributeKey; }",
                "patch_diff": "if (attributeKey) { Validate.notNull(attributeKey); return attributes.hasNull(attributeKey; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (attributeKey.toLowerCase().startsWith(\"abs:\")) { String key = attributeKey.substring(\"abs:\".length()); if (attributes.hasKey(key) && !absUrl(key).equals(\"\")) return true; }"
    },
    "Jsoup-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "return processStartTag(start.name;",
                "patch_diff": "return processStartTag(start.name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return processStartTag;",
                "patch_diff": "return processStartTag;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return processStartTag(name,",
                "patch_diff": "return processStartTag(name,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return processStartTag(",
                "patch_diff": "return processStartTag(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return processStartTag(name;",
                "patch_diff": "return processStartTag(name;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return processStartTag(start);",
                "patch_diff": "return processStartTag(start);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return processStartTag(start.name);",
                "patch_diff": "return processStartTag(start.name);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return processStartTag(start.name,",
                "patch_diff": "return processStartTag(start.name,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return processStartTag(t,",
                "patch_diff": "return processStartTag(t,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return processStartTag(start, i);",
                "patch_diff": "return processStartTag(start, i);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().name(name)); } return process(start.reset().name(name)); } public boolean processStartTag(String name, Attributes attrs) { if (currentToken == start) { // don't recycle an in-use token return process(new Token.StartTag().nameAttr(name, attrs)); } start.reset(); start.nameAttr(name, attrs); return process(start); } protected boolean processEndTag(String name) { if (currentToken == end) { // don't recycle an in-use token return process(new Token.EndTag().name(name)); }"
    },
    "Gson-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:49.138500714 +0200\n+++ /tmp/tmpaqc5e_fs.java\t2022-07-12 15:01:49.166500548 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string 0,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:51.114489009 +0200\n+++ /tmp/tmpah_4gppv.java\t2022-07-12 15:01:51.114489009 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string 0,\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:52.614480123 +0200\n+++ /tmp/tmpij4por2y.java\t2022-07-12 15:01:52.614480123 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string parent\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:54.306470101 +0200\n+++ /tmp/tmpsp6otbd9.java\t2022-07-12 15:01:54.306470101 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string parent\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:55.978460192 +0200\n+++ /tmp/tmp6urwj4gl.java\t2022-07-12 15:01:55.982460171 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:57.670450167 +0200\n+++ /tmp/tmpn_5cqhm_.java\t2022-07-12 15:01:57.670450167 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:01:59.374440068 +0200\n+++ /tmp/tmpevjd_hhm.java\t2022-07-12 15:01:59.378440047 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date (of type\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:02:01.042430183 +0200\n+++ /tmp/tmpbgnm79le.java\t2022-07-12 15:02:01.042430183 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseException(\"The date (of type\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (in.peek == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:02:02.878419304 +0200\n+++ /tmp/tmpqxto1v5z.java\t2022-07-12 15:02:02.878419304 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek == JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string 0,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-17/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java\t2022-07-12 15:02:04.622408964 +0200\n+++ /tmp/tmppvd285d8.java\t2022-07-12 15:02:04.626408943 +0200\n@@ -94,12 +94,11 @@\n     }\n   }\n \n   @Override\n   public Date read(JsonReader in) throws IOException {\n-    if (in.peek() != JsonToken.STRING) {\n-      throw new JsonParseException(\"The date should be a string value\");\n+if (in.peek!= JsonToken.STRING) { throw new JsonParseExceptionParseException(\"The date should be a string 0,\n     }\n     Date date = deserializeToDate(in.nextString());\n     if (dateType == Date.class) {\n       return date;\n     } else if (dateType == Timestamp.class) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\");",
        "fixed_line": "if (in.peek() == JsonToken.NULL) { in.nextNull(); return null;"
    },
    "JacksonCore-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:06.350398724 +0200\n+++ /tmp/tmpacfadj3j.java\t2022-07-12 15:02:06.438398202 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_INTERFACES;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_MEMBERS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:08.162387979 +0200\n+++ /tmp/tmpofwbu7kx.java\t2022-07-12 15:02:08.162387979 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_MEMBERS;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:09.746378588 +0200\n+++ /tmp/tmpkwcaxiz2.java\t2022-07-12 15:02:09.746378588 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", 1);\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:11.346369104 +0200\n+++ /tmp/tmpf7ena7ik.java\t2022-07-12 15:02:11.346369104 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_EMPTY;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", last;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:12.918359780 +0200\n+++ /tmp/tmpsf3w5w30.java\t2022-07-12 15:02:12.922359758 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", last;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:14.410350932 +0200\n+++ /tmp/tmpnslnwjw4.java\t2022-07-12 15:02:14.410350932 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", // object (tatu:\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:20.890312614 +0200\n+++ /tmp/tmp8luh840j.java\t2022-07-12 15:02:20.890312614 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", value;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", member;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:22.438310717 +0200\n+++ /tmp/tmpkdekka8h.java\t2022-07-12 15:02:22.442310713 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", member;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_NON_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:23.978309325 +0200\n+++ /tmp/tmpycgus8us.java\t2022-07-12 15:02:23.978309325 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", LEAPPROTOTYPE_NON_OBJECT;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JsonGenerationException(\"No native support for writing embedded objects\", FIX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-20/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java\t2022-07-12 15:02:25.610307825 +0200\n+++ /tmp/tmpi2wl8ykj.java\t2022-07-12 15:02:25.610307825 +0200\n@@ -1325,11 +1325,11 @@\n      *\n      * @since 2.8\n      */\n     public void writeEmbeddedObject(Object object) throws IOException {\n         // 01-Sep-2016, tatu: As per [core#318], handle small number of cases\n-        throw new JsonGenerationException(\"No native support for writing embedded objects\",\n+throw new JsonGenerationException(\"No native support for writing embedded objects\", FIX;\n                 this);\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JsonGenerationException(\"No native support for writing embedded objects\",",
        "fixed_line": "if (object == null) { writeNull(); return; } if (object instanceof byte[]) { writeBinary((byte[]) object); return; } throw new JsonGenerationException(\"No native support for writing embedded objects of type \" +object.getClass().getName(),"
    },
    "Math-75": {
        "fixes": [
            {
                "k": 1,
                "patch": "return getCumPct((Comparable<?>)v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:27.234306310 +0200\n+++ /tmp/tmpm1nixpqc.java\t2022-07-12 15:02:27.258306287 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return getCumPct((Comparable<?> v)v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:29.674303989 +0200\n+++ /tmp/tmp3v6qexv6.java\t2022-07-12 15:02:29.678303986 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v)v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return getCumPct((Comparable<?>)v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:31.858301868 +0200\n+++ /tmp/tmpkth9lynh.java\t2022-07-12 15:02:31.858301868 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>)v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return getCumPct((Comparable<?>) v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:39.674293932 +0200\n+++ /tmp/tmp8hya_bx6.java\t2022-07-12 15:02:39.674293932 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return getCumPct((Comparable<?>) v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:46.490286581 +0200\n+++ /tmp/tmp8shgo9th.java\t2022-07-12 15:02:46.490286581 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return getCumPct((Comparable<?> v) v;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:48.482284355 +0200\n+++ /tmp/tmpl5e5_3my.java\t2022-07-12 15:02:48.482284355 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) v;\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return getCumPct((Comparable<?> v) v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:50.534282028 +0200\n+++ /tmp/tmp16rjtpmt.java\t2022-07-12 15:02:50.534282028 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return getCumPct((Comparable<?> v) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:52.678279556 +0200\n+++ /tmp/tmpceu_cg2u.java\t2022-07-12 15:02:52.678279556 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v) {\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return getCumPct((Comparable<?>) v,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:54.622277286 +0200\n+++ /tmp/tmp31k0d2w9.java\t2022-07-12 15:02:54.622277286 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?>) v,\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return getCumPct((Comparable<?> v)v);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-75/src/main/java/org/apache/commons/math/stat/Frequency.java\t2022-07-12 15:02:56.778274726 +0200\n+++ /tmp/tmpswrn7m3j.java\t2022-07-12 15:02:56.782274724 +0200\n@@ -298,11 +298,11 @@\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+return getCumPct((Comparable<?> v)v);\n     }\n \n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return getCumPct((Comparable<?>) v);",
        "fixed_line": "return getPct((Comparable<?>) v);"
    },
    "Lang-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:02:59.030272016 +0200\n+++ /tmp/tmp2tjbravf.java\t2022-07-12 15:02:59.086271948 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:09.654258643 +0200\n+++ /tmp/tmpvm84gkvc.java\t2022-07-12 15:03:09.666258628 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:19.134245933 +0200\n+++ /tmp/tmpe9k3zp8s.java\t2022-07-12 15:03:19.138245924 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the E",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:28.514232640 +0200\n+++ /tmp/tmpojkci18p.java\t2022-07-12 15:03:28.514232640 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the E\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:38.026218459 +0200\n+++ /tmp/tmp15u23ne5.java\t2022-07-12 15:03:38.026218459 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after type\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return foundDigit &&!hasExp; // we need to do a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:47.694203323 +0200\n+++ /tmp/tmpjnvvi_o9.java\t2022-07-12 15:03:47.698203316 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to do a digit after the\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return foundDigit &&!allowSigns;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:03:57.334187520 +0200\n+++ /tmp/tmpv9f8cflr.java\t2022-07-12 15:03:57.338187517 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!allowSigns;\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return foundDigit &&!hasExp; // we need a digit after the foundDigit",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:04:06.938171091 +0200\n+++ /tmp/tmptg4xmhi3.java\t2022-07-12 15:04:06.942171087 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need a digit after the foundDigit\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:04:16.454154145 +0200\n+++ /tmp/tmpsuf62mho.java\t2022-07-12 15:04:16.458154138 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after type\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return foundDigit &&!hasExp; // we need to check whether a digit after the",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-24/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 15:04:25.902136677 +0200\n+++ /tmp/tmplyfek0y2.java\t2022-07-12 15:04:25.902136677 +0200\n@@ -1408,11 +1408,11 @@\n                 return foundDigit;\n             }\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+return foundDigit &&!hasExp; // we need to check whether a digit after the\n             }\n             // last character is illegal\n             return false;\n         }\n         // allowSigns is true iff the val ends in 'E'\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return foundDigit && !hasExp;",
        "fixed_line": "return foundDigit && !hasExp && !hasDecPoint;"
    },
    "Math-103": {
        "fixes": [
            {
                "k": 1,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) /",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) /",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum);",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * accum);",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * accum);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * accum))));",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / (standardDeviation * accum))));",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / n;",
                "patch_diff": "return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(x - mean) / n;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0.0d; } else if (x > (mean + 20 * standardDeviation)) { return 1.0d; } else { throw ex; } }"
    },
    "Csv-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int col = 0; col < values.length; col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < values.length; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int col = 0; col < values.length; col = 0; col < values.length; col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < values.length; col = 0; col < values.length; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int col = 0; col < values.length; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < values.length; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int col = 0; col < values.length; i++) {",
                "patch_diff": "for (int col = 0; col < values.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int col = 0; col < values.length; col = entry.getValue().intValue; col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < values.length; col = entry.getValue().intValue; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int col = 0; col < values.length; col = 0; col < values.length;",
                "patch_diff": "for (int col = 0; col < values.length; col = 0; col < values.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int col = 0; col < values.length; col = 0; col < values.length; ++i) {",
                "patch_diff": "for (int col = 0; col < values.length; col = 0; col < values.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int col = 0; col < values.length; col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col < values.length; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int col = 0; col < values.length; ++i) {",
                "patch_diff": "for (int col = 0; col < values.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int col = 0; col < values.length; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col < values.length; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (mapping == null) { return map; }"
    },
    "Jsoup-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (attr.getKey() + \":\";",
                "patch_diff": "if (attr.getKey() + \":\";",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value instanceof optionally update) {",
                "patch_diff": "if (value instanceof optionally update) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < size; ++i) {",
                "patch_diff": "for (int i = 0; i < size; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (attr.getKey()) {",
                "patch_diff": "if (attr.getKey()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value == null) {",
                "patch_diff": "if (value == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value < 0.0) {",
                "patch_diff": "if (value < 0.0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < size; ++j) {",
                "patch_diff": "for (int i = 0; i < size; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (value.getKey()) {",
                "patch_diff": "if (value.getKey()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (value instanceof optionally update) {",
                "patch_diff": "} else if (value instanceof optionally update) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < size; i++) {",
                "patch_diff": "for (int i = 0; i < size; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value.length() == 0) value = attr.getValue(); // if it could not be made abs, run as-is to allow custom unknown protocols"
    },
    "JxPath-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return ValueUtils.getLength(collection) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:40.890107680 +0200\n+++ /tmp/tmpn91zr4hs.java\t2022-07-12 15:04:40.910107638 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) - 1;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return ValueUtils.getLength(collection) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:43.666102135 +0200\n+++ /tmp/tmprlptbs5e.java\t2022-07-12 15:04:43.666102135 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) {\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return ValueUtils.getLength(lengthlength;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:45.346098756 +0200\n+++ /tmp/tmppkmqe95w.java\t2022-07-12 15:04:45.346098756 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlength;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return ValueUtils.getLength(collection);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:46.886095642 +0200\n+++ /tmp/tmp0a_elkc2.java\t2022-07-12 15:04:46.886095642 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return ValueUtils.getLength(collectioncollection);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:48.782091788 +0200\n+++ /tmp/tmp0beun8u5.java\t2022-07-12 15:04:48.782091788 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collectioncollection);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return ValueUtils.getLength(lengthlength - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:50.478088315 +0200\n+++ /tmp/tmpw81s4eyl.java\t2022-07-12 15:04:50.478088315 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlength - 1);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return ValueUtils.getLength(collection) - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:52.118084945 +0200\n+++ /tmp/tmpl7bclxai.java\t2022-07-12 15:04:52.146084886 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(collection) - 1);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return ValueUtils.getLength(value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:53.894081270 +0200\n+++ /tmp/tmpkidn3tao.java\t2022-07-12 15:04:53.894081270 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(value);\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return ValueUtils.getLength(lengthlengthBaseValue());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:04:59.666069184 +0200\n+++ /tmp/tmp60rn8tyb.java\t2022-07-12 15:04:59.666069184 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlengthBaseValue());\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return ValueUtils.getLength(lengthlengthlength;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-21/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java\t2022-07-12 15:05:01.298065727 +0200\n+++ /tmp/tmpjks4n_1u.java\t2022-07-12 15:05:01.298065727 +0200\n@@ -147,11 +147,11 @@\n      * If the property contains a collection, then the length of that\n      * collection, otherwise - 1.\n      * @return int length\n      */\n     public int getLength() {\n-        return ValueUtils.getLength(getBaseValue());\n+return ValueUtils.getLength(lengthlengthlength;\n     }\n \n     /**\n      * Returns a NodePointer that can be used to access the currently\n      * selected property value.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return ValueUtils.getLength(getBaseValue());",
        "fixed_line": "Object baseValue = getBaseValue(); return baseValue == null ? 1 : ValueUtils.getLength(baseValue);"
    },
    "Jsoup-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (cfg.values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:03.254061562 +0200\n+++ /tmp/tmp3hzoln4e.java\t2022-07-12 15:05:03.322061413 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (cfg.values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (this.values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:05.434056887 +0200\n+++ /tmp/tmp8ikckrkc.java\t2022-07-12 15:05:05.434056887 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (this.values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (values.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:06.978053559 +0200\n+++ /tmp/tmpyvbmenci.java\t2022-07-12 15:05:06.978053559 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (name.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:08.498050263 +0200\n+++ /tmp/tmpkv9hurmu.java\t2022-07-12 15:05:08.498050263 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (name.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (values.isEmpty())",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:10.014046968 +0200\n+++ /tmp/tmpykyf1tdt.java\t2022-07-12 15:05:10.014046968 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.isEmpty())\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (values.length == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:14.474037175 +0200\n+++ /tmp/tmpxu7saldi.java\t2022-07-12 15:05:14.474037175 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (values.length == 0) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (cfg.values.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:15.914033987 +0200\n+++ /tmp/tmpna7zmuqk.java\t2022-07-12 15:05:15.914033987 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (cfg.values.length) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (header.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:17.434030608 +0200\n+++ /tmp/tmp7du8jt7l.java\t2022-07-12 15:05:17.438030599 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (header.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (this.values.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:18.990027133 +0200\n+++ /tmp/tmp5t0fcdo0.java\t2022-07-12 15:05:18.990027133 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (this.values.length) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (path.isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-48/src/main/java/org/jsoup/helper/HttpConnection.java\t2022-07-12 15:05:20.578023569 +0200\n+++ /tmp/tmpmhi73e32.java\t2022-07-12 15:05:20.578023569 +0200\n@@ -768,11 +768,11 @@\n                         // name not blank, value not null\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n+if (path.isEmpty()) {\n                         header(name, values.get(0));\n                 }\n             }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!values.isEmpty())",
        "fixed_line": "if (values.size() == 1) header(name, values.get(0)); else if (values.size() > 1) { StringBuilder accum = new StringBuilder(); for (int i = 0; i < values.size(); i++) { final String val = values.get(i); if (i != 0) accum.append(\", \"); accum.append(val); } header(name, accum.toString()); }"
    },
    "JacksonDatabind-100": {
        "fixes": [
            {
                "k": 1,
                "patch": "byte[] data = node.binaryValue; if (ob == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:22.342019592 +0200\n+++ /tmp/tmpw603pmny.java\t2022-07-12 15:05:22.366019539 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "byte[] data = n.binaryValue; if (ob == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:24.698014251 +0200\n+++ /tmp/tmprq8rw1wf.java\t2022-07-12 15:05:24.702014242 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; if (ob == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "byte[] data = node.binaryValue; data!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:26.454010249 +0200\n+++ /tmp/tmpels4iocd.java\t2022-07-12 15:05:26.454010249 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; data!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "byte[] data = node.binaryValue; if (ob instanceof byte[]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:28.182006291 +0200\n+++ /tmp/tmpmer74sb5.java\t2022-07-12 15:05:28.182006291 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob instanceof byte[]) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "byte[] data = node.binaryValue; if (rhs == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:30.014002074 +0200\n+++ /tmp/tmp3qzi5ras.java\t2022-07-12 15:05:30.014002074 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (rhs == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "byte[] data = node.binaryValue; if (data == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:31.681998215 +0200\n+++ /tmp/tmp_av7dk9y.java\t2022-07-12 15:05:31.685998207 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (data == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "byte[] data = node.binaryValue; if (ob!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:33.397994230 +0200\n+++ /tmp/tmpuxaepdp1.java\t2022-07-12 15:05:33.397994230 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; if (ob!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "byte[] data = node.binaryValue; data == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:35.161990112 +0200\n+++ /tmp/tmpfl0k9ymp.java\t2022-07-12 15:05:35.161990112 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = node.binaryValue; data == null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "byte[] data = n.binaryValue; if (ob instanceof byte[]) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:36.853986144 +0200\n+++ /tmp/tmpsn9jmz9f.java\t2022-07-12 15:05:36.853986144 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; if (ob instanceof byte[]) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "byte[] data = n.binaryValue; data!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-100/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\t2022-07-12 15:05:38.597982036 +0200\n+++ /tmp/tmp2it50zlr.java\t2022-07-12 15:05:38.597982036 +0200\n@@ -358,19 +358,11 @@\n         // Multiple possibilities...\n         JsonNode n = currentNode();\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n-            }\n-            if (n.isPojo()) {\n-                Object ob = ((POJONode) n).getPojo();\n-                if (ob instanceof byte[]) {\n-                    return (byte[]) ob;\n-                }\n+byte[] data = n.binaryValue; data!= null) {\n             }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "byte[] data = n.binaryValue(); if (data != null) { return data; } if (n.isPojo()) { Object ob = ((POJONode) n).getPojo(); if (ob instanceof byte[]) { return (byte[]) ob; }",
        "fixed_line": "if (n instanceof TextNode) { return ((TextNode) n).getBinaryValue(b64variant); } return n.binaryValue();"
    },
    "Csv-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int col = 0; col < n.getValue().intValue; col = entry.getKey(), values[col]); }",
                "patch_diff": "// for (int col = 0; col < n.getValue().intValue; col = entry.getKey(), values[col]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int col = 0; col < n.getValue().intValue; col = entry.getKey(), values[col]); }",
                "patch_diff": "for (int col = 0; col < n.getValue().intValue; col = entry.getKey(), values[col]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int col = 0; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col = entry.getValue().intValue(); col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int col = 0; col < n.getValue().intValue; col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col < n.getValue().intValue; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int col = 0; col < n.getValue().intValue; col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < n.getValue().intValue; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this.entry.getValue().intValue();",
                "patch_diff": "return this.entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int col = 0; col < n; col = entry.getValue().intValue();",
                "patch_diff": "for (int col = 0; col < n; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int col = 0; col < n.getValue().intValue(); col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col < n.getValue().intValue(); col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int col = 0; col < n; col = entry.getValue().intValue();",
                "patch_diff": "// for (int col = 0; col < n; col = entry.getValue().intValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int col = 0; col < n.getValue().intValue(); col = entry.getKey(), values[col]); }",
                "patch_diff": "// for (int col = 0; col < n.getValue().intValue(); col = entry.getKey(), values[col]); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (col < values.length) { map.put(entry.getKey(), values[col]); }"
    },
    "Closure-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent!= null && parent.getType() == Token.ASSIGN) {",
                "patch_diff": "if (parent!= null && parent.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (lent!= null && parent.getType() == Token.ASSIGN) {",
                "patch_diff": "if (lent!= null && parent.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (lent!= null && rhs.getType() == Token.ASSIGN) {",
                "patch_diff": "if (lent!= null && rhs.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent!= null && rhs.getType() == Token.ASSIGN) {",
                "patch_diff": "if (parent!= null && rhs.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (lent == null && parent.getType() == Token.ASSIGN) {",
                "patch_diff": "if (lent == null && parent.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lhs.getType() == Token.ASSIGN) {",
                "patch_diff": "if (lhs.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent!= null && parent.getType() == Token.NUMBER) {",
                "patch_diff": "if (parent!= null && parent.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lent!= null && parent.getType() == Token.NUMBER) {",
                "patch_diff": "if (lent!= null && parent.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lent!= null && rhs.getType() == Token.NUMBER) {",
                "patch_diff": "if (lent!= null && rhs.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lent!= null && rhs = parent.getType() == Token.ASSIGN) {",
                "patch_diff": "if (lent!= null && rhs = parent.getType() == Token.ASSIGN) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Node gramps = parent.getParent(); if (NodeUtil.isObjectLitKey(parent, gramps)) { JSDocInfo maybeLends = gramps.getJSDocInfo(); if (maybeLends != null && maybeLends.getLendsName() != null && maybeLends.getLendsName().endsWith(\".prototype\")) { return false; } }"
    },
    "Lang-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "patch_diff": "if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "throw new NumberFormatException(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "patch_diff": "} else if (val.startsWith(\"\\\"\\\" is not a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "patch_diff": "} else if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "patch_diff": "// if (val.startsWith(\"\\\"\\\" is not a validnumber.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "patch_diff": "} else if (val.startsWith(\"\\\"\\\" is not a valid number.\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (val.startsWith(\"\\\"\\\" is not a valid as a valid number.\"); }",
                "patch_diff": "if (val.startsWith(\"\\\"\\\" is not a valid as a valid number.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (val.length() == 1 && !Character.isDigit(val.charAt(0))) { throw new NumberFormatException(val + \" is not a valid number.\"); }"
    },
    "Closure-113": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.detachFromParent!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:05:45.781964921 +0200\n+++ /tmp/tmpmtff74ye.java\t2022-07-12 15:05:45.817964836 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (parent.detachFromParent!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (removed == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:05:50.873952601 +0200\n+++ /tmp/tmpze0u1knl.java\t2022-07-12 15:05:50.877952592 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:05:54.481943778 +0200\n+++ /tmp/tmp0qb0mrb4.java\t2022-07-12 15:05:54.485943769 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (parent!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.detachFromParent == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:06:47.701804930 +0200\n+++ /tmp/tmp2rsg__9m.java\t2022-07-12 15:06:47.705804920 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (parent.detachFromParent == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:06:51.613794107 +0200\n+++ /tmp/tmpv1ocf7o6.java\t2022-07-12 15:06:51.613794107 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (c!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (removed!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:06:55.417783506 +0200\n+++ /tmp/tmp5srlwalm.java\t2022-07-12 15:06:55.417783506 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (replacement == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:06:59.057773289 +0200\n+++ /tmp/tmp62pdpqgn.java\t2022-07-12 15:06:59.057773289 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (replacement == null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (replacement!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:07:02.769762798 +0200\n+++ /tmp/tmph_zii2sq.java\t2022-07-12 15:07:02.769762798 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (replacement!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (root!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:07:06.357752591 +0200\n+++ /tmp/tmp2snjgunx.java\t2022-07-12 15:07:06.361752578 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (root!= null) {\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (removed == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-113/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 15:07:10.209741560 +0200\n+++ /tmp/tmpic9vyz5k.java\t2022-07-12 15:07:10.209741560 +0200\n@@ -324,11 +324,11 @@\n       // Requires should be removed before further processing.\n       // Some clients run closure pass multiple times, first with\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+if (removed == null) { // block only override if more specific\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }\n     }\n   }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (provided != null) {",
        "fixed_line": "if (provided != null || requiresLevel.isOn()) {"
    },
    "Jsoup-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i == lastChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:14.289729793 +0200\n+++ /tmp/tmpmdxt8xbt.java\t2022-07-12 15:07:14.325729688 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == lastChar) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i == sourceIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:16.597723097 +0200\n+++ /tmp/tmpth60r7fj.java\t2022-07-12 15:07:16.601723084 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == sourceIndex) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i == startPropertyIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:18.453717693 +0200\n+++ /tmp/tmpfgmsgm59.java\t2022-07-12 15:07:18.457717682 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == startPropertyIndex) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (last < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:20.037713068 +0200\n+++ /tmp/tmpbifdjiy_.java\t2022-07-12 15:07:20.037713068 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (last < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i <= length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:24.273700637 +0200\n+++ /tmp/tmprqbnlpu2.java\t2022-07-12 15:07:24.273700637 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i <= length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (length < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:27.421691343 +0200\n+++ /tmp/tmp_k6nuw4n.java\t2022-07-12 15:07:27.421691343 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (length < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i == length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:30.605681890 +0200\n+++ /tmp/tmp3b_gbxt4.java\t2022-07-12 15:07:30.605681890 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i > length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:33.757672485 +0200\n+++ /tmp/tmpyl6zbjgw.java\t2022-07-12 15:07:33.761672473 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i > length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (i < length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:36.857663188 +0200\n+++ /tmp/tmpozd4eb6v.java\t2022-07-12 15:07:36.861663176 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i < length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i == source.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-34/src/main/java/org/jsoup/parser/CharacterReader.java\t2022-07-12 15:07:40.013653674 +0200\n+++ /tmp/tmplzwwhra6.java\t2022-07-12 15:07:40.033653614 +0200\n@@ -86,11 +86,11 @@\n             // scan to first instance of startchar:\n             if (startChar != input[offset])\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (i == source.length) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (offset < length) {",
        "fixed_line": "if (offset < length && last <= length) {"
    },
    "Collections-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "return toKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return createRangeMap(fromKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return createRangeMap(fromKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return toKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final boolean toKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "private static final boolean toKey, fromInclusive, toKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive); }",
                "patch_diff": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return toKey, fromInclusive, toKey, toInclusive, toInclusive); }",
                "patch_diff": "return toKey, fromInclusive, toKey, toInclusive, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return createRangeMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return createRangeMap(fromKey, fromInclusive, toKey, toInclusive, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return fromInclusive, toKey, toKey, toInclusive, toKey, toInclusive); }",
                "patch_diff": "return fromInclusive, toKey, toKey, toInclusive, toKey, toInclusive); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public void clear() { Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator(); Set<K> currentKeys = keySet(); while (it.hasNext()) { if (currentKeys.contains(it.next().getKey())) { it.remove(); } } }"
    },
    "Cli-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str.substring(1, length = str.length - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:43.833642098 +0200\n+++ /tmp/tmp6ev_1g20.java\t2022-07-12 15:07:43.889641925 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str.substring(1, length = str.length - 1);\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"\\\"\", str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:45.469637112 +0200\n+++ /tmp/tmpb6szg20u.java\t2022-07-12 15:07:45.469637112 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\", str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:46.929632656 +0200\n+++ /tmp/tmpsf7w1cc8.java\t2022-07-12 15:07:46.933632646 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:48.393628180 +0200\n+++ /tmp/tmpv1hkag18.java\t2022-07-12 15:07:48.397628167 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:49.845623727 +0200\n+++ /tmp/tmpw_7rxr3i.java\t2022-07-12 15:07:49.845623727 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"\\\"\", str = str; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:51.341619130 +0200\n+++ /tmp/tmph_ucx3ln.java\t2022-07-12 15:07:51.341619130 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\", str = str; }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str.substring(1, length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:52.909614301 +0200\n+++ /tmp/tmptl44idtk.java\t2022-07-12 15:07:52.913614289 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str.substring(1, length) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"\\\"\\\"\", str = str.length()); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:54.473609471 +0200\n+++ /tmp/tmpwb2dqzsw.java\t2022-07-12 15:07:54.473609471 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\"\", str = str.length()); }\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"\\\"\\\" str = str; } else if (length > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:55.905605040 +0200\n+++ /tmp/tmpiz9mz32g.java\t2022-07-12 15:07:55.905605040 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\\\" str = str; } else if (length > 0) {\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, length = str.length - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-29/src/java/org/apache/commons/cli/Util.java\t2022-07-12 15:07:57.373600487 +0200\n+++ /tmp/tmph_tc0hb0.java\t2022-07-12 15:07:57.373600487 +0200\n@@ -60,18 +60,11 @@\n      *\n      * @return The string without the leading and trailing quotes.\n      */\n     static String stripLeadingAndTrailingQuotes(String str)\n     {\n-        if (str.startsWith(\"\\\"\"))\n-        {\n-            str = str.substring(1, str.length());\n-        }\n-        int length = str.length();\n-        if (str.endsWith(\"\\\"\"))\n-        {\n-            str = str.substring(0, length - 1);\n+if (str.startsWith(\"\\\"\")) { str = str.substring(1, length = str.length - 1);\n         }\n         \n         return str;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"\\\"\")) { str = str.substring(1, str.length()); } int length = str.length(); if (str.endsWith(\"\\\"\")) { str = str.substring(0, length - 1);",
        "fixed_line": "if (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1) { str = str.substring(1, length - 1);"
    },
    "Cli-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "Option option = new Option(opt, description);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:07:59.237594690 +0200\n+++ /tmp/tmpaf5tdg4e.java\t2022-07-12 15:07:59.313594455 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description);\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Option option = new Option(opt, description;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:02.745583742 +0200\n+++ /tmp/tmp7_bbgald.java\t2022-07-12 15:08:02.745583742 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Option option = new Option(opt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:04.305578854 +0200\n+++ /tmp/tmpl980b5a9.java\t2022-07-12 15:08:04.305578854 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Option option = new Option(opt, option;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:06.117573163 +0200\n+++ /tmp/tmpe992r4r6.java\t2022-07-12 15:08:06.117573163 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option;\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Option option = new Option(opt,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:07.777567938 +0200\n+++ /tmp/tmpgo_i60yy.java\t2022-07-12 15:08:07.777567938 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt,\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Option option = new Option(opt, option.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:09.385562861 +0200\n+++ /tmp/tmpeuke3u9x.java\t2022-07-12 15:08:09.385562861 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, option.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Option option = new Option(opt, description.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:11.033557649 +0200\n+++ /tmp/tmpu9xde2jy.java\t2022-07-12 15:08:11.033557649 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Option option = new Option(opt, description,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:12.705552346 +0200\n+++ /tmp/tmpqtguy0zp.java\t2022-07-12 15:08:12.705552346 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description,\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Option option = new Option(opt.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:14.265547387 +0200\n+++ /tmp/tmpk4rw2epc.java\t2022-07-12 15:08:14.269547375 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt.\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Option option = new Option(opt, description));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-26/src/java/org/apache/commons/cli/OptionBuilder.java\t2022-07-12 15:08:15.889542213 +0200\n+++ /tmp/tmpb3lc_3fs.java\t2022-07-12 15:08:15.889542213 +0200\n@@ -344,11 +344,11 @@\n      * a valid character.  See Option.\n      */\n     public static Option create(String opt) throws IllegalArgumentException\n     {\n             // create the option\n-        Option option = new Option(opt, description);\n+Option option = new Option(opt, description));\n \n             // set the option properties\n             option.setLongOpt(longopt);\n             option.setRequired(required);\n             option.setOptionalArg(optionalArg);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Option option = new Option(opt, description);",
        "fixed_line": "Option option = null; try { // create the option option = new Option(opt, description); // set the option properties option.setLongOpt(longopt); option.setRequired(required); option.setOptionalArg(optionalArg); option.setArgs(numberOfArgs); option.setType(type); option.setValueSeparator(valuesep); option.setArgName(argName); } finally { // reset the OptionBuilder properties OptionBuilder.reset(); }"
    },
    "JacksonDatabind-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "return id;",
                "patch_diff": "return id;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "patch_diff": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return idatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "patch_diff": "return idatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "patch_diff": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return idatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "patch_diff": "return idatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "patch_diff": "return tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return idatu: id = generator.generateId(tatu: id = generator;",
                "patch_diff": "return idatu: id = generator.generateId(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(forPojo;",
                "patch_diff": "return id = tatu:: declaredType.isAssignableFrom(tatu: id = generator.generateId(forPojo;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return tatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "patch_diff": "return tatu:: declaredType.isAssignableFrom(tatu: id = generator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return idatu: id = generator.generateId(tatu: id = generator.generateId(forPojo;",
                "patch_diff": "return idatu: id = generator.generateId(tatu: id = generator.generateId(forPojo;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (id == null) { id = generator.generateId(forPojo); }"
    },
    "Math-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.columns = columnDimension; this.columns = new OpenIntToDouble(this.columns, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.columns = new OpenIntToDouble(this.columns, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.columns = columnDimension; this.columns = new OpenIntToDouble(rowDimension, columnDimension, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.columns = new OpenIntToDouble(rowDimension, columnDimension, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.columns = columnDimension; this.columns = new OpenIntToDouble(rowDimension, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.columns = new OpenIntToDouble(rowDimension, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.columns = columnDimension; this.rows = new OpenIntToDouble(this.columns, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.rows = new OpenIntToDouble(this.columns, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.columns = columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.columns = columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension);",
                "patch_diff": "this.columns = columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.columns = rowDimension; this.columns = new OpenIntToDouble(this.columns, columnDimension);",
                "patch_diff": "this.columns = rowDimension; this.columns = new OpenIntToDouble(this.columns, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.columns = columnDimension; this.columns = new OpenIntToDouble(.0);",
                "patch_diff": "this.columns = columnDimension; this.columns = new OpenIntToDouble(.0);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.columns = new OpenIntToDouble(this.columns, columnDimension; this.rows = new OpenIntToDouble(rowDimension);",
                "patch_diff": "this.columns = new OpenIntToDouble(this.columns, columnDimension; this.rows = new OpenIntToDouble(rowDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.columns = new OpenIntToDouble(this.columns, columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension);",
                "patch_diff": "this.columns = new OpenIntToDouble(this.columns, columnDimension; this.rows = new OpenIntToDouble(rowDimension, columnDimension);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "long lRow = (long) rowDimension; long lCol = (long) columnDimension; if (lRow * lCol >= (long) Integer.MAX_VALUE) { throw new NumberIsTooLargeException(lRow * lCol, Integer.MAX_VALUE, false); }"
    },
    "JacksonDatabind-44": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new SimpleType(subclass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(subclass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new SimpleType(subclass, _superClass, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(subclass, _superClass, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new SimpleType(_class, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(_class, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new SimpleType(subclass, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(subclass, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new SimpleType(subclass, _typeHandler, _typeHandler, _asStatic);",
                "patch_diff": "return new SimpleType(subclass, _typeHandler, _typeHandler, _asStatic);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] EASTER = this.typeHandler;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.typeHandler;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new SimpleType(subclass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "return new SimpleType(subclass, _superClass, _valueHandler, _typeHandler,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] EASTER = _typeHandler;",
                "patch_diff": "private static final /*day*/int[] EASTER = _typeHandler;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_class.isAssignableFrom(subclass)) { /* throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \" +_class.getName()); */ return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } // Otherwise, stitch together the hierarchy. First, super-class Class<?> next = subclass.getSuperclass(); if (next == _class) { // straight up parent class? Great. return new SimpleType(subclass, _bindings, this, _superInterfaces, _valueHandler, _typeHandler, _asStatic); } if ((next != null) && _class.isAssignableFrom(next)) { JavaType superb = _narrow(next); return new SimpleType(subclass, _bindings, superb, null, _valueHandler, _typeHandler, _asStatic); } // if not found, try a super-interface Class<?>[] nextI = subclass.getInterfaces(); for (Class<?> iface : nextI) { if (iface == _class) { // directly implemented return new SimpleType(subclass, _bindings, null, new JavaType[] { this }, _valueHandler, _typeHandler, _asStatic); } if (_class.isAssignableFrom(iface)) { // indirect, so recurse JavaType superb = _narrow(iface); return new SimpleType(subclass, _bindings, null, new JavaType[] { superb }, _valueHandler, _typeHandler, _asStatic); } } // should not get here but... throw new IllegalArgumentException(\"Internal error: Can not resolve sub-type for Class \"+subclass.getName()+\" to \" +_class.getName());"
    },
    "Time-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "patch_diff": "throw e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text[i].set(millis, resetFields[i].set(millis, resetFields);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text[i].set(millis, resetFields[i].set(millis, resetFields);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis, resetFields);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis, resetFields);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text[i].set(millis, resetFields[i].set(millis, resetFields[i].set(millis, resetFields);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text[i].set(millis, resetFields[i].set(millis, resetFields[i].set(millis, resetFields);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis);",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (millis >= count) {",
                "patch_diff": "if (millis >= count) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (millis!= null) {",
                "patch_diff": "if (millis!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis, resetFields); }",
                "patch_diff": "e.prependMessage(\"Cannot parse \\\"\" + text + \"; i = savedFields[i].set(millis, resetFields[i].set(millis, resetFields); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (resetFields) { for (int i = 0; i < count; i++) { millis = savedFields[i].set(millis, i == (count - 1)); } }"
    },
    "JacksonDatabind-41": {
        "fixes": [
            {
                "k": 1,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:25.093512664 +0200\n+++ /tmp/tmpl5tue9jx.java\t2022-07-12 15:08:25.173512411 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return constructType(contextClass, constructType));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:27.357505342 +0200\n+++ /tmp/tmpwbcqfnen.java\t2022-07-12 15:08:27.357505342 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType));\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:28.937500217 +0200\n+++ /tmp/tmpam50jav7.java\t2022-07-12 15:08:28.937500217 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return constructType(contextClass, constructType; type!= type, contextClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:30.449495303 +0200\n+++ /tmp/tmpmwlxpm3r.java\t2022-07-12 15:08:30.449495303 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType; type!= type, contextClass;\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return constructType(contextClass, constructType; type!= type, contextClass, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:32.077490000 +0200\n+++ /tmp/tmp66beqg8b.java\t2022-07-12 15:08:32.077490000 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType; type!= type, contextClass, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:33.885484095 +0200\n+++ /tmp/tmpuokbthrx.java\t2022-07-12 15:08:33.889484083 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass) {\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:35.493478834 +0200\n+++ /tmp/tmpx3vkcm69.java\t2022-07-12 15:08:35.497478819 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass;\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return constructType(contextClass, constructType; type!= type, contextClass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:37.209473205 +0200\n+++ /tmp/tmp2trhtas0.java\t2022-07-12 15:08:37.209473205 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType; type!= type, contextClass) {\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:39.829464589 +0200\n+++ /tmp/tmpdnyggksi.java\t2022-07-12 15:08:39.829464589 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType; type, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return constructType(contextClass, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-41/src/main/java/com/fasterxml/jackson/databind/type/TypeFactory.java\t2022-07-12 15:08:42.741454977 +0200\n+++ /tmp/tmpnprwq8ao.java\t2022-07-12 15:08:43.653451957 +0200\n@@ -597,19 +597,11 @@\n     /**\n      * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n      */\n     @Deprecated\n     public JavaType constructType(Type type, Class<?> contextClass) {\n-        return constructType(type, constructType(contextClass));\n-    }\n-\n-    /**\n-     * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1)\n-     */\n-    @Deprecated\n-    public JavaType constructType(Type type, JavaType contextType) {\n-        return _fromAny(null, type, contextType.getBindings());\n+return constructType(contextClass, constructType = objType.deprecated Since 2.7(type, contextClass, _fromType);\n     }\n \n     /*\n     /**********************************************************\n     /* Direct factory methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return constructType(type, constructType(contextClass)); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { return _fromAny(null, type, contextType.getBindings());",
        "fixed_line": "TypeBindings bindings = (contextClass == null) ? TypeBindings.emptyBindings() : constructType(contextClass).getBindings(); return _fromAny(null, type, bindings); } /** * @deprecated Since 2.7 (accidentally removed in 2.7.0; added back in 2.7.1) */ @Deprecated public JavaType constructType(Type type, JavaType contextType) { TypeBindings bindings = (contextType == null) ? TypeBindings.emptyBindings() : contextType.getBindings(); return _fromAny(null, type, bindings);"
    },
    "JacksonDatabind-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "ignored = ignoredBuilderals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:08:47.397439532 +0200\n+++ /tmp/tmpi4zmfuqi.java\t2022-07-12 15:08:47.653438679 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilderals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ignored = ignoreAny.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:08:52.545422349 +0200\n+++ /tmp/tmpt8y0wnuy.java\t2022-07-12 15:08:52.545422349 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAny.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ignored = ignoreAny.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:08:55.077413858 +0200\n+++ /tmp/tmpr2t6w6jv.java\t2022-07-12 15:08:55.077413858 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAny.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ignored = ignoredBuilder.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:08:58.381402736 +0200\n+++ /tmp/tmpm2t7fdwd.java\t2022-07-12 15:08:58.381402736 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilder.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ignored = ignoredObjectals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:09:01.089393588 +0200\n+++ /tmp/tmpd0f58i4h.java\t2022-07-12 15:09:01.109393521 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredObjectals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ignored = ignorals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:09:04.065383497 +0200\n+++ /tmp/tmptrmbloz1.java\t2022-07-12 15:09:04.065383497 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignorals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ignored = ignoreAnyals.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:10:17.249124475 +0200\n+++ /tmp/tmpbk8gj1c8.java\t2022-07-12 15:10:17.253124459 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAnyals.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ignored = ignoreAnyals.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:10:19.265117056 +0200\n+++ /tmp/tmpwhcr_pdk.java\t2022-07-12 15:10:19.265117056 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoreAnyals.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ignored = ignored.getIgnored();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:10:21.141110143 +0200\n+++ /tmp/tmpewhwznxp.java\t2022-07-12 15:10:21.141110143 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignored.getIgnored();\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ignored = ignoredBuilderals.getIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-82/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\t2022-07-12 15:10:23.145102742 +0200\n+++ /tmp/tmpjojc2zgu.java\t2022-07-12 15:10:23.145102742 +0200\n@@ -490,11 +490,11 @@\n \n         if (ignorals != null) {\n             boolean ignoreAny = ignorals.getIgnoreUnknown();\n             builder.setIgnoreUnknownProperties(ignoreAny);\n             // Or explicit/implicit definitions?\n-            ignored = ignorals.getIgnored();\n+ignored = ignoredBuilderals.getIgnored;\n             for (String propName : ignored) {\n                 builder.addIgnorable(propName);\n             }\n         } else {\n             ignored = Collections.emptySet();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "ignored = ignorals.getIgnored();",
        "fixed_line": "ignored = ignorals.findIgnoredForDeserialization();"
    },
    "JacksonDatabind-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (property!= null) { return from; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:10:25.289094811 +0200\n+++ /tmp/tmpdsv_h32i.java\t2022-07-12 15:10:25.357094551 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (property!= null) { return this.property; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:10:28.021084676 +0200\n+++ /tmp/tmpznmvucac.java\t2022-07-12 15:10:28.021084676 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this.property; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (property!= null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:10:29.829077957 +0200\n+++ /tmp/tmphc9q3dnc.java\t2022-07-12 15:10:29.829077957 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (property!= null) { return from first; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:29.884848555 +0200\n+++ /tmp/tmptz94mb1u.java\t2022-07-12 15:11:29.884848555 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from first; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (property!= null) { return from from '_; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:31.520842144 +0200\n+++ /tmp/tmpwdu31sqz.java\t2022-07-12 15:11:31.520842144 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from from '_; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (property!= null) { return jp; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:33.160835710 +0200\n+++ /tmp/tmp4zbu4c0k.java\t2022-07-12 15:11:33.164835694 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return jp; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (property!= null) { return _property; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:34.904828858 +0200\n+++ /tmp/tmpxxebk341.java\t2022-07-12 15:11:34.904828858 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return _property; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (property!= null) { return from '_; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:36.684821854 +0200\n+++ /tmp/tmp_qq0s4j1.java\t2022-07-12 15:11:36.684821854 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return from '_; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (property!= null) { return null; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:11:38.520814621 +0200\n+++ /tmp/tmp1wd1tgdm.java\t2022-07-12 15:11:38.520814621 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property!= null) { return null; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (property == null) { return this; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-102/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 15:12:33.180594761 +0200\n+++ /tmp/tmpkh2e7ci8.java\t2022-07-12 15:12:33.180594761 +0200\n@@ -62,13 +62,11 @@\n     public JsonSerializer<?> createContextual(SerializerProvider serializers,\n             BeanProperty property) throws JsonMappingException\n     {\n         // Note! Should not skip if `property` null since that'd skip check\n         // for config overrides, in case of root value\n-        if (property == null) {\n-            return this;\n-        }\n+if (property == null) { return this; }\n         JsonFormat.Value format = findFormatOverrides(serializers, property, handledType());\n         if (format == null) {\n             return this;\n         }\n         // Simple case first: serialize as numeric timestamp?\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (property == null) { return this; }",
        "fixed_line": ""
    },
    "Closure-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// this is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// this is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // object is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // object is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // can have arbitrary properties on it.",
                "patch_diff": "// // can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // object is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // object is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// this is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// this is not be in the value is not be in the value is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // object is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // object is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "patch_diff": "// // is not be in the value is not be in this.prototype can have arbitrary properties on it.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (gramps.isDelProp()) { return false; }"
    },
    "Math-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "int idx = index < N; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:30.208356716 +0200\n+++ /tmp/tmpevfee3_z.java\t2022-07-12 15:13:30.252356532 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int idx = index < N; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:33.364343303 +0200\n+++ /tmp/tmp9sz2y9f8.java\t2022-07-12 15:13:33.364343303 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int idx = index < N; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:35.396334654 +0200\n+++ /tmp/tmpzcp7xdbb.java\t2022-07-12 15:13:35.396334654 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int idx = index < indices.length; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:37.400326115 +0200\n+++ /tmp/tmps_4ucu1c.java\t2022-07-12 15:13:37.400326115 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int idx = index < N; ++idx; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:39.716316233 +0200\n+++ /tmp/tmpoma108ji.java\t2022-07-12 15:13:39.716316233 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < N; ++idx; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int idx = index < indices.length; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:41.800307331 +0200\n+++ /tmp/tmpbw0ia_p9.java\t2022-07-12 15:13:41.800307331 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int idx = 0; n < indicesIndex; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:43.924298246 +0200\n+++ /tmp/tmpv95x0osu.java\t2022-07-12 15:13:43.924298246 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = 0; n < indicesIndex; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int idx = 0; n < indicesIndex; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:45.976289460 +0200\n+++ /tmp/tmp50n0n3vt.java\t2022-07-12 15:13:45.976289460 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = 0; n < indicesIndex; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int idx = index < indicesIndex; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:47.912281163 +0200\n+++ /tmp/tmpthrhvg_o.java\t2022-07-12 15:13:47.916281145 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indicesIndex; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int idx = index < indices.length; ++idx; ++idx; ++idx) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-56/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\t2022-07-12 15:13:49.920272548 +0200\n+++ /tmp/tmp2yrtkemv.java\t2022-07-12 15:13:49.920272548 +0200\n@@ -232,17 +232,11 @@\n             --idx;\n             count -= offset;\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n-        indices[last] = idx;\n+int idx = index < indices.length; ++idx; ++idx; ++idx) {\n \n         return indices;\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx;",
        "fixed_line": "indices[last] = index - count;"
    },
    "Math-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "return serosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:13:52.100263182 +0200\n+++ /tmp/tmp3jg6r077.java\t2022-07-12 15:13:52.128263059 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return200osomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:13:55.100250274 +0200\n+++ /tmp/tmpuvloufh6.java\t2022-07-12 15:13:55.100250274 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return200osomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return chromosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:13:57.192241262 +0200\n+++ /tmp/tmp63mk4qo1.java\t2022-07-12 15:13:57.192241262 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return serosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:28.224106418 +0200\n+++ /tmp/tmpvm0bww_h.java\t2022-07-12 15:14:28.224106418 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return chromosomes_DECL.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:30.360097058 +0200\n+++ /tmp/tmpwoy0rr4d.java\t2022-07-12 15:14:30.360097058 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomes_DECL.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return200osomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:32.452087880 +0200\n+++ /tmp/tmp24se84mg.java\t2022-07-12 15:14:32.456087863 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return200osomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return chromosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:34.604078432 +0200\n+++ /tmp/tmpcs8q03t0.java\t2022-07-12 15:14:34.608078414 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return chromosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return lastComparisonosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:36.680069305 +0200\n+++ /tmp/tmpp0me6_sd.java\t2022-07-12 15:14:36.680069305 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return lastComparisonosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return lastComparisonosomesosomes.iterator();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:38.808059942 +0200\n+++ /tmp/tmpm55zp4cs.java\t2022-07-12 15:14:38.808059942 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return lastComparisonosomesosomes.iterator();\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return serosomesosomes.iterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-34/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\t2022-07-12 15:14:40.940050551 +0200\n+++ /tmp/tmp2cwnas8u.java\t2022-07-12 15:14:40.940050551 +0200\n@@ -204,8 +204,8 @@\n      * <p>Any call to {@link Iterator#remove()} will result in a {@link UnsupportedOperationException}.</p>\n      *\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return serosomesosomes.iterator;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return chromosomes.iterator();",
        "fixed_line": "return getChromosomes().iterator();"
    },
    "Mockito-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:43.308040106 +0200\n+++ /tmp/tmp0us0kr5w.java\t2022-07-12 15:14:43.388039754 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAware) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:46.124027674 +0200\n+++ /tmp/tmpp5q6itmf.java\t2022-07-12 15:14:46.128027657 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAware) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode == verificationMode.getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:47.936019666 +0200\n+++ /tmp/tmpjtrtano8.java\t2022-07-12 15:14:47.940019648 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode == verificationMode.getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMockMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:49.840011243 +0200\n+++ /tmp/tmpb_wp1kqn.java\t2022-07-12 15:14:49.840011243 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMockMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:51.824002457 +0200\n+++ /tmp/tmp1onfwg2t.java\t2022-07-12 15:14:51.824002457 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:53.747993930 +0200\n+++ /tmp/tmp9f8m7sno.java\t2022-07-12 15:14:53.747993930 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock()) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:56.195983070 +0200\n+++ /tmp/tmp1fz_p9_v.java\t2022-07-12 15:14:56.195983070 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockAwareVerificationMode)) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:58.011975006 +0200\n+++ /tmp/tmpoykf0j7u.java\t2022-07-12 15:14:58.011975006 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMockMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:14:59.867966756 +0200\n+++ /tmp/tmp7i4nadj2.java\t2022-07-12 15:14:59.867966756 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode instanceofgetMock') {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode!=getMockAwareVerificationMode) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-13/src/org/mockito/internal/MockHandler.java\t2022-07-12 15:15:01.831958020 +0200\n+++ /tmp/tmptc6zxipy.java\t2022-07-12 15:15:01.831958020 +0200\n@@ -72,11 +72,11 @@\n \n         //if verificationMode is not null then someone is doing verify()        \n         if (verificationMode != null) {\n             //We need to check if verification was started on the correct mock \n             // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n+if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode!=getMockAwareVerificationMode) {\n                 VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                 verificationMode.verify(data);\n                 return null;\n                 // this means there is an invocation on a different mock. Re-adding verification mode \n                 // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {",
        "fixed_line": "if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) { VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher); verificationMode.verify(data); return null; } else { // this means there is an invocation on a different mock. Re-adding verification mode // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138) mockingProgress.verificationStarted(verificationMode);"
    },
    "Csv-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.out = out; this.format = format;",
                "patch_diff": "this.out = out; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.out = this.format; this.format = format;",
                "patch_diff": "this.out = this.format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.out = format; this.format = format;",
                "patch_diff": "this.out = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// this.out = format; this.format = format;",
                "patch_diff": "// this.out = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// this.format = format; this.format = format;",
                "patch_diff": "// this.format = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // can't really modify it's do implicit re-parse",
                "patch_diff": "// // can't really modify it's do implicit re-parse",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.out = out; this.format = format; this.format = format;",
                "patch_diff": "this.out = out; this.format = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.out = format; this.format = format; this.format = format;",
                "patch_diff": "this.out = format; this.format = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.out = this.format; this.format = format; this.format = format;",
                "patch_diff": "this.out = this.format; this.format = format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // can't really modify it was non-literal characters that.format; this.format = format;",
                "patch_diff": "// // can't really modify it was non-literal characters that.format; this.format = format;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (format.getHeader() != null) { this.printRecord((Object[]) format.getHeader()); }"
    },
    "Math-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "private RealMatrix squareRoot = new EigenDecomposition(millisecond);",
                "patch_diff": "private RealMatrix squareRoot = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new EigenDecomposition(millisecond);",
                "patch_diff": "return new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "patch_diff": "return new EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private RealMatrix squareRoot = new EigenDecomposition(m);",
                "patch_diff": "private RealMatrix squareRoot = new EigenDecomposition(m);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "patch_diff": "private static final EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private RealMatrix squareRoot(m = new EigenDecomposition(millisecond);",
                "patch_diff": "private RealMatrix squareRoot(m = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "patch_diff": "throw new EigenDecomposition dec = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new EigenDecomposition(m);",
                "patch_diff": "return new EigenDecomposition(m);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private RealMatrix squareRoot = new EigenDecomposition;",
                "patch_diff": "private RealMatrix squareRoot = new EigenDecomposition;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new EigenDecomposition(m = new EigenDecomposition(millisecond);",
                "patch_diff": "return new EigenDecomposition(m = new EigenDecomposition(millisecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (m instanceof DiagonalMatrix) { final int dim = m.getRowDimension(); final RealMatrix sqrtM = new DiagonalMatrix(dim); for (int i = 0; i < dim; i++) { sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i))); } return sqrtM; } else { final EigenDecomposition dec = new EigenDecomposition(m); return dec.getSquareRoot(); }"
    },
    "Gson-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (typeNames[stackSize - 2] = \"null\"; }",
                "patch_diff": "} else if (typeNames[stackSize - 2] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (typeNames[stackSize - 1] = \"null\"; }",
                "patch_diff": "} else if (typeNames[stackSize - 1] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (stackSize - 2] = \"null\"; }",
                "patch_diff": "} else if (stackSize - 2] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new JsonToken.NAME - 2] = \"null\"; }",
                "patch_diff": "return new JsonToken.NAME - 2] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (c == JsonToken.NAME) {",
                "patch_diff": "} else if (c == JsonToken.NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (typeNames[stackSize - 2] = \"null\";",
                "patch_diff": "} else if (typeNames[stackSize - 2] = \"null\";",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (c == JsonToken.FIELD_NAME) {",
                "patch_diff": "} else if (c == JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (typeNames[stackSize - 1] = \"null\";",
                "patch_diff": "} else if (typeNames[stackSize - 1] = \"null\";",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return JsonToken.NAME - 2] = \"null\"; }",
                "patch_diff": "return JsonToken.NAME - 2] = \"null\"; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (typeNames[stackSize - 2] = \"null\"; } else {",
                "patch_diff": "} else if (typeNames[stackSize - 2] = \"null\"; } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (stackSize > 0) { pathNames[stackSize - 1] = \"null\"; } } if (stackSize > 0) { pathIndices[stackSize - 1]++; }"
    },
    "Time-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "int defaultYear = iChronology.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:09.035925905 +0200\n+++ /tmp/tmpachouhq5.java\t2022-07-12 15:15:09.131925477 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iChronology.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int defaultYear = iChronology.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:12.671909658 +0200\n+++ /tmp/tmpmmi5q0zd.java\t2022-07-12 15:15:12.675909640 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iChronology.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int defaultYear = instantLocal - chrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:15.391897485 +0200\n+++ /tmp/tmp92ribt05.java\t2022-07-12 15:15:15.391897485 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal - chrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int defaultYear = iLocals.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:18.159885084 +0200\n+++ /tmp/tmp42gd09cv.java\t2022-07-12 15:15:18.159885084 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iLocals.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int defaultYear = instantLocal - chrono.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:21.047872128 +0200\n+++ /tmp/tmp8a5oly71.java\t2022-07-12 15:15:21.051872111 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal - chrono.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int defaultYear = iLocals.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:23.719860128 +0200\n+++ /tmp/tmp8ym8f89u.java\t2022-07-12 15:15:23.719860128 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = iLocals.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int defaultYear = ichrono.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:26.255848724 +0200\n+++ /tmp/tmp1_5hl0fp.java\t2022-07-12 15:15:26.255848724 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = ichrono.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int defaultYear = instantLocal.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:28.979836463 +0200\n+++ /tmp/tmpfrcas_1c.java\t2022-07-12 15:15:28.979836463 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = instantLocal.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int defaultYear = parser.year().get(instantLocal);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:31.651824421 +0200\n+++ /tmp/tmpxbhfds42.java\t2022-07-12 15:15:31.651824421 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = parser.year().get(instantLocal);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int defaultYear = ichrono.year().get(instantLocal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-7/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 15:15:34.443811821 +0200\n+++ /tmp/tmpv6v0y9bt.java\t2022-07-12 15:15:34.443811821 +0200\n@@ -705,11 +705,11 @@\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+int defaultYear = ichrono.year().get(instantLocal;\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int defaultYear = chrono.year().get(instantLocal);",
        "fixed_line": "int defaultYear = DateTimeUtils.getChronology(chrono).year().get(instantMillis);"
    },
    "Closure-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be valid)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:15:37.191799405 +0200\n+++ /tmp/tmpw_2yntit.java\t2022-07-12 15:15:37.231799227 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be valid)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:16:06.887664359 +0200\n+++ /tmp/tmp50pm1zk5.java\t2022-07-12 15:16:06.887664359 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "return false; // can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:16:34.739536260 +0200\n+++ /tmp/tmpbkshji5c.java\t2022-07-12 15:16:34.743536243 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be null or EMPTY\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "return false; // can't really modify it was non-literal characters that were // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:17:02.231408524 +0200\n+++ /tmp/tmptowcd8v3.java\t2022-07-12 15:17:02.231408524 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that were // need to check\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (e if it was -->",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:17:29.903278727 +0200\n+++ /tmp/tmpuscet77_.java\t2022-07-12 15:17:29.907278708 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (e if it was -->\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "return false; // can't really modify it was non-literal characters that might be null!",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:17:57.735147000 +0200\n+++ /tmp/tmpqajqtiqf.java\t2022-07-12 15:17:57.735147000 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be null!\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:18:25.883012640 +0200\n+++ /tmp/tmp_95402zg.java\t2022-07-12 15:18:25.883012640 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD -\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:18:53.798878318 +0200\n+++ /tmp/tmpm00h9t_c.java\t2022-07-12 15:18:53.798878318 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (toJsonNode)\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:19:21.370744659 +0200\n+++ /tmp/tmpuowg70h5.java\t2022-07-12 15:19:21.370744659 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be Token.REGEXPMD\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "return false; // can't really modify it was non-literal characters that might be valid (empty be // need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-86/src/com/google/javascript/jscomp/NodeUtil.java\t2022-07-12 15:19:49.274608445 +0200\n+++ /tmp/tmp_oa71ph1.java\t2022-07-12 15:19:49.274608445 +0200\n@@ -2460,11 +2460,11 @@\n             || locals.apply(value);\n       case Token.NEW:\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return false; // can't really modify it was non-literal characters that might be valid (empty be // need to check\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:\n       case Token.OBJECTLIT:\n         // Literals objects with non-literal children are allowed.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "return true;",
        "fixed_line": "return false;"
    },
    "Jsoup-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (element.equals(element)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:17.054471940 +0200\n+++ /tmp/tmpv12uqq0t.java\t2022-07-12 15:20:17.086471781 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (element.equals(element)) return element.search;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:19.294460895 +0200\n+++ /tmp/tmpc19scmml.java\t2022-07-12 15:20:19.294460895 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.search;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (element.equals(element);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:20.990452530 +0200\n+++ /tmp/tmpilypquqy.java\t2022-07-12 15:20:20.990452530 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element);\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (element.equals(element)) return element.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:22.562444771 +0200\n+++ /tmp/tmpzn5lg6wn.java\t2022-07-12 15:20:22.566444752 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.class;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (element.equals(element)) return element.get(i);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:24.462435393 +0200\n+++ /tmp/tmpoagr1j_0.java\t2022-07-12 15:20:24.462435393 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) return element.get(i);\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (element.equals(search)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:26.278426424 +0200\n+++ /tmp/tmpudtm4qtf.java\t2022-07-12 15:20:26.278426424 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (element.equals(element)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:28.010417868 +0200\n+++ /tmp/tmp3viakd93.java\t2022-07-12 15:20:28.010417868 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element)) {\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (element.equals(search)) return element.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:29.718409426 +0200\n+++ /tmp/tmpxxjh_i46.java\t2022-07-12 15:20:29.718409426 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element.class;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (element.equals(search)) return element.search;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:31.502400607 +0200\n+++ /tmp/tmpahe6yss0.java\t2022-07-12 15:20:31.502400607 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(search)) return element.search;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (element.equals(element.search)) return element;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-43/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 15:20:33.374391347 +0200\n+++ /tmp/tmpn2bwf80x.java\t2022-07-12 15:20:33.374391347 +0200\n@@ -569,11 +569,11 @@\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+if (element.equals(element.search)) return element;\n                 return i;\n         }\n         return null;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (element.equals(search))",
        "fixed_line": "if (element == search)"
    },
    "JacksonCore-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:35.418381236 +0200\n+++ /tmp/tmpwc7_x4bp.java\t2022-07-12 15:20:35.494380857 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i++) {\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:37.426371294 +0200\n+++ /tmp/tmp7ejmtdu9.java\t2022-07-12 15:20:37.426371294 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:39.034363330 +0200\n+++ /tmp/tmp26ajg4am.java\t2022-07-12 15:20:39.034363330 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i++) {\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:40.678355188 +0200\n+++ /tmp/tmpo11pg6ym.java\t2022-07-12 15:20:40.682355166 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:42.254347376 +0200\n+++ /tmp/tmp92c5jdr4.java\t2022-07-12 15:20:42.258347356 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:43.970338872 +0200\n+++ /tmp/tmp3cgynltq.java\t2022-07-12 15:20:43.970338872 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i; ++i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:45.422331669 +0200\n+++ /tmp/tmp7466klq6.java\t2022-07-12 15:20:45.422331669 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i++) {\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:47.046323613 +0200\n+++ /tmp/tmptk9ymo70.java\t2022-07-12 15:20:47.046323613 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i;i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:48.822314800 +0200\n+++ /tmp/tmpnil7i59f.java\t2022-07-12 15:20:48.822314800 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i);i; ++i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0; i < len; ++i) { char c = str.charAt(i;i);i; ++i)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-6/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:20:50.374307095 +0200\n+++ /tmp/tmpqwq05sja.java\t2022-07-12 15:20:50.378307076 +0200\n@@ -188,12 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         // [core#176]: no leading zeroes allowed\n-        for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i);\n+for (int i = 0; i < len; ++i) { char c = str.charAt(i;i);i; ++i)\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; i < len; ++i) { char c = str.charAt(i);",
        "fixed_line": "char c = str.charAt(0); if (c <= '0') { return (len == 1 && c == '0') ? 0 : -1; } if (c > '9') { return -1; } for (int i = 1; i < len; ++i) { c = str.charAt(i);"
    },
    "Time-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (nextAdjusted == nextAdjusted) { return offsetAdjusted; }",
                "patch_diff": "if (nextAdjusted == nextAdjusted) { return offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (nextLocal!= nextAdjusted) { return offsetAdjusted; }",
                "patch_diff": "if (nextLocal!= nextAdjusted) { return offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (nextAdjusted == nextAdjusted) { return offsetAdjusted; }",
                "patch_diff": "} else if (nextAdjusted == nextAdjusted) { return offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (nextAdjusted == nextAdjusted) {",
                "patch_diff": "if (nextAdjusted == nextAdjusted) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return offsetLocal - offsetAdjusted; }",
                "patch_diff": "return offsetLocal - offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nextLocal!= nextAdjusted) {",
                "patch_diff": "if (nextLocal!= nextAdjusted) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (nextAdjusted == nextAdjusted; }",
                "patch_diff": "if (nextAdjusted == nextAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (nextAdjusted == nextAdjusted) { return offsetLocal; }",
                "patch_diff": "} else if (nextAdjusted == nextAdjusted) { return offsetLocal; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (nextAdjusted == nextAdjusted) { return offsetLocal; }",
                "patch_diff": "if (nextAdjusted == nextAdjusted) { return offsetLocal; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (nextAdjusted!= nextAdjusted) { return offsetAdjusted; }",
                "patch_diff": "if (nextAdjusted!= nextAdjusted) { return offsetAdjusted; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (offsetLocal > 0) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } }"
    },
    "JacksonDatabind-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator,",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// JSError.make(t, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef);",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), beanDesc.getClassAnnotations(), mutator, propDef);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator, propDef);",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator, propDef);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// JSError.make(t, propDef.getWrapperName(), mutator,",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), mutator,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(),",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(),",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator, declaredType);",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator, declaredType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator);",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.isEnabled(propDef.getWrapperName(), propDef.getClassAnnotations(), mutator,",
                "patch_diff": "this.isEnabled(propDef.getWrapperName(), propDef.getClassAnnotations(), mutator,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// JSError.make(t, propDef.getWrapperName(), mutator, propDef.getClassAnnotations(), mutator,",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), mutator, propDef.getClassAnnotations(), mutator,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator;",
                "patch_diff": "// JSError.make(t, propDef.getWrapperName(), propDef.getClassAnnotations(), mutator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if ((mutator instanceof AnnotatedField) && \"cause\".equals(mutator.getName())) { ; } else { mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); }"
    },
    "Closure-131": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (lengthlength == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:20:55.862279835 +0200\n+++ /tmp/tmpuxs8g8zu.java\t2022-07-12 15:20:55.906279613 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (!i) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:01.190253337 +0200\n+++ /tmp/tmpanfd02g5.java\t2022-07-12 15:21:01.190253337 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (!i) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (!Character.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:04.758235579 +0200\n+++ /tmp/tmpt8_jdrnb.java\t2022-07-12 15:21:04.758235579 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (!Character.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (lengthlength == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:08.346217704 +0200\n+++ /tmp/tmpasuny1sp.java\t2022-07-12 15:21:08.350217684 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlength == 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (!i.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:11.830200340 +0200\n+++ /tmp/tmpien_u95t.java\t2022-07-12 15:21:11.830200340 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (!i.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i.isJavaIdentifierPart) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:15.490182080 +0200\n+++ /tmp/tmppb5iettn.java\t2022-07-12 15:21:15.490182080 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i.isJavaIdentifierPart) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:19.102164050 +0200\n+++ /tmp/tmp9ryd1h1r.java\t2022-07-12 15:21:19.102164050 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (i == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (lengthlengthlength == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:22.570146728 +0200\n+++ /tmp/tmplc7gpmnc.java\t2022-07-12 15:21:22.570146728 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlengthlength == 0) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (iters.length <= 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:26.214128510 +0200\n+++ /tmp/tmpacmjjy9q.java\t2022-07-12 15:21:26.214128510 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (iters.length <= 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lengthlengthlength == 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-131/src/com/google/javascript/rhino/TokenStream.java\t2022-07-12 15:21:29.786110645 +0200\n+++ /tmp/tmpu466ub0t.java\t2022-07-12 15:21:29.786110645 +0200\n@@ -194,11 +194,11 @@\n           !Character.isJavaIdentifierStart(s.charAt(0))) {\n         return false;\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+if (lengthlengthlength == 1) {\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n       }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "Character.isIdentifierIgnorable(s.charAt(0)) || !Character.isJavaIdentifierStart(s.charAt(0))) { return false; } for (int i = 1; i < length; i++) { if (Character.isIdentifierIgnorable(s.charAt(i)) ||"
    },
    "JacksonDatabind-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "gen.writeObject(_value); // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:21:33.382092644 +0200\n+++ /tmp/tmpxd11z6a0.java\t2022-07-12 15:21:33.458092266 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is lower case\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "gen.writeObject(_value instanceof gen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:22:32.049797307 +0200\n+++ /tmp/tmpl9uulp07.java\t2022-07-12 15:22:32.049797307 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value instanceof gen;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "gen.writeObject(_value, instance);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:22:33.721788846 +0200\n+++ /tmp/tmp619bhfre.java\t2022-07-12 15:22:33.721788846 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value, instance);\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "gen.writeObject(_value); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:22:35.441780140 +0200\n+++ /tmp/tmpp1h4kvqp.java\t2022-07-12 15:22:35.441780140 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); }\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "gen.writeObject(_value); // value is this to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:22:37.097771755 +0200\n+++ /tmp/tmp9bigww4b.java\t2022-07-12 15:22:37.097771755 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is this to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "gen.writeObject(_valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:23:32.125491874 +0200\n+++ /tmp/tmpobokp1gk.java\t2022-07-12 15:23:32.129491853 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_valueType;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "gen.writeObject(_value);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:23:33.725483701 +0200\n+++ /tmp/tmp2tf18oyy.java\t2022-07-12 15:23:33.725483701 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value);\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "gen.writeObject(_valueInputRow;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:24:28.257204034 +0200\n+++ /tmp/tmptg58ls4r.java\t2022-07-12 15:24:28.257204034 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_valueInputRow;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "gen.writeObject(_value;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:24:29.945195343 +0200\n+++ /tmp/tmpl00tzuam.java\t2022-07-12 15:24:29.945195343 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value;\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "gen.writeObject(_value); // value is to 0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-97/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\t2022-07-12 15:24:31.557187043 +0200\n+++ /tmp/tmpqbjiiotm.java\t2022-07-12 15:24:31.561187024 +0200\n@@ -109,11 +109,11 @@\n         } else if (_value instanceof JsonSerializable) {\n             ((JsonSerializable) _value).serialize(gen, ctxt);\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+gen.writeObject(_value); // value is to 0\n         }\n     }\n \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "gen.writeObject(_value);",
        "fixed_line": "ctxt.defaultSerializeValue(_value, gen);"
    },
    "Lang-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "return containsStr.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:25.896906258 +0200\n+++ /tmp/tmpnaiccfg2.java\t2022-07-12 15:25:25.936906050 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return searchStr.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:27.716896821 +0200\n+++ /tmp/tmpjdd3afer.java\t2022-07-12 15:25:27.720896799 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return searchStr.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return str.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:29.296888627 +0200\n+++ /tmp/tmpbo9g7pmo.java\t2022-07-12 15:25:29.300888605 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return str.toUpperCasetoUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:30.836880639 +0200\n+++ /tmp/tmpzcvdftwi.java\t2022-07-12 15:25:30.840880620 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCasetoUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return contains(str.toUpperCase(), searchStr;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:32.424872402 +0200\n+++ /tmp/tmpoaug9pva.java\t2022-07-12 15:25:32.428872381 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr;\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return str.toUpperCaseINGINGstr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:34.108863665 +0200\n+++ /tmp/tmpl92o5a7u.java\t2022-07-12 15:25:34.108863665 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCaseINGINGstr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return str.toUpperCase - searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:35.860854572 +0200\n+++ /tmp/tmpg4__e6vv.java\t2022-07-12 15:25:35.864854550 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return str.toUpperCase - searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:37.520845955 +0200\n+++ /tmp/tmpey5quiee.java\t2022-07-12 15:25:37.524845934 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return contains(str.toUpperCase(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return containsStr.toUpperCase(), searchStr;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:46.344800128 +0200\n+++ /tmp/tmpqgcb5wji.java\t2022-07-12 15:25:46.344800128 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpperCase(), searchStr;\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return containsStr.toUpper(), searchStr.toUpperCase());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-40/src/java/org/apache/commons/lang/StringUtils.java\t2022-07-12 15:25:47.952791770 +0200\n+++ /tmp/tmpamuaawr6.java\t2022-07-12 15:25:47.952791770 +0200\n@@ -1043,11 +1043,11 @@\n      */\n     public static boolean containsIgnoreCase(String str, String searchStr) {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+return containsStr.toUpper(), searchStr.toUpperCase());\n     }\n \n     // IndexOfAny chars\n     //-----------------------------------------------------------------------\n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return contains(str.toUpperCase(), searchStr.toUpperCase());",
        "fixed_line": "int len = searchStr.length(); int max = str.length() - len; for (int i = 0; i <= max; i++) { if (str.regionMatches(true, i, searchStr, 0, len)) { return true; } } return false;"
    },
    "Closure-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:25:49.960781332 +0200\n+++ /tmp/tmpmp8w0i2p.java\t2022-07-12 15:25:50.032780959 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:25:54.708756646 +0200\n+++ /tmp/tmp_q2n0r6j.java\t2022-07-12 15:25:54.708756646 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(tokenType.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:25:58.188738543 +0200\n+++ /tmp/tmprrp28u6p.java\t2022-07-12 15:25:58.188738543 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(tokenType.toString());\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:01.624720663 +0200\n+++ /tmp/tmparye62bh.java\t2022-07-12 15:26:01.628720642 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:05.312701464 +0200\n+++ /tmp/tmpjxi_z1xv.java\t2022-07-12 15:26:05.312701464 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:09.032682090 +0200\n+++ /tmp/tmpgph53iuq.java\t2022-07-12 15:26:09.032682090 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:12.884662019 +0200\n+++ /tmp/tmpq3xbs4qs.java\t2022-07-12 15:26:12.888662000 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_PRETTY_PRINTED_TYPE;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:16.244644508 +0200\n+++ /tmp/tmpwd2i8ymj.java\t2022-07-12 15:26:16.244644508 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:20.100624402 +0200\n+++ /tmp/tmpse8tigae.java\t2022-07-12 15:26:20.100624402 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_TYPE_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(defaultNewED_TYPE_PRETTY_PRINTED_PRINTED_TYPE_ERROR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-39/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\t2022-07-12 15:26:23.836604914 +0200\n+++ /tmp/tmpov172wmm.java\t2022-07-12 15:26:23.836604914 +0200\n@@ -375,25 +375,11 @@\n           sb.append(\", \");\n         }\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n-        }\n-      }\n-\n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n+sb.append(defaultNewED_TYPE_PRETTY_PRINTED_PRINTED_TYPE_ERROR;\n     }\n   }\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(getPropertyType(property).toString()); ++i; if (i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return \"{...}\";",
        "fixed_line": "sb.append(getPropertyType(property).toStringHelper(forAnnotations)); ++i; if (!forAnnotations && i == MAX_PRETTY_PRINTED_PROPERTIES) { sb.append(\", ...\"); break; } } sb.append(\"}\"); prettyPrint = true; return sb.toString(); } else { return forAnnotations ? \"?\" : \"{...}\";"
    },
    "Cli-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuffer buff = new StringBuffer(4;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:27.480585905 +0200\n+++ /tmp/tmpfmmviov_.java\t2022-07-12 15:26:27.516585714 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(4;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuffer buff = new StringBuffer(iterables;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:29.308576360 +0200\n+++ /tmp/tmpd71xvqy3.java\t2022-07-12 15:26:29.308576360 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterables;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuffer buff = new StringBuffer(16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:30.764568760 +0200\n+++ /tmp/tmpsjhap658.java\t2022-07-12 15:26:30.764568760 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(16;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuffer buff = new StringBuffer(ake;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:32.500559696 +0200\n+++ /tmp/tmp61ppdc8e.java\t2022-07-12 15:26:32.500559696 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(ake;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuffer buff = new StringBuffer(iterators;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:33.980551966 +0200\n+++ /tmp/tmpj20j09lf.java\t2022-07-12 15:26:33.980551966 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterators;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuffer buff = new StringBuffer(iterators);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:35.404544528 +0200\n+++ /tmp/tmpnryr68s_.java\t2022-07-12 15:26:35.404544528 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterators);\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuffer buff = new StringBuffer(128;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:37.296534646 +0200\n+++ /tmp/tmpn4zxt1p8.java\t2022-07-12 15:26:37.296534646 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(128;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuffer buff = new StringBuffer[128];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:38.912526203 +0200\n+++ /tmp/tmpwp02shbp.java\t2022-07-12 15:26:38.912526203 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer[128];\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuffer buff = requiredOptions;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:40.756516567 +0200\n+++ /tmp/tmpe282nhmh.java\t2022-07-12 15:26:40.756516567 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = requiredOptions;\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuffer buff = new StringBuffer(iterables);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-4/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:26:42.396507995 +0200\n+++ /tmp/tmpgee98xi4.java\t2022-07-12 15:26:42.396507995 +0200\n@@ -293,11 +293,11 @@\n         // if there are required options that have not been\n         // processsed\n         if (requiredOptions.size() > 0)\n         {\n             Iterator iter = requiredOptions.iterator();\n-            StringBuffer buff = new StringBuffer();\n+StringBuffer buff = new StringBuffer(iterables);\n \n \n             // loop through the required options\n             while (iter.hasNext())\n             {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuffer buff = new StringBuffer();",
        "fixed_line": "StringBuffer buff = new StringBuffer(\"Missing required option\"); buff.append(requiredOptions.size() == 1 ? \"\" : \"s\"); buff.append(\": \");"
    },
    "Closure-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return NodeUtil.isFunctionExpression( n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:26:44.644496254 +0200\n+++ /tmp/tmpr63hd7ve.java\t2022-07-12 15:26:44.720495852 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return NodeUtil.isFunctionExpression( n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:26:49.720469701 +0200\n+++ /tmp/tmpp7dxi6ch.java\t2022-07-12 15:26:49.724469680 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return NodeUtil.isFunctionExpression(parent;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:30.184257644 +0200\n+++ /tmp/tmpjhmpljx5.java\t2022-07-12 15:27:30.184257644 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(parent;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return NodeUtil.isFunctionExpression( n, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:33.564239894 +0200\n+++ /tmp/tmp_fw8a7kv.java\t2022-07-12 15:27:33.568239872 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression( n, n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return NodeUtil.isFunctionExpression(parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:37.548218966 +0200\n+++ /tmp/tmpf7qyh3of.java\t2022-07-12 15:27:37.548218966 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(parent);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return NodeUtil.isFunctionExpression;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:41.288199313 +0200\n+++ /tmp/tmp275yf1m6.java\t2022-07-12 15:27:41.292199292 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return NodeUtil.isFunctionExpression(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:45.016179718 +0200\n+++ /tmp/tmp9u9mcf8m.java\t2022-07-12 15:27:45.016179718 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpression(n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return NodeUtil.isFunctionExpressionNode(n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:48.540161187 +0200\n+++ /tmp/tmp6_3u4g1z.java\t2022-07-12 15:27:48.544161166 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode(n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return NodeUtil.isFunctionExpressionNode( n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:52.044142758 +0200\n+++ /tmp/tmpaluhswvv.java\t2022-07-12 15:27:52.048142737 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode( n;\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return NodeUtil.isFunctionExpressionNode( n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-55/src/com/google/javascript/jscomp/FunctionRewriter.java\t2022-07-12 15:27:55.736123333 +0200\n+++ /tmp/tmp5r7ubvve.java\t2022-07-12 15:27:55.736123333 +0200\n@@ -112,11 +112,11 @@\n         reducer.getClass().toString() + \":helper\", reducer.getHelperSource());\n     return (root != null) ? root.removeFirstChild() : null;\n   }\n \n   private static boolean isReduceableFunctionExpression(Node n) {\n-    return NodeUtil.isFunctionExpression(n);\n+return NodeUtil.isFunctionExpressionNode( n);\n   }\n \n   /**\n    * Information needed to apply a reduction.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return NodeUtil.isFunctionExpression(n);",
        "fixed_line": "return NodeUtil.isFunctionExpression(n) && !NodeUtil.isGetOrSetKey(n.getParent());"
    },
    "JacksonDatabind-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (mixIn methods) {",
                "patch_diff": "} else if (mixIn methods) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; i++) {",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; ++i) {",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (methodIns) {",
                "patch_diff": "} else if (methodIns) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; i++) { if (mixIn methods.isAssignableFrom(m)); } }",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < count; i++) { if (mixIn methods.isAssignableFrom(m)); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; i++) {",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < size; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (mixIn methods.length) {",
                "patch_diff": "} else if (mixIn methods.length) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < names.length; i++) {",
                "patch_diff": "// [JACKSON-level merge within mixinsn, as per [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < names.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "am = mixIns.find(m); if (am != null) { _addMixUnders(m, am); } else { mixIns.add(_constructMethod(m)); }"
    },
    "Lang-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "out.write('\\\\');",
                "patch_diff": "out.write('\\\\');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "patch_diff": "out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\'); break; case '\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write('\\\\': out.write(ch; default",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case '/': out.write('\\\\'); out.write('/'); break;"
    },
    "Math-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (state. boundaries[0] = uB; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (state. boundaries = new double[2]; boundaries[0] = uB;",
                "patch_diff": "if (state. boundaries = new double[2]; boundaries[0] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (lB. boundaries[0] = uB; boundaries[1] = uB;",
                "patch_diff": "if (lB. boundaries[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (state. boundaries[0] = uB; boundaries[1] = uB;",
                "patch_diff": "} else if (state. boundaries[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (state. boundaries = new double[2]; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries = new double[2]; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (lB; boundaries[0] = uB; boundaries[1] = uB;",
                "patch_diff": "if (lB; boundaries[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (state. boundaries = new double[2]; boundaries[0] = uB; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries = new double[2]; boundaries[0] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (state. boundaries = new double[2] = lB; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries = new double[2] = lB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (state. boundaries[0] = uB; boundaries[1] = uB; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries[0] = uB; boundaries[1] = uB; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (state. boundaries = new double[1]; boundaries[1] = uB;",
                "patch_diff": "if (state. boundaries = new double[1]; boundaries[1] = uB;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "for (int i = 0; i < lB.length; i++) { if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) { final double max = Double.MAX_VALUE + boundaries[0][i]; final NumberIsTooLargeException e = new NumberIsTooLargeException(boundaries[1][i], max, true); e.getContext().addMessage(LocalizedFormats.OVERFLOW); e.getContext().addMessage(LocalizedFormats.INDEX, i); throw e; } }"
    },
    "JacksonDatabind-86": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+_referencedType; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+_referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "throw new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JavaType sb = new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "patch_diff": "JavaType sb = new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _referencedType+\", new = \"+ref; }",
                "patch_diff": "return _referencedType+\", new = \"+ref; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _referencedType;",
                "patch_diff": "return _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = _referencedType;",
                "patch_diff": "private static final /*day*/int[] EASTER = _referencedType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref.referencedType; }",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref.referencedType; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref;",
                "patch_diff": "return new IllegalStateException(\"Trying to re-set selfType+\", new = \"+ref;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JavaType getSuperClass() { if (_referencedType != null) { return _referencedType.getSuperClass(); } return super.getSuperClass(); }"
    },
    "Closure-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "@Override public JSType getLeastSupertype = this.buildType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:07.560061085 +0200\n+++ /tmp/tmpqkh1gx2n.java\t2022-07-12 15:28:07.648060619 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = this.buildType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "@Override public JSType getLeastSupertype;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:13.180031471 +0200\n+++ /tmp/tmp59g4pmjq.java\t2022-07-12 15:28:13.184031449 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "@Override public JSType getLeastSupertype(property) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:16.960011549 +0200\n+++ /tmp/tmp1m4d2qtt.java\t2022-07-12 15:28:16.964011528 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(property) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "@Override public JSType getLeastSupertype = that.buildType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:20.443993180 +0200\n+++ /tmp/tmp44bww2lw.java\t2022-07-12 15:28:20.447993159 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.buildType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "@Override public JSType getLeastSupertype = that.isRecordType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:24.255973077 +0200\n+++ /tmp/tmpx6_sadxn.java\t2022-07-12 15:28:24.255973077 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.isRecordType;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "@Override public JSType getLeastSupertype;STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:27.955953558 +0200\n+++ /tmp/tmp6pyzk9cs.java\t2022-07-12 15:28:27.955953558 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype;STRING) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "@Override public JSType getLeastSupertype = that.build;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:31.347935658 +0200\n+++ /tmp/tmpaf65i53t.java\t2022-07-12 15:28:31.347935658 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = that.build;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "@Override public JSType getLeastSupertype(JSType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:34.859917121 +0200\n+++ /tmp/tmp8rn9m9wr.java\t2022-07-12 15:28:34.859917121 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype(JSType) {\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "@Override public JSType getLeastSupertype = this.build;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:38.547897650 +0200\n+++ /tmp/tmp6kxi5ipc.java\t2022-07-12 15:28:38.547897650 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override public JSType getLeastSupertype = this.build;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "@Override publicJSType getLeastSupertype;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-46/src/com/google/javascript/rhino/jstype/RecordType.java\t2022-07-12 15:28:42.515876692 +0200\n+++ /tmp/tmprk5w6mq7.java\t2022-07-12 15:28:42.515876692 +0200\n@@ -135,26 +135,11 @@\n \n     return super.defineProperty(propertyName, type, inferred,\n         propertyNode);\n   }\n \n-  @Override\n-  public JSType getLeastSupertype(JSType that) {\n-    if (!that.isRecordType()) {\n-      return super.getLeastSupertype(that);\n-    }\n-    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n-    for (String property : properties.keySet()) {\n-      if (that.toMaybeRecordType().hasProperty(property) &&\n-          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n-              getPropertyType(property))) {\n-        builder.addProperty(property, getPropertyType(property),\n-            getPropertyNode(property));\n-      }\n-    }\n-    return builder.build();\n-  }\n+@Override publicJSType getLeastSupertype;\n   JSType getGreatestSubtypeHelper(JSType that) {\n     if (that.isRecordType()) {\n       RecordType thatRecord = that.toMaybeRecordType();\n       RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "@Override public JSType getLeastSupertype(JSType that) { if (!that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "fixed_line": ""
    },
    "JacksonCore-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = str.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:46.467855813 +0200\n+++ /tmp/tmpliirrqqt.java\t2022-07-12 15:28:46.495855665 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = s.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:48.515844992 +0200\n+++ /tmp/tmpqovdgplh.java\t2022-07-12 15:28:48.515844992 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = s.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = input.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:50.055836852 +0200\n+++ /tmp/tmpp_p56qn5.java\t2022-07-12 15:28:50.055836852 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = input.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = text.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:51.583828776 +0200\n+++ /tmp/tmpx02upaag.java\t2022-07-12 15:28:51.583828776 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = text.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i++) - '0') * 10;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:53.183820319 +0200\n+++ /tmp/tmp7fbjqyuf.java\t2022-07-12 15:28:53.183820319 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++) - '0') * 10;\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i++++i++) - '0') * 10;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:54.667812472 +0200\n+++ /tmp/tmphken4qx2.java\t2022-07-12 15:28:54.671812451 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++) - '0') * 10;\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c = str.charAt(i++++i++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:56.243804139 +0200\n+++ /tmp/tmppz1fiq29.java\t2022-07-12 15:28:56.243804139 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i++++i++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = text.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:57.843795678 +0200\n+++ /tmp/tmp5r0ebbxu.java\t2022-07-12 15:28:57.843795678 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = text.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = input.charAt(i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:28:59.467787089 +0200\n+++ /tmp/tmpm2sx4ofz.java\t2022-07-12 15:28:59.467787089 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = input.charAt(i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = key.charAt(i++++i++);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonCore-5/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\t2022-07-12 15:29:01.019778881 +0200\n+++ /tmp/tmp6g9zv8rs.java\t2022-07-12 15:29:01.019778881 +0200\n@@ -188,11 +188,11 @@\n         // have arrays over 2 billion entries so ints are fine.\n         if (len == 0 || len > 10) {\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = key.charAt(i++++i++);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }\n         }\n         if (len == 10) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i++);",
        "fixed_line": "char c = str.charAt(i);"
    },
    "Math-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (j = 0; k < yDotK[1]); ++j) {",
                "patch_diff": "for (j = 0; k < yDotK[1]); ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (j = 0; k < x.length; ++j) {",
                "patch_diff": "for (j = 0; k < x.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int k = 0; k < yDotK[1]); ++j) {",
                "patch_diff": "for (int k = 0; k < yDotK[1]); ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (j = 0; j < x.length; ++j) {",
                "patch_diff": "for (j = 0; j < x.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (j = 0; k < yDotK[1]); ++j; ++j) {",
                "patch_diff": "for (j = 0; k < yDotK[1]); ++j; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (j = 0; k < d; ++j) {",
                "patch_diff": "for (j = 0; k < d; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int k = 0; k < yDotK.length; ++j) {",
                "patch_diff": "for (int k = 0; k < yDotK.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int k = 0; k < yDotK[1]); ++j; ++j) {",
                "patch_diff": "for (int k = 0; k < yDotK[1]); ++j; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (j = 0; k < y, k; ++j) {",
                "patch_diff": "for (j = 0; k < y, k; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (j = 0; j < k; ++j) {",
                "patch_diff": "for (j = 0; j < k; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (forward) { if (stepStart + stepSize >= t) { stepSize = t - stepStart; } } else { if (stepStart + stepSize <= t) { stepSize = t - stepStart; } }"
    },
    "JacksonDatabind-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] EASTER = this;",
                "patch_diff": "private static final /*day*/int[] EASTER = this;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] EASTER = _valueInstantiator;",
                "patch_diff": "private static final /*day*/int[] EASTER = _valueInstantiator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] EASTER = _typeFactory;",
                "patch_diff": "private static final /*day*/int[] EASTER = _typeFactory;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] EASTER = _beanType;",
                "patch_diff": "private static final /*day*/int[] EASTER = _beanType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] EASTER = _valueInstantiator.length;",
                "patch_diff": "private static final /*day*/int[] EASTER = _valueInstantiator.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] items = _valueInstantiator;",
                "patch_diff": "private static final /*day*/int[] items = _valueInstantiator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] EASTER = _type;",
                "patch_diff": "private static final /*day*/int[] EASTER = _type;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] items = this;",
                "patch_diff": "private static final /*day*/int[] items = this;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] EASTER = this.textBuffer;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.textBuffer;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /*day*/int[] EASTER = _parsingContext.instance;",
                "patch_diff": "private static final /*day*/int[] EASTER = _parsingContext.instance;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (jp.getCurrentTokenId() != JsonToken.FIELD_NAME.id()) { copyCurrentStructure(jp); return this; } /* 28-Oct-2014, tatu: As per #592, need to support a special case of starting from * FIELD_NAME, which is taken to mean that we are missing START_OBJECT, but need * to assume one did exist. */ JsonToken t; writeStartObject(); do { copyCurrentStructure(jp); } while ((t = jp.nextToken()) == JsonToken.FIELD_NAME); if (t != JsonToken.END_OBJECT) { throw ctxt.mappingException(\"Expected END_OBJECT after copying contents of a JsonParser into TokenBuffer, got \"+t); } writeEndObject();"
    },
    "Chart-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (endIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:06.495749907 +0200\n+++ /tmp/tmpj46_fx68.java\t2022-07-12 15:29:06.591749399 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (lastIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:16.971694448 +0200\n+++ /tmp/tmpyvy75cxy.java\t2022-07-12 15:29:16.971694448 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (lastIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (startIndex < 0) { // end period is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:18.915684154 +0200\n+++ /tmp/tmpcawg3vah.java\t2022-07-12 15:29:18.915684154 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (startIndex < 0) { // end period is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (endIndex < 0) { // end period is first item AFTER end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:27.047641068 +0200\n+++ /tmp/tmpqivygzny.java\t2022-07-12 15:29:27.047641068 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is first item AFTER end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (endIndex < 0) { // start is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:35.427596644 +0200\n+++ /tmp/tmpvlytb4gd.java\t2022-07-12 15:29:35.427596644 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // start is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (endIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:43.755552471 +0200\n+++ /tmp/tmp6k0ju99q.java\t2022-07-12 15:29:43.755552471 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (endIndex < 0) { // end period is last item BEFORE end",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:29:51.723510182 +0200\n+++ /tmp/tmpi66mjtf5.java\t2022-07-12 15:29:51.723510182 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is last item BEFORE end\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (endIndex < 0) { // end period is a end period",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:30:00.091465746 +0200\n+++ /tmp/tmpfgd065kv.java\t2022-07-12 15:30:00.091465746 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (endIndex < 0) { // end period is a end period\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (lastIndex < 0) { // start is not in original series",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:30:08.343421902 +0200\n+++ /tmp/tmpqzr4lbdh.java\t2022-07-12 15:30:08.343421902 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (lastIndex < 0) { // start is not in original series\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (lastIndex < 0) { // end period is negative",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-9/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 15:30:10.311411443 +0200\n+++ /tmp/tmpvzt82ppm.java\t2022-07-12 15:30:10.311411443 +0200\n@@ -939,11 +939,11 @@\n         int endIndex = getIndex(end);\n         if (endIndex < 0) {             // end period is not in original series\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+if (lastIndex < 0) { // end period is negative\n             emptyRange = true;\n         }\n         if (emptyRange) {\n             TimeSeries copy = (TimeSeries) super.clone();\n             copy.data = new java.util.ArrayList();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (endIndex < 0) {",
        "fixed_line": "if ((endIndex < 0) || (endIndex < startIndex)) {"
    },
    "JacksonDatabind-93": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:12.727398601 +0200\n+++ /tmp/tmpdhe5ua0z.java\t2022-07-12 15:30:12.759398430 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (raw.startsWith(\"/\")) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:15.287384989 +0200\n+++ /tmp/tmph_efheab.java\t2022-07-12 15:30:15.287384989 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (raw.startsWith(\"/STRING) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:17.135375163 +0200\n+++ /tmp/tmpraobplx_.java\t2022-07-12 15:30:17.135375163 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/STRING) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (raw.startsWith(\"/\")) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:18.635367186 +0200\n+++ /tmp/tmpyjb3zhlk.java\t2022-07-12 15:30:18.635367186 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (raw.startsWith(\"/Id) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:20.339358124 +0200\n+++ /tmp/tmpdldsn7lq.java\t2022-07-12 15:30:20.339358124 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/Id) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (raw.startsWith(\"/ /*\") || cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:22.119348656 +0200\n+++ /tmp/tmpj7f8zymu.java\t2022-07-12 15:30:22.119348656 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/ /*\") || cls = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (raw.startsWith(\"/STRING) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:23.715340168 +0200\n+++ /tmp/tmpo0dwzuzf.java\t2022-07-12 15:30:23.715340168 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/STRING) { for (rawType = raw.class; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (raw.startsWith(\"/ type) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:25.427331060 +0200\n+++ /tmp/tmppj83xbhr.java\t2022-07-12 15:30:25.431331040 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/ type) { for (raw = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = cls; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:27.131321995 +0200\n+++ /tmp/tmpntkmno2j.java\t2022-07-12 15:30:27.131321995 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = cls; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (raw.startsWith(\"/\")) { for (raw<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-93/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java\t2022-07-12 15:30:28.919312478 +0200\n+++ /tmp/tmp1jicifr6.java\t2022-07-12 15:30:28.919312478 +0200\n@@ -78,12 +78,11 @@\n             }\n \n             // 18-Dec-2017, tatu: As per [databind#1855], need bit more sophisticated handling\n             //    for some Spring framework types\n             // 05-Jan-2017, tatu: ... also, only applies to classes, not interfaces\n-            if (full.startsWith(PREFIX_STRING)) {\n-                for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {\n+if (raw.startsWith(\"/\")) { for (raw<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                     String name = cls.getSimpleName();\n                     // looking for \"AbstractBeanFactoryPointcutAdvisor\" but no point to allow any is there?\n                     if (\"AbstractPointcutAdvisor\".equals(name)\n                             // ditto  for \"FileSystemXmlApplicationContext\": block all ApplicationContexts\n                             || \"AbstractApplicationContext\".equals(name)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {",
        "fixed_line": "if (!raw.isInterface() && full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; (cls != null) && (cls != Object.class); cls = cls.getSuperclass()) {"
    },
    "Codec-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringUtils.newStringUtf8Base64(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:31.127300724 +0200\n+++ /tmp/tmpelq3r4om.java\t2022-07-12 15:30:31.195300364 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8Base64(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringUtils.newStringUtf8Base64(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:33.283289252 +0200\n+++ /tmp/tmp7ga8i9rb.java\t2022-07-12 15:30:33.283289252 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8Base64(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringUtils.newStringUtf8(base64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:34.803281160 +0200\n+++ /tmp/tmp9yuagalj.java\t2022-07-12 15:30:34.803281160 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(base64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringUtils.newStringUtf8(base64Data, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:36.475272260 +0200\n+++ /tmp/tmp5wd8rebi.java\t2022-07-12 15:30:36.475272260 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(base64Data, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return StringUtils.newStringUtf8(formatData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:38.267262718 +0200\n+++ /tmp/tmprbnu0138.java\t2022-07-12 15:30:38.267262718 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(formatData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringUtils.newStringUtf8(_base64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:40.103252941 +0200\n+++ /tmp/tmp5x8wnoon.java\t2022-07-12 15:30:40.103252941 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(_base64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringUtils.newStringUtf8(binaryData, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:41.719244336 +0200\n+++ /tmp/tmpocp9gv4u.java\t2022-07-12 15:30:41.719244336 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(binaryData, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringUtils.newStringUtf8(_base64Data, true));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:43.375235516 +0200\n+++ /tmp/tmpl85uobqp.java\t2022-07-12 15:30:43.375235516 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(_base64Data, true));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringUtils.newStringUtf8(encodeBase64Data, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:45.199225801 +0200\n+++ /tmp/tmp2va6wxbl.java\t2022-07-12 15:30:45.203225779 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(encodeBase64Data, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringUtils.newStringUtf8(binaryData, false));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-7/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:30:47.055215915 +0200\n+++ /tmp/tmpzbv2gert.java\t2022-07-12 15:30:47.055215915 +0200\n@@ -665,11 +665,11 @@\n      *            binary data to encode\n      * @return String containing Base64 characters.\n      * @since 1.4\n      */    \n     public static String encodeBase64String(byte[] binaryData) {\n-        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n+return StringUtils.newStringUtf8(binaryData, false));\n     }\n     \n     /**\n      * Encodes binary data using a URL-safe variation of the base64 algorithm but does not chunk the output. The\n      * url-safe variation emits - and _ instead of + and / characters.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
        "fixed_line": "return StringUtils.newStringUtf8(encodeBase64(binaryData, false));"
    },
    "Math-50": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:30:49.091205066 +0200\n+++ /tmp/tmp7r4jw1gj.java\t2022-07-12 15:30:49.139204810 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:30:52.291188015 +0200\n+++ /tmp/tmpsjig_ptw.java\t2022-07-12 15:30:52.291188015 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x0 = 0.5 * (x0 + x1 - x0) * (x1 = x0 - f1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:30:54.367176950 +0200\n+++ /tmp/tmp5fsoiksw.java\t2022-07-12 15:30:54.371176929 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1 - x0) * (x1 = x0 - f1;\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x0 = 0.5 * (x0 + x1) / (x0 = x1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:30:56.551165312 +0200\n+++ /tmp/tmpj7arv7hm.java\t2022-07-12 15:30:56.551165312 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) / (x0 = x1);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:30:58.731153689 +0200\n+++ /tmp/tmpb4kixkz1.java\t2022-07-12 15:30:58.731153689 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:31:00.791142708 +0200\n+++ /tmp/tmpnlp1u3sm.java\t2022-07-12 15:31:00.791142708 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x1);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); if (x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:31:03.055130630 +0200\n+++ /tmp/tmp5tw33wus.java\t2022-07-12 15:31:03.055130630 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); if (x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:31:05.131119563 +0200\n+++ /tmp/tmpyemi_47w.java\t2022-07-12 15:31:05.131119563 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x1 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); double x0 = x0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:31:07.371107616 +0200\n+++ /tmp/tmp3xu22r4b.java\t2022-07-12 15:31:07.371107616 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); double x0 = x0);\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); } else if (x0 = x0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-50/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\t2022-07-12 15:31:09.591095775 +0200\n+++ /tmp/tmp0p9l8hc3.java\t2022-07-12 15:31:09.591095775 +0200\n@@ -182,14 +182,11 @@\n                 case PEGASUS:\n                     f0 *= f1 / (f1 + fx);\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n-                    if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n-                    }\n+if (x0 = 0.5 * (x0 + x1) * (x0 + point1.x0 = x0); } else if (x0 = x0); }\n                     break;\n                 default:\n                     // Should never happen.\n                     throw new MathInternalError();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); }",
        "fixed_line": ""
    },
    "Closure-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "Node next = c.getNext(); // c may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:31:11.847083738 +0200\n+++ /tmp/tmp5btnox_6.java\t2022-07-12 15:31:11.879083568 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Node next = c.getNext(); // c may be removed (c)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:31:58.774833044 +0200\n+++ /tmp/tmp3schey5i.java\t2022-07-12 15:31:58.774833044 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed (c)\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Node next = c.getNext(); // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:32:41.342605105 +0200\n+++ /tmp/tmp3p32zlve.java\t2022-07-12 15:32:41.346605084 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Node next = c.getNext(); // c may be null or empty",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:33:23.466379087 +0200\n+++ /tmp/tmpfoz0v6_0.java\t2022-07-12 15:33:23.466379087 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be null or empty\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Node next = c.getNext(); // c may be removed.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:34:05.274154350 +0200\n+++ /tmp/tmpjhgylqkk.java\t2022-07-12 15:34:05.274154350 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c may be removed.\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Node next = c.getNext(); // c = c.next;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:34:46.957929901 +0200\n+++ /tmp/tmpq2dnulog.java\t2022-07-12 15:34:46.957929901 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Node next = c.getNext(); // c = c.next, block;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:35:27.957708794 +0200\n+++ /tmp/tmpj7emt7ej.java\t2022-07-12 15:35:27.957708794 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c = c.next, block;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Node next = c.getNext;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:36:09.001487139 +0200\n+++ /tmp/tmpgg89i9hq.java\t2022-07-12 15:36:09.001487139 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext;\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Node next = c.getNext; // c = c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:36:12.597467704 +0200\n+++ /tmp/tmpvf3kjpka.java\t2022-07-12 15:36:12.601467683 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext; // c = c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Node next = c.getNext(); // c.next, may be removed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-13/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\t2022-07-12 15:36:16.153448486 +0200\n+++ /tmp/tmpl16nhqux.java\t2022-07-12 15:36:16.153448486 +0200\n@@ -122,11 +122,11 @@\n     int visits = 0;\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n         traverse(c);\n-        Node next = c.getNext();\n+Node next = c.getNext(); // c.next, may be removed\n         c = next;\n       }\n \n       visit(node);\n       visits++;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Node next = c.getNext();",
        "fixed_line": "Node next = c.getNext();"
    },
    "Jsoup-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:36:58.269278580 +0200\n+++ /tmp/tmpqw8ef1yi.java\t2022-07-12 15:36:58.325278384 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").5) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:00.193271871 +0200\n+++ /tmp/tmpidu9y06z.java\t2022-07-12 15:37:00.193271871 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\").\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:01.685266659 +0200\n+++ /tmp/tmpy_9nj2n1.java\t2022-07-12 15:37:01.685266659 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:03.257261159 +0200\n+++ /tmp/tmpjsaz9v5c.java\t2022-07-12 15:37:03.257261159 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"plot\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:04.809255721 +0200\n+++ /tmp/tmpicgry8vs.java\t2022-07-12 15:37:04.813255707 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\", \"plot\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:06.309250458 +0200\n+++ /tmp/tmp24rn9pmi.java\t2022-07-12 15:37:06.309250458 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\").5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:07.845245061 +0200\n+++ /tmp/tmpqq53h9_0.java\t2022-07-12 15:37:07.849245047 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \" \"Xoframes\", \"style\").5) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\", \"plot\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:09.381239655 +0200\n+++ /tmp/tmpuyzttzcw.java\t2022-07-12 15:37:09.381239655 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\", \"plot\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") ||!isrames\", \"title\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:11.085233647 +0200\n+++ /tmp/tmprnaasiu2.java\t2022-07-12 15:37:11.085233647 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgs): \" +command\", \"link\", \"meta\", \"Xoframes\", \"style\") ||!isrames\", \"title\")) {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-15/src/main/java/org/jsoup/parser/TreeBuilderState.java\t2022-07-12 15:37:12.749227772 +0200\n+++ /tmp/tmpuwspr7b0.java\t2022-07-12 15:37:12.749227772 +0200\n@@ -278,11 +278,11 @@\n                         Element html = tb.getStack().getFirst();\n                         for (Attribute attribute : startTag.getAttributes()) {\n                             if (!html.hasAttr(attribute.getKey()))\n                                 html.attributes().put(attribute);\n                         }\n-                    } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n+} else if (StringUtil.ineno, \"base\", \"bgsound\", \"link\", \"meta\", \"style\") ||!isrames\", \"title\", \"style\") {\n                         return tb.process(t, InHead);\n                     } else if (name.equals(\"body\")) {\n                         tb.error(this);\n                         LinkedList<Element> stack = tb.getStack();\n                         if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {",
        "fixed_line": "} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {"
    },
    "Time-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "bucket.setZone(id = position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:14.721220796 +0200\n+++ /tmp/tmpyc06pb4r.java\t2022-07-12 15:37:14.877220245 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "bucket.setZone(id = position + 1, text.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:18.053208983 +0200\n+++ /tmp/tmpq10xkfh9.java\t2022-07-12 15:37:18.053208983 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + 1, text.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:19.629203383 +0200\n+++ /tmp/tmpqcfcy0e6.java\t2022-07-12 15:37:19.633203369 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length();\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length - position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:21.145197987 +0200\n+++ /tmp/tmp58mueg_n.java\t2022-07-12 15:37:21.149197973 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length - position;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "bucket.setZone(id = position + id;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:22.765192214 +0200\n+++ /tmp/tmplvf53gf6.java\t2022-07-12 15:37:22.769192200 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = position + id;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "bucket.setZone(id = text.length - position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:24.569185773 +0200\n+++ /tmp/tmp2rfah8o4.java\t2022-07-12 15:37:24.569185773 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = text.length - position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "bucket.setZone(id = str + id;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:26.305179567 +0200\n+++ /tmp/tmpin4_4mb8.java\t2022-07-12 15:37:26.309179553 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(id = str + id;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "bucket.setZone(idid = position + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:27.921173780 +0200\n+++ /tmp/tmpgep4q0cu.java\t2022-07-12 15:37:27.921173780 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(idid = position + 1;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "bucket.setZone(DateTimeZone.forID(id + 1, text.length() - position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:29.505168099 +0200\n+++ /tmp/tmphu0vnvki.java\t2022-07-12 15:37:29.505168099 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + 1, text.length() - position;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "bucket.setZone(DateTimeZone.forID(id + id;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-20/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\t2022-07-12 15:37:31.197162022 +0200\n+++ /tmp/tmpt_u9ew1u.java\t2022-07-12 15:37:31.201162008 +0200\n@@ -2539,12 +2539,11 @@\n \n         public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n             String str = text.substring(position);\n             for (String id : ALL_IDS) {\n                 if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n+bucket.setZone(DateTimeZone.forID(id + id;\n                 }\n             }\n             return ~position;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "bucket.setZone(DateTimeZone.forID(id)); return position + id.length();",
        "fixed_line": "String best = null; for (String id : ALL_IDS) { if (str.startsWith(id)) { if (best == null || id.length() > best.length()) { best = id; } } } if (best != null) { bucket.setZone(DateTimeZone.forID(best)); return position + best.length(); }"
    },
    "Time-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:33.177154898 +0200\n+++ /tmp/tmp7jtfegug.java\t2022-07-12 15:37:33.193154842 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCToLocal - 3 * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long instantBefore = convertUTCs * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:35.341147099 +0200\n+++ /tmp/tmp0zhdt5o6.java\t2022-07-12 15:37:35.345147085 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCs * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long instantBefore = convertUTCCount * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:37.117140685 +0200\n+++ /tmp/tmp14wm7un8.java\t2022-07-12 15:37:37.117140685 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTCCount * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long instantBefore = new DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:38.773134697 +0200\n+++ /tmp/tmp1mq_d4pt.java\t2022-07-12 15:37:38.773134697 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = new DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long instantBefore = convertUTC * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:40.373128903 +0200\n+++ /tmp/tmp9ckh_e2i.java\t2022-07-12 15:37:40.373128903 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long instantBefore = convertUTC - offset) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:42.157122434 +0200\n+++ /tmp/tmpq26b_vkq.java\t2022-07-12 15:37:42.157122434 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC - offset) * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long instantBefore = convertUTC > 3 * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:43.709116797 +0200\n+++ /tmp/tmpw0vwq4xm.java\t2022-07-12 15:37:43.713116781 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC > 3 * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long instantBefore = convertUTC - offset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:45.485110337 +0200\n+++ /tmp/tmpvzmqd9hh.java\t2022-07-12 15:37:45.485110337 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC - offset;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long instantBefore = convertUTC(instant - offset) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:47.173104186 +0200\n+++ /tmp/tmpqwxmca4n.java\t2022-07-12 15:37:47.177104172 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = convertUTC(instant - offset) * DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long instantBefore = instant / DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-17/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 15:37:48.925097795 +0200\n+++ /tmp/tmptv7aegd5.java\t2022-07-12 15:37:48.925097795 +0200\n@@ -1162,19 +1162,11 @@\n      */\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n         \n         // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n-        }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+long instantBefore = instant / DateTimeConstants.MILLIS_PER_HOUR;\n         \n         // calculate result\n           // currently in later offset\n           // currently in earlier offset\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR); long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR); if (instantBefore == instantAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long local = convertUTCToLocal(instant); return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);",
        "fixed_line": "long instantBefore = instant - 3 * DateTimeConstants.MILLIS_PER_HOUR; long instantAfter = instant + 3 * DateTimeConstants.MILLIS_PER_HOUR; long offsetBefore = getOffset(instantBefore); long offsetAfter = getOffset(instantAfter); if (offsetBefore <= offsetAfter) { return instant; // not an overlap (less than is a gap, equal is normal case) } // work out range of instants that have duplicate local times long diff = offsetBefore - offsetAfter; long transition = nextTransition(instantBefore); long overlapStart = transition - diff; long overlapEnd = transition + diff; if (instant < overlapStart || instant >= overlapEnd) { return instant; // not an overlap } // calculate result long afterStart = instant - overlapStart; if (afterStart >= diff) { // currently in later offset return earlierOrLater ? instant : instant - diff; } else { // currently in earlier offset return earlierOrLater ? instant + diff : instant; }"
    },
    "JacksonDatabind-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "paramName = candidate.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:37:50.769091056 +0200\n+++ /tmp/tmpgk4cvx90.java\t2022-07-12 15:37:50.837090804 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "paramName = candidate.findImplicitParamNameName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:37:53.329081685 +0200\n+++ /tmp/tmpsp36skrv.java\t2022-07-12 15:37:53.329081685 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "paramName = candidate.findImplicitParamName)];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:37:55.325074365 +0200\n+++ /tmp/tmp7mutyu9_.java\t2022-07-12 15:37:55.329074349 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName)];\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "paramName = candidate.findImplicitParamName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:37:56.897068590 +0200\n+++ /tmp/tmp6et2qii1.java\t2022-07-12 15:37:56.901068574 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "paramName = t.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:37:58.629062218 +0200\n+++ /tmp/tmpzks73js_.java\t2022-07-12 15:37:58.633062204 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = t.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "paramName = candidate.findImplicitParamName(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:38:00.641054806 +0200\n+++ /tmp/tmpeiwj3wmx.java\t2022-07-12 15:38:00.653054762 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(1);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "paramName = candidate.findImplicitParamName(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:38:57.808839172 +0200\n+++ /tmp/tmpl3b6ki7f.java\t2022-07-12 15:38:57.808839172 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "paramName = candidateDef.findImplicitParamName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:39:53.096622077 +0200\n+++ /tmp/tmpqdsf7dcg.java\t2022-07-12 15:39:53.096622077 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidateDef.findImplicitParamName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "paramName = candidate.findImplicitParamNameName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:39:54.952614654 +0200\n+++ /tmp/tmphltkkcwg.java\t2022-07-12 15:39:54.956614638 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameName);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "paramName = candidate.findImplicitParamNameNameName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-96/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\t2022-07-12 15:39:56.496608472 +0200\n+++ /tmp/tmphctk6r7y.java\t2022-07-12 15:39:56.512608407 +0200\n@@ -730,11 +730,11 @@\n             // or field, we'll consider it property-based as well\n \n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+paramName = candidate.findImplicitParamNameNameName;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {\n             SettableBeanProperty[] properties = new SettableBeanProperty[] {\n                     constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId)\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "paramName = candidate.findImplicitParamName(0);",
        "fixed_line": "paramName = candidate.paramName(0);"
    },
    "Cli-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new MissingOptionException(buff.millisecondPart.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:39:58.580600119 +0200\n+++ /tmp/tmpkaagsj0t.java\t2022-07-12 15:39:58.608600006 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:00.528592301 +0200\n+++ /tmp/tmpm2y225bk.java\t2022-07-12 15:40:00.532592285 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new MissingOptionException(buff.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:02.056586163 +0200\n+++ /tmp/tmp1igdt3zu.java\t2022-07-12 15:40:02.056586163 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecond);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new MissingOptionException(buff.MIN_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:03.660579713 +0200\n+++ /tmp/tmpmse13g7w.java\t2022-07-12 15:40:03.660579713 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MIN_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecondPart.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:05.112573869 +0200\n+++ /tmp/tmpwci1fv2a.java\t2022-07-12 15:40:05.116573853 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecondPart.toString());\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new MissingOptionException(buff.MIN_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:06.748567280 +0200\n+++ /tmp/tmpz2tyciow.java\t2022-07-12 15:40:06.752567262 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MIN_VALUE)\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:08.228561312 +0200\n+++ /tmp/tmpn0awhsjt.java\t2022-07-12 15:40:08.228561312 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE)\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new MissingOptionException(buff.MIN_VALUE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:09.756555145 +0200\n+++ /tmp/tmp6nrw8i5f.java\t2022-07-12 15:40:09.756555145 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MIN_VALUE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new MissingOptionException(buff.MINUTE_VALUE_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:11.432548374 +0200\n+++ /tmp/tmpp3jarikv.java\t2022-07-12 15:40:11.432548374 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.MINUTE_VALUE_VALUE;\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new MissingOptionException(buff.millisecondPart.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-9/src/java/org/apache/commons/cli/Parser.java\t2022-07-12 15:40:12.968542163 +0200\n+++ /tmp/tmpwc9ytlvy.java\t2022-07-12 15:40:12.968542163 +0200\n@@ -317,11 +317,11 @@\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n             }\n \n-            throw new MissingOptionException(buff.toString());\n+throw new MissingOptionException(buff.millisecondPart.millisecond);\n         }\n     }\n \n     /**\n      * <p>Process the argument values for the specified Option\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new MissingOptionException(buff.toString());",
        "fixed_line": "buff.append(\", \"); } throw new MissingOptionException(buff.substring(0, buff.length() - 2));"
    },
    "Chart-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:14.836534605 +0200\n+++ /tmp/tmpo7ozp1sd.java\t2022-07-12 15:40:14.920534263 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:16.956526014 +0200\n+++ /tmp/tmp09_3k5zm.java\t2022-07-12 15:40:16.960525998 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:18.540519587 +0200\n+++ /tmp/tmpqwe_9vvy.java\t2022-07-12 15:40:18.540519587 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return \" title=\\\"\" + this.toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:20.080513335 +0200\n+++ /tmp/tmpyczc3f6t.java\t2022-07-12 15:40:20.084513319 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return \" title=\\\"\" + this.toolTipText; + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:21.656506930 +0200\n+++ /tmp/tmpgnj2v_ol.java\t2022-07-12 15:40:21.656506930 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.toolTipText; + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return \" title=\\\"\" + this.toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:23.312500194 +0200\n+++ /tmp/tmpbniv2zsq.java\t2022-07-12 15:40:23.312500194 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:24.872493844 +0200\n+++ /tmp/tmp95ipcbwq.java\t2022-07-12 15:40:24.872493844 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\";\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:26.420487535 +0200\n+++ /tmp/tmpcm7s4t2u.java\t2022-07-12 15:40:26.420487535 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText);\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:28.052480879 +0200\n+++ /tmp/tmp_1alwf9p.java\t2022-07-12 15:40:28.052480879 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + this.title=\\\"\" + toolTipText;\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-10/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\t2022-07-12 15:40:29.584474626 +0200\n+++ /tmp/tmpq8vuerih.java\t2022-07-12 15:40:29.584474626 +0200\n@@ -60,10 +60,10 @@\n      * @param toolTipText  the tooltip.\n      * \n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+return \" title=\\\"\" + this.title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }\n             + \"\\\" alt=\\\"\\\"\";\n     }\n \n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return \" title=\\\"\" + toolTipText",
        "fixed_line": "return \" title=\\\"\" + ImageMapUtilities.htmlEscape(toolTipText)"
    },
    "JacksonDatabind-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements BeanProperty(propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:31.316467547 +0200\n+++ /tmp/tmpignwnmmr.java\t2022-07-12 15:40:31.376467303 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propName);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements BeanProperty) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:33.192459876 +0200\n+++ /tmp/tmp8tp6aqfz.java\t2022-07-12 15:40:33.192459876 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty) {\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements BeanPropertyON_NULL_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:34.696453718 +0200\n+++ /tmp/tmpdsk0u_bm.java\t2022-07-12 15:40:34.700453703 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyON_NULL_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements BeanPropertyHandler) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:36.232447424 +0200\n+++ /tmp/tmpsrgx1l4_.java\t2022-07-12 15:40:36.232447424 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyHandler) {\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements BeanProperty(propDef);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:37.732441275 +0200\n+++ /tmp/tmpxi9pw3xw.java\t2022-07-12 15:40:37.732441275 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty(propDef);\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements BeanProperty '\"+_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:39.244435069 +0200\n+++ /tmp/tmppabzol60.java\t2022-07-12 15:40:39.248435051 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACES;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements BeanProperty '\"+_INTERFACE_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:40.816428610 +0200\n+++ /tmp/tmptyy5seak.java\t2022-07-12 15:40:40.816428610 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACE_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements BeanPropertyHandler;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:42.316422446 +0200\n+++ /tmp/tmpgj0l6x0b.java\t2022-07-12 15:40:42.320422427 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyHandler;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements BeanPropertyIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:43.852416124 +0200\n+++ /tmp/tmpbpia31s8.java\t2022-07-12 15:40:43.852416124 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanPropertyIndex) {\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements BeanProperty '\"+_INTERFACES_FOR_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-26/src/main/java/com/fasterxml/jackson/databind/ser/BeanPropertyWriter.java\t2022-07-12 15:40:45.348409964 +0200\n+++ /tmp/tmpozosf4sx.java\t2022-07-12 15:40:45.352409949 +0200\n@@ -34,11 +34,11 @@\n  * code and this is to reduce likelihood of data corruption and\n  * synchronization issues.\n  */\n @JacksonStdImpl // since 2.6. NOTE: sub-classes typically are not\n public class BeanPropertyWriter extends PropertyWriter\n-    implements BeanProperty\n+implements BeanProperty '\"+_INTERFACES_FOR_EMPTY;\n {\n     // as of 2.6.2\n \n     /**\n      * Marker object used to indicate \"do not serialize if empty\"\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "implements BeanProperty",
        "fixed_line": "implements BeanProperty, java.io.Serializable // since 2.6.2 { // as of 2.6.2 private static final long serialVersionUID = 4603296144163950020L;"
    },
    "Closure-119": {
        "fixes": [
            {
                "k": 1,
                "patch": "isSet = false; type = Name.Type.FUNCTION;",
                "patch_diff": "isSet = false; type = Name.Type.FUNCTION;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "isSet = false; type = Name.Type.FUNCTION; break;",
                "patch_diff": "isSet = false; type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "switch (type = Name.Type.FUNCTION; break;",
                "patch_diff": "switch (type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "else if (type = Name.Type.FUNCTION; break;",
                "patch_diff": "else if (type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "type = Name.Type.FUNCTION; break;",
                "patch_diff": "type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// type = Name.Type.FUNCTION; break;",
                "patch_diff": "// type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return isSet = false; type = Name.Type.FUNCTION;",
                "patch_diff": "return isSet = false; type = Name.Type.FUNCTION;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return isSet = false; type = Name.Type.FUNCTION; break;",
                "patch_diff": "return isSet = false; type = Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "switch (type = t.Type.FUNCTION; break;",
                "patch_diff": "switch (type = t.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "else if (type == Name.Type.FUNCTION; break;",
                "patch_diff": "else if (type == Name.Type.FUNCTION; break;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.CATCH:"
    },
    "Chart-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:40:49.136394343 +0200\n+++ /tmp/tmp6t6dx5ck.java\t2022-07-12 15:40:49.164394229 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues?",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:40:59.040353354 +0200\n+++ /tmp/tmp_ln1exs4.java\t2022-07-12 15:40:59.040353354 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues?\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:00.620346795 +0200\n+++ /tmp/tmp3p22tb2y.java\t2022-07-12 15:41:00.620346795 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues)) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:02.196340246 +0200\n+++ /tmp/tmpqvj5gi9i.java\t2022-07-12 15:41:02.196340246 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues;\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (index >= 0 &&!this.allowDuplicateXValues = {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:03.800333576 +0200\n+++ /tmp/tmpdpd9lksr.java\t2022-07-12 15:41:03.800333576 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.allowDuplicateXValues = {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (index >= 0 ||!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:05.392326950 +0200\n+++ /tmp/tmpdsbb3j2f.java\t2022-07-12 15:41:05.392326950 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 ||!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (index!= 0 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:13.720292206 +0200\n+++ /tmp/tmpa2c7u2ur.java\t2022-07-12 15:41:13.720292206 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index!= 0 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (index >= 0 &&!this.noDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:22.188256729 +0200\n+++ /tmp/tmpfzaf1wm_.java\t2022-07-12 15:41:22.188256729 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 &&!this.noDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (index >= 1 &&!this.allowDuplicateXValues) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:23.940249370 +0200\n+++ /tmp/tmpiuggjs8u.java\t2022-07-12 15:41:23.944249351 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 1 &&!this.allowDuplicateXValues) {\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (index >= 0 ||!this.allowDuplicateXValues?",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-5/source/org/jfree/data/xy/XYSeries.java\t2022-07-12 15:41:32.436213594 +0200\n+++ /tmp/tmpb_9knh64.java\t2022-07-12 15:41:32.436213594 +0200\n@@ -543,11 +543,11 @@\n         }\n \n         // if we get to here, we know that duplicate X values are not permitted\n         XYDataItem overwritten = null;\n         int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n+if (index >= 0 ||!this.allowDuplicateXValues?\n             XYDataItem existing = (XYDataItem) this.data.get(index);\n             try {\n                 overwritten = (XYDataItem) existing.clone();\n             }\n             catch (CloneNotSupportedException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (index >= 0 && !this.allowDuplicateXValues) {",
        "fixed_line": "if (this.allowDuplicateXValues) { add(x, y); return null; } // if we get to here, we know that duplicate X values are not permitted XYDataItem overwritten = null; int index = indexOf(x); if (index >= 0) {"
    },
    "Mockito-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:41:34.384205368 +0200\n+++ /tmp/tmpc3dmxqg9.java\t2022-07-12 15:41:34.540204711 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:41:47.696148968 +0200\n+++ /tmp/tmpkoikjo5w.java\t2022-07-12 15:41:47.696148968 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:41:57.144108725 +0200\n+++ /tmp/tmpilwneejg.java\t2022-07-12 15:41:57.144108725 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:05.236074124 +0200\n+++ /tmp/tmpyck8ar1m.java\t2022-07-12 15:42:05.240074106 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (actualType instanceof actualTypeParameters;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:14.348035009 +0200\n+++ /tmp/tmp85btht3k.java\t2022-07-12 15:42:14.348035009 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (actualType instanceof actualTypeParameters) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:22.432000176 +0200\n+++ /tmp/tmpi0io4us9.java\t2022-07-12 15:42:22.432000176 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (actualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:31.559960703 +0200\n+++ /tmp/tmplj2wm8bz.java\t2022-07-12 15:42:31.559960703 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (actualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (typeualActualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:39.559925984 +0200\n+++ /tmp/tmpfg5bppxg.java\t2022-07-12 15:42:39.559925984 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (typeualActualType instanceof actualTypeArgument;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:47.583891044 +0200\n+++ /tmp/tmp06xkbl_l.java\t2022-07-12 15:42:47.583891044 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (typeualActualType instanceof actualTypeArgument;\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (wantedualActualType instanceof actualTypeParameters.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-8/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\t2022-07-12 15:42:55.719855503 +0200\n+++ /tmp/tmpu4hvrjod.java\t2022-07-12 15:42:55.719855503 +0200\n@@ -74,11 +74,11 @@\n             TypeVariable typeParameter = typeParameters[i];\n             Type actualTypeArgument = actualTypeArguments[i];\n \n             if (actualTypeArgument instanceof WildcardType) {\n                 contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n+} else if (wantedualActualType instanceof actualTypeParameters.class) {\n                 contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n             }\n             // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else {",
        "fixed_line": "} else if (typeParameter != actualTypeArgument) {"
    },
    "Closure-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "!options.skipAllPasses && options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:03.983819287 +0200\n+++ /tmp/tmpaqrfib8m.java\t2022-07-12 15:43:04.051818987 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "!options.skipAllPasses || options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:08.639798829 +0200\n+++ /tmp/tmpsyx3gqcw.java\t2022-07-12 15:43:08.639798829 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "!options.skipAllPasses &&!options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:12.015783975 +0200\n+++ /tmp/tmpnne363de.java\t2022-07-12 15:43:12.019783957 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&!options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "!options.skipAllPasses && options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:15.563768341 +0200\n+++ /tmp/tmpr3qm_i_i.java\t2022-07-12 15:43:15.567768323 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses && options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "!options.skipAllPasses || options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:19.087752793 +0200\n+++ /tmp/tmpsdu5n0cr.java\t2022-07-12 15:43:19.087752793 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "!options.skipAllPasses ||options.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:22.427738039 +0200\n+++ /tmp/tmp25pxq7dk.java\t2022-07-12 15:43:22.427738039 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses ||options.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "!options.skipAllPasses || s.closurePasses) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:25.799723125 +0200\n+++ /tmp/tmpwubmn_w7.java\t2022-07-12 15:43:25.803723105 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses || s.closurePasses) {\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "!options.skipAllPasses &&!options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:29.323707517 +0200\n+++ /tmp/tmpfym3sx9l.java\t2022-07-12 15:43:29.327707499 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&!options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "!options.skipAllPasses ||options.closurePasses;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:32.751692316 +0200\n+++ /tmp/tmp0lozhz9p.java\t2022-07-12 15:43:32.751692316 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses ||options.closurePasses;\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "!options.skipAllPasses &&",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-31/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 15:43:36.263676723 +0200\n+++ /tmp/tmp067ffze4.java\t2022-07-12 15:43:36.263676723 +0200\n@@ -1280,11 +1280,11 @@\n       // Check if inputs need to be rebuilt from modules.\n       boolean staleInputs = false;\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+!options.skipAllPasses &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "!options.skipAllPasses &&",
        "fixed_line": ""
    },
    "JacksonDatabind-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:17.747491094 +0200\n+++ /tmp/tmpiiq73czp.java\t2022-07-12 15:44:17.775490965 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:19.635482581 +0200\n+++ /tmp/tmpuzsso1ey.java\t2022-07-12 15:44:19.635482581 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:21.311475022 +0200\n+++ /tmp/tmpm88tv1ya.java\t2022-07-12 15:44:21.311475022 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:23.039467225 +0200\n+++ /tmp/tmpfahu_mj8.java\t2022-07-12 15:44:23.039467225 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (typeId == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:24.627460057 +0200\n+++ /tmp/tmp6oqf_rej.java\t2022-07-12 15:44:24.627460057 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId == JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:26.283452575 +0200\n+++ /tmp/tmp7aw8h_st.java\t2022-07-12 15:44:26.283452575 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt; add JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (type == JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:27.823445615 +0200\n+++ /tmp/tmp6az5_f6w.java\t2022-07-12 15:44:27.823445615 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (type == JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:29.451438253 +0200\n+++ /tmp/tmpe8gpty9s.java\t2022-07-12 15:44:29.451438253 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (_typeId == JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (typeId!= JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:31.223430236 +0200\n+++ /tmp/tmpthbel6gi.java\t2022-07-12 15:44:31.223430236 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (typeId!= JsonToken.START_OBJECT) { throw ctxt.wrong JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-35/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/AsWrapperTypeDeserializer.java\t2022-07-12 15:44:32.799423101 +0200\n+++ /tmp/tmpyty2e7da.java\t2022-07-12 15:44:32.799423101 +0200\n@@ -84,14 +84,11 @@\n             if (typeId != null) {\n                 return _deserializeWithNativeTypeId(p, ctxt, typeId);\n             }\n         }\n         // first, sanity checks\n-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {\n-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,\n-                    \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName());\n-        }\n+if (_typeId!= JsonToken.START_OBJECT) { throw ctxt: \"need JSON Object to contain As.WRAPPER_OBJECT type information?)\"); }\n             // should always get field name, but just in case...\n             if (p.nextToken() != JsonToken.FIELD_NAME) {\n                 throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,\n                         \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\");\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (p.getCurrentToken() != JsonToken.START_OBJECT) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }",
        "fixed_line": "JsonToken t = p.getCurrentToken(); if (t == JsonToken.START_OBJECT) { // should always get field name, but just in case... if (p.nextToken() != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME, \"need JSON String that contains type id (for subtype of \"+baseTypeName()+\")\"); } } else if (t != JsonToken.FIELD_NAME) { throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT, \"need JSON Object to contain As.WRAPPER_OBJECT type information for class \"+baseTypeName()); }"
    },
    "Closure-56": {
        "fixes": [
            {
                "k": 1,
                "patch": "return js.indexOf('\\n', pos;",
                "patch_diff": "return js.indexOf('\\n', pos;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return js.indexOf('\\n', pos) == -1) {",
                "patch_diff": "return js.indexOf('\\n', pos) == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return js.indexOf('\\n', pos);",
                "patch_diff": "return js.indexOf('\\n', pos);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (js.indexOf('\\n', pos) == -1) {",
                "patch_diff": "} else if (js.indexOf('\\n', pos) == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (js.indexOf('\\n', pos) == -1) {",
                "patch_diff": "if (js.indexOf('\\n', pos) == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return js.indexOf('\\n', pos) == null;",
                "patch_diff": "return js.indexOf('\\n', pos) == null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return js.indexOf('\\n', pos + 1);",
                "patch_diff": "return js.indexOf('\\n', pos + 1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return js.indexOf('\\n', pos) == start;",
                "patch_diff": "return js.indexOf('\\n', pos) == start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return js.indexOf('\\n', pos); }",
                "patch_diff": "return js.indexOf('\\n', pos); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return js.indexOf('\\n', pos)!= -1) {",
                "patch_diff": "return js.indexOf('\\n', pos)!= -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (pos >= js.length()) { return null; } else { return js.substring(pos, js.length()); }"
    },
    "Codec-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(DEFAULT_TABLE_SIZE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:36.191407733 +0200\n+++ /tmp/tmp07w0m496.java\t2022-07-12 15:44:36.227407572 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_TABLE_SIZE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(DEFAULT_MAXIMUM_CACHE_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:37.971399665 +0200\n+++ /tmp/tmpy_arx79d.java\t2022-07-12 15:44:37.971399665 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_CACHE_SIZE);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(DEFAULT_MAXIMUM_CACHE_SIZE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:39.607392245 +0200\n+++ /tmp/tmp5jzliear.java\t2022-07-12 15:44:39.607392245 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_CACHE_SIZE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(DEFAULT_TABLE_SIZE);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:41.131385326 +0200\n+++ /tmp/tmplcgbeb7n.java\t2022-07-12 15:44:41.131385326 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_TABLE_SIZE);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(DEFAULT_MAXIMUM_VALUE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:42.719378116 +0200\n+++ /tmp/tmpkbdirotz.java\t2022-07-12 15:44:42.719378116 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(DEFAULT_MAXIMUM_VALUE;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.true;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:44.231371247 +0200\n+++ /tmp/tmpdeizan8a.java\t2022-07-12 15:44:44.231371247 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this.true;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:45.855363866 +0200\n+++ /tmp/tmp_stk154q.java\t2022-07-12 15:44:45.855363866 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(false;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:48.803350457 +0200\n+++ /tmp/tmp32wqm7p8.java\t2022-07-12 15:44:48.803350457 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(false;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(true;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:50.387343248 +0200\n+++ /tmp/tmp8l3zwpk0.java\t2022-07-12 15:44:50.387343248 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(true;\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-4/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 15:44:51.899336363 +0200\n+++ /tmp/tmp92fztgoc.java\t2022-07-12 15:44:51.899336363 +0200\n@@ -220,11 +220,11 @@\n      * <p>\n      * When decoding all variants are supported.\n      * </p>\n      */\n     public Base64() {\n-        this(false);\n+this(false);\n     }\n \n     /**\n      * Creates a Base64 codec used for decoding (all modes) and encoding in the given URL-safe mode.\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "this(false);",
        "fixed_line": "this(0);"
    },
    "Cli-35": {
        "fixes": [
            {
                "k": 1,
                "patch": "List matchingOpts = new ArrayList<String>();",
                "patch_diff": "List matchingOpts = new ArrayList<String>();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (opt.startsWith(opt) {",
                "patch_diff": "if (opt.startsWith(opt) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return matchingOpts = new ArrayList<String>();",
                "patch_diff": "return matchingOpts = new ArrayList<String>();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (longOpt = longOpts.keySet;",
                "patch_diff": "for (longOpt = longOpts.keySet;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (longOpt = longOpts.keySet()) {",
                "patch_diff": "for (longOpt = longOpts.keySet()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (opt.startsWith(\"/Id) {",
                "patch_diff": "if (opt.startsWith(\"/Id) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (longOpt = longOpts.length;",
                "patch_diff": "for (longOpt = longOpts.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "List matchingOpts = new ArrayList<String>(); }",
                "patch_diff": "List matchingOpts = new ArrayList<String>(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "List<String> matchingOpts = Util.typeSet;",
                "patch_diff": "List<String> matchingOpts = Util.typeSet;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "List<String> matchingOpts = Util.keySet;",
                "patch_diff": "List<String> matchingOpts = Util.keySet;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if(longOpts.keySet().contains(opt)) { return Collections.singletonList(opt); }"
    },
    "Codec-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>>",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:44:56.671314612 +0200\n+++ /tmp/tmp8ymfqmwo.java\t2022-07-12 15:44:56.703314467 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>>\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:44:58.699305362 +0200\n+++ /tmp/tmppui2pwyo.java\t2022-07-12 15:44:58.699305362 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length);\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 162.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:00.395297617 +0200\n+++ /tmp/tmpddq5kgw8.java\t2022-07-12 15:45:00.407297563 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 162.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:01.907290715 +0200\n+++ /tmp/tmp5wopung4.java\t2022-07-12 15:45:01.907290715 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length;\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:03.399283897 +0200\n+++ /tmp/tmp405qf27t.java\t2022-07-12 15:45:03.399283897 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length,\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:04.899277038 +0200\n+++ /tmp/tmp15azcjcx.java\t2022-07-12 15:45:04.899277038 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), cs2.length());\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), Math.max(theta1.length >>>",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:06.479269813 +0200\n+++ /tmp/tmpe78z3_bb.java\t2022-07-12 15:45:06.479269813 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs1, 0, cs2.length(), Math.max(theta1.length >>>\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs1, 0, 0, Math.max(max2, m text2.length())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:08.067262549 +0200\n+++ /tmp/tmpx8dpmgi7.java\t2022-07-12 15:45:08.067262549 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs1, 0, 0, Math.max(max2, m text2.length())) {\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 12.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:09.535255827 +0200\n+++ /tmp/tmpxlb3zitc.java\t2022-07-12 15:45:09.539255811 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length(), Math.max(theta1.length >>> 12.length()));\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-18/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 15:45:11.059248849 +0200\n+++ /tmp/tmpktj1lj_l.java\t2022-07-12 15:45:11.059248849 +0200\n@@ -76,11 +76,11 @@\n             return false;\n         }\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+return CharSequenceUtils.regionMatches(true, false, cs2, 0, cs2.length())) {\n     }\n \n     /**\n      * Calls {@link String#getBytes(Charset)}\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
        "fixed_line": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());"
    },
    "Mockito-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (k instanceof CapturesArguments && k) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:12.747241115 +0200\n+++ /tmp/tmpzee5qu_4.java\t2022-07-12 15:45:12.795240898 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (k >= m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:15.935226499 +0200\n+++ /tmp/tmp3o3c8ueq.java\t2022-07-12 15:45:15.935226499 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k >= m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (k < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:18.275215762 +0200\n+++ /tmp/tmp3kft751y.java\t2022-07-12 15:45:18.279215746 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k < 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (k instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:35.367137124 +0200\n+++ /tmp/tmp5xvegaf2.java\t2022-07-12 15:45:35.367137124 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (k instanceof CapturesArguments && k instanceof CapturesArguments) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:37.607126792 +0200\n+++ /tmp/tmp079f_tmd.java\t2022-07-12 15:45:37.607126792 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k instanceof CapturesArguments) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (k instanceof CapturesArguments && k <= m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:39.843116468 +0200\n+++ /tmp/tmp7845hfk1.java\t2022-07-12 15:45:39.843116468 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k <= m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (k == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:42.055106252 +0200\n+++ /tmp/tmp_2mv0wfm.java\t2022-07-12 15:45:42.055106252 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k == 0) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (k instanceof CapturesArguments && k)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:45:58.851028481 +0200\n+++ /tmp/tmpfqxxshvu.java\t2022-07-12 15:45:58.851028481 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k)) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (k instanceof CapturesArguments && k == m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:46:00.771019566 +0200\n+++ /tmp/tmpg59wxfcr.java\t2022-07-12 15:46:00.775019549 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k == m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (k instanceof CapturesArguments && k < m) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-34/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 15:46:03.207008254 +0200\n+++ /tmp/tmpc7h8o6r9.java\t2022-07-12 15:46:03.211008233 +0200\n@@ -101,11 +101,11 @@\n     }\n \n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (k instanceof CapturesArguments && k < m) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (m instanceof CapturesArguments) {",
        "fixed_line": "if (m instanceof CapturesArguments && i.getArguments().length > k) {"
    },
    "JxPath-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:05.778996303 +0200\n+++ /tmp/tmpqwdxae52.java\t2022-07-12 15:46:05.838996023 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return equalStrings(namespaceURI, nodeNS, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:08.202985027 +0200\n+++ /tmp/tmpebshe_3v.java\t2022-07-12 15:46:08.206985007 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:10.230975589 +0200\n+++ /tmp/tmpo3vxvq3a.java\t2022-07-12 15:46:10.234975573 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return equalStrings(namespaceURI, nodeNS)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:15.074953030 +0200\n+++ /tmp/tmpyij057l6.java\t2022-07-12 15:46:15.074953030 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS)) {\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return equalStrings(namespaceURI, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:16.734945292 +0200\n+++ /tmp/tmp4xv2_xjg.java\t2022-07-12 15:46:16.734945292 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return equalStrings(namespaceURI, nodeNS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:21.334923837 +0200\n+++ /tmp/tmp7g5pauml.java\t2022-07-12 15:46:21.334923837 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return equalStrings(namespaceURI, nodeNS_namespaceURI);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:22.798917001 +0200\n+++ /tmp/tmp5xop_ntn.java\t2022-07-12 15:46:22.802916985 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS_namespaceURI);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return equalStrings(namespaceURI, nodeNSNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:24.774907775 +0200\n+++ /tmp/tmp9gu2zp2a.java\t2022-07-12 15:46:24.778907754 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNSNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS.namespaceURI;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:26.510899662 +0200\n+++ /tmp/tmpztokxl3q.java\t2022-07-12 15:46:26.510899662 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS.namespaceURI;\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return equalStrings(namespaceURI, nodeNS = nodeNS, nodeNS);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-12/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\t2022-07-12 15:46:28.282891379 +0200\n+++ /tmp/tmphu27gmkr.java\t2022-07-12 15:46:28.302891286 +0200\n@@ -103,11 +103,11 @@\n             }\n             if (wildcard\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+return equalStrings(namespaceURI, nodeNS = nodeNS, nodeNS);\n             }\n             return false;\n         }\n         if (test instanceof NodeTypeTest) {\n             int nodeType = node.getNodeType();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return equalStrings(namespaceURI, nodeNS);",
        "fixed_line": "return equalStrings(namespaceURI, nodeNS) || nodeNS == null && equalStrings(testPrefix, getPrefix(node));"
    },
    "Closure-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (var.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:30.498881019 +0200\n+++ /tmp/tmpm9v48g1p.java\t2022-07-12 15:46:30.538880828 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent.isVar; n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:35.662856846 +0200\n+++ /tmp/tmptm_z_jvs.java\t2022-07-12 15:46:35.662856846 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar; n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:39.246840053 +0200\n+++ /tmp/tmpnz1o0me1.java\t2022-07-12 15:46:39.246840053 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (var.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:42.818823304 +0200\n+++ /tmp/tmprbhv5gn9.java\t2022-07-12 15:46:42.818823304 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (scope.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:46.430806350 +0200\n+++ /tmp/tmpev2dlwkt.java\t2022-07-12 15:46:46.434806330 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (scope.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (nots.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:49.962789759 +0200\n+++ /tmp/tmpd7zgpm_i.java\t2022-07-12 15:46:49.962789759 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (nots.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (var.isVar; n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:53.506773098 +0200\n+++ /tmp/tmptjahczlk.java\t2022-07-12 15:46:53.506773098 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (var.isVar; n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (gramps.isVar && n.hasChildren) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:46:57.078756289 +0200\n+++ /tmp/tmp2zwykzoi.java\t2022-07-12 15:46:57.078756289 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (gramps.isVar && n.hasChildren) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (gramps.isVar;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:47:00.482740260 +0200\n+++ /tmp/tmp74tqum9n.java\t2022-07-12 15:47:00.482740260 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (gramps.isVar;\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (parent.isVar()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-24/src/com/google/javascript/jscomp/ScopedAliases.java\t2022-07-12 15:47:04.074723334 +0200\n+++ /tmp/tmp6nr6162p.java\t2022-07-12 15:47:04.074723334 +0200\n@@ -273,28 +273,11 @@\n       Scope scope = t.getScope();\n       for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n         int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n-        }\n-        }\n+if (parent.isVar()) {\n       }\n     }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.isVar()) { if (n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. // Parameters of the scope function also get a BAD_PARAMETERS // error. } else { // TODO(robbyw): Support using locals for private variables. report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString()); } }",
        "fixed_line": "if (parent.isVar() && n.hasChildren() && n.getFirstChild().isQualifiedName()) { String name = n.getString(); Var aliasVar = scope.getVar(name); aliases.put(name, aliasVar); String qualifiedName = aliasVar.getInitialValue().getQualifiedName(); transformation.addAlias(name, qualifiedName); } else if (v.isBleedingFunction()) { // Bleeding functions already get a BAD_PARAMETERS error, so just // do nothing. } else if (parent.getType() == Token.LP) {"
    },
    "Math-96": {
        "fixes": [
            {
                "k": 1,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:09.266698842 +0200\n+++ /tmp/tmp_cibqmuh.java\t2022-07-12 15:47:09.726696668 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:14.322674965 +0200\n+++ /tmp/tmp34pk_qdd.java\t2022-07-12 15:47:14.322674965 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:17.434660252 +0200\n+++ /tmp/tmpw1a755ew.java\t2022-07-12 15:47:17.434660252 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:20.434646065 +0200\n+++ /tmp/tmpe0goz74d.java\t2022-07-12 15:47:20.434646065 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:23.462631732 +0200\n+++ /tmp/tmpsi_oqh3b.java\t2022-07-12 15:47:23.462631732 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:26.278618395 +0200\n+++ /tmp/tmpxq7p5jpt.java\t2022-07-12 15:47:26.406617789 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:29.270604217 +0200\n+++ /tmp/tmp5uqd9g84.java\t2022-07-12 15:47:29.270604217 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits) {\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:31.630593023 +0200\n+++ /tmp/tmp46rksblg.java\t2022-07-12 15:47:31.682592779 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:34.434579723 +0200\n+++ /tmp/tmp2tc2ed6k.java\t2022-07-12 15:47:34.486579479 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits % Double.doubleToRawLongBits) == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-96/src/java/org/apache/commons/math/complex/Complex.java\t2022-07-12 15:47:37.498565177 +0200\n+++ /tmp/tmp8ms54a0c.java\t2022-07-12 15:47:37.550564929 +0200\n@@ -253,11 +253,11 @@\n             try {\n                 Complex rhs = (Complex)other;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits && (Double.doubleToRawLongBits == Double.doubleToRawLongBits;\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()));",
        "fixed_line": "ret = (real == rhs.real) && (imaginary == rhs.imaginary);"
    },
    "Math-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (source.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:40.470551061 +0200\n+++ /tmp/tmp77d4qrsy.java\t2022-07-12 15:47:40.718549885 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (source.substring(startIndexIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:44.706530922 +0200\n+++ /tmp/tmp2pupn88u.java\t2022-07-12 15:47:44.706530922 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndexIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (endIndex.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:48.358513547 +0200\n+++ /tmp/tmp38chmmr4.java\t2022-07-12 15:47:48.426513225 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (startIndex.length) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:52.314494710 +0200\n+++ /tmp/tmpsmcymtfx.java\t2022-07-12 15:47:52.314494710 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex.length) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (source.substring(startIndex);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:56.298475726 +0200\n+++ /tmp/tmpko1r_37i.java\t2022-07-12 15:47:56.298475726 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex);\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (endIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:47:59.654459721 +0200\n+++ /tmp/tmpurntggwu.java\t2022-07-12 15:47:59.658459700 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex < 0) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (startIndex < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:48:03.502441358 +0200\n+++ /tmp/tmp9x60k_7c.java\t2022-07-12 15:48:03.506441339 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex < 0) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (source.substring(startIndex, endIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:48:07.150423936 +0200\n+++ /tmp/tmpoe8qjwyv.java\t2022-07-12 15:48:07.150423936 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (source.substring(startIndex, endIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (startIndex.substring(startIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:48:10.746406750 +0200\n+++ /tmp/tmpvmrf_lf4.java\t2022-07-12 15:48:10.834406337 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (startIndex.substring(startIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (endIndex.substring(startIndexIndex) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-101/src/java/org/apache/commons/math/complex/ComplexFormat.java\t2022-07-12 15:48:14.470388940 +0200\n+++ /tmp/tmp_tcrc830.java\t2022-07-12 15:48:14.470388940 +0200\n@@ -372,11 +372,11 @@\n \n         // parse imaginary character\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+if (endIndex.substring(startIndexIndex) {\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index\n             // character examined.\n             pos.setIndex(initialIndex);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (",
        "fixed_line": "if ((startIndex >= source.length()) || (endIndex > source.length()) ||"
    },
    "Math-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:48:18.602369166 +0200\n+++ /tmp/tmpxo05_1_g.java\t2022-07-12 15:48:19.478364971 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:49:14.014102488 +0200\n+++ /tmp/tmp5ojd54d4.java\t2022-07-12 15:49:14.014102488 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:50:00.409877246 +0200\n+++ /tmp/tmplx_pd7j6.java\t2022-07-12 15:50:00.409877246 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:50:46.957649642 +0200\n+++ /tmp/tmp3_fkzdnv.java\t2022-07-12 15:50:46.957649642 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:51:33.725419464 +0200\n+++ /tmp/tmpowe2l51m.java\t2022-07-12 15:51:33.725419464 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:52:20.481187976 +0200\n+++ /tmp/tmp_9m342ps.java\t2022-07-12 15:52:20.481187976 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:53:07.172955556 +0200\n+++ /tmp/tmpkxjeuvqk.java\t2022-07-12 15:53:07.172955556 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:53:53.576723443 +0200\n+++ /tmp/tmpn2s2e7lw.java\t2022-07-12 15:53:53.580723424 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:54:39.892490750 +0200\n+++ /tmp/tmpvcl7hsp6.java\t2022-07-12 15:54:39.892490750 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnotnotnotnotnotnotnotnotnotnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-12/src/main/java/org/apache/commons/math3/random/BitsStreamGenerator.java\t2022-07-12 15:55:27.012253056 +0200\n+++ /tmp/tmp0e0v6i1j.java\t2022-07-12 15:55:27.012253056 +0200\n@@ -24,11 +24,11 @@\n  *\n  * @version $Id$\n  * @since 2.0\n  */\n public abstract class BitsStreamGenerator\n-    implements RandomGenerator {\n+implements RandomGenerator { // 1; // we didn't really modify it's totalGJACKSON-notnot real number\n     /** Serializable version identifier */\n     /** Next gaussian. */\n     private double nextGaussian;\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "implements RandomGenerator {",
        "fixed_line": "import java.io.Serializable; import org.apache.commons.math3.exception.NotStrictlyPositiveException; import org.apache.commons.math3.util.FastMath; /** Base class for random number generators that generates bits streams. * * @version $Id$ * @since 2.0 */ public abstract class BitsStreamGenerator implements RandomGenerator, Serializable { /** Serializable version identifier */ private static final long serialVersionUID = 20130104L;"
    },
    "Time-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (months % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:14.316013546 +0200\n+++ /tmp/tmpiml2rue2.java\t2022-07-12 15:56:14.440012918 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (months % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (months % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:16.348003242 +0200\n+++ /tmp/tmpebfsnqll.java\t2022-07-12 15:56:16.360003180 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (months % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (years % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:17.851995611 +0200\n+++ /tmp/tmp4zii15bd.java\t2022-07-12 15:56:17.851995611 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (years % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years % 12!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:19.387987820 +0200\n+++ /tmp/tmpjp6bon_a.java\t2022-07-12 15:56:19.387987820 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years % 12!= 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (months % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:21.003979621 +0200\n+++ /tmp/tmpol269ext.java\t2022-07-12 15:56:21.003979621 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (months % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "years = FieldUtils.safeAdd(years, months / 12; if (years % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:22.515971946 +0200\n+++ /tmp/tmpr7zve550.java\t2022-07-12 15:56:22.519971927 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12; if (years % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (months % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:24.063964091 +0200\n+++ /tmp/tmpfgchb9jg.java\t2022-07-12 15:56:24.067964069 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (months % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "years = FieldUtils.safeAdd(years, months % 12; if (years % 12 == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:25.555956516 +0200\n+++ /tmp/tmph7cf6maf.java\t2022-07-12 15:56:25.559956498 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12; if (years % 12 == 0) {\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "years = FieldUtils.safeAdd(years, months % 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:27.119948578 +0200\n+++ /tmp/tmpy4r3w9ul.java\t2022-07-12 15:56:27.123948556 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months % 12;\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "years = FieldUtils.safeAdd(years, months / 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-5/src/main/java/org/joda/time/Period.java\t2022-07-12 15:56:28.607941024 +0200\n+++ /tmp/tmpfsbfzy3e.java\t2022-07-12 15:56:28.611941002 +0200\n@@ -1623,17 +1623,11 @@\n         millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n         Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n         int years = getYears();\n         int months = getMonths();\n         if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+years = FieldUtils.safeAdd(years, months / 12;\n             }\n         }\n         return result;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "years = FieldUtils.safeAdd(years, months / 12); months = months % 12; if (years != 0) { result = result.withYears(years); } if (months != 0) { result = result.withMonths(months);",
        "fixed_line": "long totalMonths = years * 12L + months; if (type.isSupported(DurationFieldType.YEARS_TYPE)) { int normalizedYears = FieldUtils.safeToInt(totalMonths / 12); result = result.withYears(normalizedYears); totalMonths = totalMonths - (normalizedYears * 12); } if (type.isSupported(DurationFieldType.MONTHS_TYPE)) { int normalizedMonths = FieldUtils.safeToInt(totalMonths); result = result.withMonths(normalizedMonths); totalMonths = totalMonths - normalizedMonths; } if (totalMonths != 0) { throw new UnsupportedOperationException(\"Unable to normalize as PeriodType is missing either years or months but period has a month/year amount: \" + toString());"
    },
    "Closure-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "String param = params.getParameter(1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:56:30.235932757 +0200\n+++ /tmp/tmpyrq0cmmb.java\t2022-07-12 15:56:30.259932636 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(1);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "String param = params.getParameterList;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:01.347774614 +0200\n+++ /tmp/tmp0cr42cp6.java\t2022-07-12 15:57:01.347774614 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterList;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "String param = params.getParametering;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:04.139760408 +0200\n+++ /tmp/tmp6wwyizqn.java\t2022-07-12 15:57:04.139760408 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParametering;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "String param = params.getParameter am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:06.883746441 +0200\n+++ /tmp/tmppd5otqf5.java\t2022-07-12 15:57:06.887746423 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter am;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "String param = params.getParameterWriter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:09.403733614 +0200\n+++ /tmp/tmpntikk8v5.java\t2022-07-12 15:57:09.403733614 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterWriter;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "String param = params.getParameterTypes;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:12.123719764 +0200\n+++ /tmp/tmp9db63e1s.java\t2022-07-12 15:57:12.123719764 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterTypes;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "String param = params.getParameterVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:14.879705730 +0200\n+++ /tmp/tmp2nkhm0gm.java\t2022-07-12 15:57:14.883705712 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterVal;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "String param = params.getParameter(0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:17.615691796 +0200\n+++ /tmp/tmpiwgyuc3m.java\t2022-07-12 15:57:17.615691796 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter(0);\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "String param = params.getParameter;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:46.507544502 +0200\n+++ /tmp/tmp1ki5g09l.java\t2022-07-12 15:57:46.511544484 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameter;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "String param = params.getParameterString;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-83/src/com/google/javascript/jscomp/CommandLineRunner.java\t2022-07-12 15:57:49.343530032 +0200\n+++ /tmp/tmpxz48viey.java\t2022-07-12 15:57:49.343530032 +0200\n@@ -329,11 +329,11 @@\n         super(parser, option, setter);\n       }\n \n       @Override\n       public int parseArguments(Parameters params) throws CmdLineException {\n-        String param = params.getParameter(0);\n+String param = params.getParameterString;\n \n         if (param == null) {\n           setter.addValue(true);\n           return 0;\n         } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "String param = params.getParameter(0);",
        "fixed_line": "String param = null; try { param = params.getParameter(0); } catch (CmdLineException e) {}"
    },
    "Cli-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "tokens.add(tokenPropertyAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:57:52.227515313 +0200\n+++ /tmp/tmpu2jpfyua.java\t2022-07-12 15:57:52.251515191 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokenPropertyAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tokens.add(token; if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:57:54.059505962 +0200\n+++ /tmp/tmpwmhfjc_1.java\t2022-07-12 15:57:54.059505962 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tokens.add(token); } else if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:57:55.507498570 +0200\n+++ /tmp/tmp8fgo0aa3.java\t2022-07-12 15:57:55.507498570 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tokens.add(token); } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:57:57.151490176 +0200\n+++ /tmp/tmpbhodwzxd.java\t2022-07-12 15:57:57.151490176 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token); } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tokens.add(token; } else if (stopAtNonOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:57:59.751476901 +0200\n+++ /tmp/tmpw7ofvajy.java\t2022-07-12 15:57:59.751476901 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; } else if (stopAtNonOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tokens.add(token; } else if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:58:01.227469361 +0200\n+++ /tmp/tmpcn8sx17o.java\t2022-07-12 15:58:01.231469343 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; } else if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tokens.add(token; if (tokentokenIncompleteOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:58:02.627462211 +0200\n+++ /tmp/tmp4srcdhv2.java\t2022-07-12 15:58:02.627462211 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token; if (tokentokenIncompleteOption) {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tokens.add(tokentokenIncompleteOption = false;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:58:04.131454530 +0200\n+++ /tmp/tmpz1gaco3v.java\t2022-07-12 15:58:04.135454511 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokentokenIncompleteOption = false;\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tokens.add(tokenLen =stopAtNonOption; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:58:05.715446440 +0200\n+++ /tmp/tmpnmt_h9u3.java\t2022-07-12 15:58:05.715446440 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(tokenLen =stopAtNonOption; {\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tokens.add(token;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-19/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 15:58:07.231438696 +0200\n+++ /tmp/tmpi5690job.java\t2022-07-12 15:58:07.231438696 +0200\n@@ -227,16 +227,11 @@\n     private void processOptionToken(String token, boolean stopAtNonOption)\n     {\n         if (options.hasOption(token))\n         {\n             currentOption = options.getOption(token);\n-            tokens.add(token);\n-        }\n-        else if (stopAtNonOption)\n-        {\n-            eatTheRest = true;\n-            tokens.add(token);\n+tokens.add(token;\n         }\n     }\n \n     /**\n      * <p>Breaks <code>token</code> into its constituent parts\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tokens.add(token); } else if (stopAtNonOption) { eatTheRest = true; tokens.add(token);",
        "fixed_line": "tokens.add(token);"
    },
    "Closure-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c >= 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 15:58:08.855430398 +0200\n+++ /tmp/tmp5rzhahve.java\t2022-07-12 15:58:08.879430276 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c >= 0x0f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 15:58:44.447248377 +0200\n+++ /tmp/tmp_crnoupe.java\t2022-07-12 15:58:44.451248355 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x0f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c > 0x1f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 15:59:15.959086935 +0200\n+++ /tmp/tmp59_tvqjt.java\t2022-07-12 15:59:15.959086935 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c > 0x1f && c!= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 15:59:48.014922447 +0200\n+++ /tmp/tmpjqrenjm3.java\t2022-07-12 15:59:48.018922424 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c!= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c > 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:00:19.690759668 +0200\n+++ /tmp/tmp616gtd3g.java\t2022-07-12 16:00:19.690759668 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (c >= 0x1f || c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:00:51.566595636 +0200\n+++ /tmp/tmp_zj1q41f.java\t2022-07-12 16:00:51.570595615 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f || c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0x1f || c > 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:01:23.510431038 +0200\n+++ /tmp/tmp141juq45.java\t2022-07-12 16:01:23.514431015 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c < 0x1f || c > 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c >= 0x1f && c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:01:55.206267516 +0200\n+++ /tmp/tmpxs4xawx9.java\t2022-07-12 16:01:55.206267516 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c >= 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 9,
                "patch": "if (c > 0x0f && c <= 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:02:27.154102511 +0200\n+++ /tmp/tmp97clq376.java\t2022-07-12 16:02:27.154102511 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x0f && c <= 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c > 0x1f || c < 0x7f) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-73/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:02:59.449935524 +0200\n+++ /tmp/tmp1ls8df5b.java\t2022-07-12 16:02:59.449935524 +0200\n@@ -1040,11 +1040,11 @@\n             }\n           } else {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+if (c > 0x1f || c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,\n               // or perhaps mangled by proxies along the way,\n               // so we play it safe and unicode escape them.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (c > 0x1f && c <= 0x7f) {",
        "fixed_line": "if (c > 0x1f && c < 0x7f) {"
    },
    "Closure-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (function.google.is removing) {",
                "patch_diff": "if (function.google.is removing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (function.google.com/site) {",
                "patch_diff": "if (function.google.com/site) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (function.is removing) {",
                "patch_diff": "if (function.is removing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (function.is removing()) {",
                "patch_diff": "if (function.is removing()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (function.google.is removing()) {",
                "patch_diff": "if (function.google.is removing()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (function == null) {",
                "patch_diff": "if (function == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (function.google.is removing;",
                "patch_diff": "if (function.google.is removing;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (function.google.com/)))) {",
                "patch_diff": "if (function.google.com/)))) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (function.google.com/p) {",
                "patch_diff": "if (function.google.com/p) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (info.google.is removing) {",
                "patch_diff": "if (info.google.is removing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!removeGlobals) { return; }"
    },
    "Closure-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:03:33.101761344 +0200\n+++ /tmp/tmpptlecl34.java\t2022-07-12 16:03:33.161761035 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (parent.getJSType()!= null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:03:38.317734331 +0200\n+++ /tmp/tmp_ffnlaes.java\t2022-07-12 16:03:38.317734331 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (parent.getJSType() == null && parent.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:03:41.897715789 +0200\n+++ /tmp/tmpizb3vgad.java\t2022-07-12 16:03:41.897715789 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && parent.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "} else if (parent.getJSType() == null && objNode.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:04:31.117460658 +0200\n+++ /tmp/tmp9r2jdoe0.java\t2022-07-12 16:04:31.117460658 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && objNode.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "} else if (parent.getJSType()!= null && childType.isAssign()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:17.465220110 +0200\n+++ /tmp/tmp3tviayjh.java\t2022-07-12 16:05:17.465220110 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType.isAssign()) {\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:21.009201707 +0200\n+++ /tmp/tmpzolyfpgr.java\t2022-07-12 16:05:21.013201686 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) {\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (parent.isJSType() == null && childType.isAssign()) { return;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:24.637182863 +0200\n+++ /tmp/tmp6n90de7n.java\t2022-07-12 16:05:24.637182863 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.isJSType() == null && childType.isAssign()) { return;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (parent.getJSType() == null && childType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:28.161164560 +0200\n+++ /tmp/tmpicu6j72x.java\t2022-07-12 16:05:28.161164560 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (parent.getJSType()!= null && childType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:31.529147065 +0200\n+++ /tmp/tmpnp3kojy8.java\t2022-07-12 16:05:31.533147043 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType()!= null && childType;\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (parent.getJSType() == null && childType.isAssign()) { return; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-11/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 16:05:34.993129069 +0200\n+++ /tmp/tmp_1r_gmag.java\t2022-07-12 16:05:34.993129069 +0200\n@@ -1309,12 +1309,11 @@\n     Node objNode = n.getFirstChild();\n     JSType childType = getJSType(objNode);\n \n     if (childType.isDict()) {\n       report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n-    } else if (n.getJSType() != null && parent.isAssign()) {\n-      return;\n+} else if (parent.getJSType() == null && childType.isAssign()) { return; }\n     } else if (validator.expectNotNullOrUndefined(t, n, childType,\n         \"No properties on this expression\", getNativeType(OBJECT_TYPE))) {\n       checkPropertyAccess(childType, property.getString(), t, n);\n     }\n     ensureTyped(t, n);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (n.getJSType() != null && parent.isAssign()) { return;",
        "fixed_line": ""
    },
    "Jsoup-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:38.673109948 +0200\n+++ /tmp/tmpbdauh_sk.java\t2022-07-12 16:05:38.705109785 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ensure\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:42.089092201 +0200\n+++ /tmp/tmpztzalzyj.java\t2022-07-12 16:05:42.093092179 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+ determine\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:44.737078441 +0200\n+++ /tmp/tmpbb_1wkvd.java\t2022-07-12 16:05:44.737078441 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Static\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:47.353064848 +0200\n+++ /tmp/tmpkeil8iz7.java\t2022-07-12 16:05:47.353064848 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child);\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:48.821057218 +0200\n+++ /tmp/tmpmvzxhh7b.java\t2022-07-12 16:05:48.825057197 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+Child\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:51.369043976 +0200\n+++ /tmp/tmpkqg623rg.java\t2022-07-12 16:05:51.369043976 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+ determine\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:53.913030755 +0200\n+++ /tmp/tmpayls2yhy.java\t2022-07-12 16:05:53.917030734 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+ determine\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:56.621016681 +0200\n+++ /tmp/tmp4byqmjrt.java\t2022-07-12 16:05:56.621016681 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+';\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:05:58.325007824 +0200\n+++ /tmp/tmp_p8k6511.java\t2022-07-12 16:05:58.325007824 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|[a-Z]+country\");\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-9/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:06:00.748995224 +0200\n+++ /tmp/tmpwle_rp4o.java\t2022-07-12 16:06:00.752995203 +0200\n@@ -33,11 +33,11 @@\n \n     private static final Map<String, Character> full;\n     private static final Map<Character, String> xhtmlByVal;\n     private static final Map<Character, String> baseByVal;\n     private static final Map<Character, String> fullByVal;\n-    private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");\n+private static final Pattern unescapePattern = Pattern.compile(\"a-fA-F]+)|-Z]+';\n \n     static String escape(String string, Document.OutputSettings out) {\n         return escape(string, out.encoder(), out.escapeMode());\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\");",
        "fixed_line": "private static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");"
    },
    "Math-88": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (checkRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:02.496986136 +0200\n+++ /tmp/tmp9h2xz7_b.java\t2022-07-12 16:06:02.532985951 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (checkRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (basicRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:05.168972246 +0200\n+++ /tmp/tmpmzhisv1t.java\t2022-07-12 16:06:05.168972246 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basicRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (coefficients == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:11.972936870 +0200\n+++ /tmp/tmp9n0ylkyw.java\t2022-07-12 16:06:11.972936870 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (coefficients == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (checkRow!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:18.228904341 +0200\n+++ /tmp/tmpk2cofjq6.java\t2022-07-12 16:06:18.232904319 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (checkRow!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (basic == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:20.408893005 +0200\n+++ /tmp/tmpfsvnxvte.java\t2022-07-12 16:06:20.408893005 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (basic == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if ( 20,Row == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:22.564881791 +0200\n+++ /tmp/tmp5ojij3hq.java\t2022-07-12 16:06:22.564881791 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if ( 20,Row == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (isRow!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:24.592871244 +0200\n+++ /tmp/tmpykdbwzek.java\t2022-07-12 16:06:24.592871244 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (isRow!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:26.776859886 +0200\n+++ /tmp/tmp8mj8yuu2.java\t2022-07-12 16:06:26.780859865 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (c == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (isRow == null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:29.024848194 +0200\n+++ /tmp/tmpwgdw392j.java\t2022-07-12 16:06:29.024848194 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (isRow == null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-88/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:06:31.088837458 +0200\n+++ /tmp/tmps6y3jq5j.java\t2022-07-12 16:06:31.088837458 +0200\n@@ -331,16 +331,11 @@\n                 // if multiple variables can take a given value \n                 // then we choose the first and set the rest equal to 0\n                 coefficients[i] =\n                     (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                     (restrictToNonNegative ? 0 : mostNegative);\n-            if (basicRow != null) {\n-                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n-                    if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n-                    }\n-                }\n+if (c!= null) {\n             }\n         }\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRow != null) { for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) { if (tableau.getEntry(basicRow, j) == 1) { coefficients[i] = 0; } }",
        "fixed_line": "Set<Integer> basicRows = new HashSet<Integer>(); for (int i = 0; i < coefficients.length; i++) { basicRow = getBasicRow(getNumObjectiveFunctions() + i); if (basicRows.contains(basicRow)) { // if multiple variables can take a given value // then we choose the first and set the rest equal to 0 coefficients[i] = 0; } else { basicRows.add(basicRow);"
    },
    "Time-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:33.456825142 +0200\n+++ /tmp/tmpj68hfbm0.java\t2022-07-12 16:06:33.480825015 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:35.680813569 +0200\n+++ /tmp/tmp8ypcaq9g.java\t2022-07-12 16:06:35.684813550 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "instantLocal, chrono, iLocale, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:37.412804561 +0200\n+++ /tmp/tmpaucgpin7.java\t2022-07-12 16:06:37.412804561 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:49.736740440 +0200\n+++ /tmp/tmpz23ytf8b.java\t2022-07-12 16:06:49.736740440 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:51.984728742 +0200\n+++ /tmp/tmpklbbkg3f.java\t2022-07-12 16:06:51.988728721 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = position;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:54.700714607 +0200\n+++ /tmp/tmpfpym7ma_.java\t2022-07-12 16:06:54.760714297 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = position;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "instantLocal, chrono, iLocale, iPivotYear;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:06:58.040697224 +0200\n+++ /tmp/tmpjvh_3l2f.java\t2022-07-12 16:06:59.056691936 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:07:03.092670932 +0200\n+++ /tmp/tmpw6pehcyz.java\t2022-07-12 16:07:03.196670390 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear = chrono.iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:07:05.900656315 +0200\n+++ /tmp/tmpoa3ic3ri.java\t2022-07-12 16:07:05.900656315 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear, iPivotYear, iPivotYear);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "instantLocal, chrono, iLocale, iPivotYear) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-16/src/main/java/org/joda/time/format/DateTimeFormatter.java\t2022-07-12 16:07:07.992645426 +0200\n+++ /tmp/tmpbtwdz1lu.java\t2022-07-12 16:07:07.992645426 +0200\n@@ -704,11 +704,11 @@\n         Chronology chrono = instant.getChronology();\n         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+instantLocal, chrono, iLocale, iPivotYear) - 1;\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
        "fixed_line": "instantLocal, chrono, iLocale, iPivotYear, chrono.year().get(instantLocal));"
    },
    "Closure-172": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName == null || qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (qName!= null && qName.endsWith(\".prototype) {",
                "patch_diff": "if (qName!= null && qName.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (info.endsWith(\".prototype\")) {",
                "patch_diff": "if (info.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (qName == null || qName.endsWith(\".prototype) {",
                "patch_diff": "if (qName == null || qName.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (qName!= null && inferred.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName!= null && inferred.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (qName == null && qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (qName == null && qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (info == null || qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (info == null || qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (qName!= null && inferred.endsWith(\".prototype) {",
                "patch_diff": "if (qName!= null && inferred.endsWith(\".prototype) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == null || qName.endsWith(\".prototype\")) {",
                "patch_diff": "if (type == null || qName.endsWith(\".prototype\")) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "String className = qName.substring(0, qName.lastIndexOf(\".prototype\")); Var slot = scope.getSlot(className); JSType classType = slot == null ? null : slot.getType(); if (classType != null && (classType.isConstructor() || classType.isInterface())) { return false; }"
    },
    "JacksonDatabind-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "return _defaultContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:12.764620584 +0200\n+++ /tmp/tmpksqbh2ez.java\t2022-07-12 16:07:13.016619271 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _valueInstantiator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:16.460601343 +0200\n+++ /tmp/tmpi_27m3zp.java\t2022-07-12 16:07:16.464601322 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _valueInstantiator;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _defaultContextualValueDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:19.576585120 +0200\n+++ /tmp/tmph6cw40kp.java\t2022-07-12 16:07:19.576585120 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueDeserializer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _objectIdReader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:22.828568187 +0200\n+++ /tmp/tmp381mqaj1.java\t2022-07-12 16:07:22.844568104 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _objectIdReader;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _defaultValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:25.636553566 +0200\n+++ /tmp/tmpfjuo1ms6.java\t2022-07-12 16:07:25.636553566 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _defaultValueDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:28.596538152 +0200\n+++ /tmp/tmpvt5u31br.java\t2022-07-12 16:07:28.596538152 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultValueDeserializer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _defaultImpl;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:31.616522425 +0200\n+++ /tmp/tmptize_phn.java\t2022-07-12 16:07:31.616522425 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultImpl;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return _defaultDeserializer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:34.112509425 +0200\n+++ /tmp/tmppdk726pc.java\t2022-07-12 16:07:34.112509425 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultDeserializer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _defaultContextualValueDeserializationContextualValueSer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:36.788495489 +0200\n+++ /tmp/tmprwbfe_8f.java\t2022-07-12 16:07:36.788495489 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContextualValueDeserializationContextualValueSer;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return _defaultContext;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-107/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\t2022-07-12 16:07:39.892479321 +0200\n+++ /tmp/tmp3kx1sc1u.java\t2022-07-12 16:07:39.892479321 +0200\n@@ -160,11 +160,11 @@\n                 if (deser == null) {\n                     // 10-May-2016, tatu: We may get some help...\n                     JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                     if (actual == null) { // what should this be taken to mean?\n                         // 17-Jan-2019, tatu: As per [databind#2221], better NOT return `null` but...\n-                        return null;\n+return _defaultContext;\n                     }\n                     // ... would this actually work?\n                     deser = ctxt.findContextualValueDeserializer(actual, _property);\n                 }\n             } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return null;",
        "fixed_line": "return NullifyingDeserializer.instance;"
    },
    "JacksonCore-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == TYPE_ARRAY || _currToken == JsonToken.FIELD_NAME) {",
                "patch_diff": "if (type == TYPE_ARRAY || _currToken == JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return _currToken == JsonToken.VALUE_NUMBER_INT || _currToken == JsonToken.FIELD_NAME;",
                "patch_diff": "return _currToken == JsonToken.VALUE_NUMBER_INT || _currToken == JsonToken.FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (_currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "patch_diff": "} else if (_currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return _currToken = JsonToken.VALUE_NUMBER_INT;",
                "patch_diff": "return _currToken = JsonToken.VALUE_NUMBER_INT;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return _currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "patch_diff": "return _currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _currToken = JsonToken.FIELD_NAME;",
                "patch_diff": "return _currToken = JsonToken.FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "patch_diff": "if (_currToken == JsonToken.FIELD_NAME && _currToken!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type == TYPE_ARRAY || _currToken == JsonToken.FIELD_NAME;",
                "patch_diff": "if (type == TYPE_ARRAY || _currToken == JsonToken.FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return _currToken == JsonToken.FIELD_NAME && _currToken!= JsonToken.FIELD_NAME;",
                "patch_diff": "return _currToken == JsonToken.FIELD_NAME && _currToken!= JsonToken.FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_currToken == JsonToken.FIELD_NAME && _currToken!= JsonToken.FIELD_NAME) {",
                "patch_diff": "if (_currToken == JsonToken.FIELD_NAME && _currToken!= JsonToken.FIELD_NAME) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_includePath) { if (_currToken.isStructEnd()) { if (_headContext.isStartHandled()) { return (_currToken = null); } } else if (_currToken.isScalarValue()) { //else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once // then return null if (!_headContext.isStartHandled() && (_itemFilter == TokenFilter.INCLUDE_ALL)) { return (_currToken = null); } }"
    },
    "JacksonDatabind-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "patch_diff": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "patch_diff": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _deserialize(jp, ctxt, tatu: Simple skipping;",
                "patch_diff": "return _deserialize(jp, ctxt, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens,",
                "patch_diff": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens,",
                "patch_diff": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return _deserialize(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "patch_diff": "return _deserialize(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _deserialize(jp, ctxt, tatu: Simple skipping for all other tokens;",
                "patch_diff": "return _deserialize(jp, ctxt, tatu: Simple skipping for all other tokens;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME",
                "patch_diff": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME",
                "patch_diff": "private Object deserializeWithType(jp, ctxt, tatu: Simple skipping for all other tokens, but FIELD_NAME",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping;",
                "patch_diff": "Object deserializeWithType(jp, ctxt, tatu: Simple skipping;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (p.hasToken(JsonToken.FIELD_NAME)) { while (true) { JsonToken t = p.nextToken(); if ((t == null) || (t == JsonToken.END_OBJECT)) { break; } p.skipChildren(); } } else { p.skipChildren(); }"
    },
    "Math-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] operand = {",
                "patch_diff": "private static final /*day*/int[] operand = {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] operand) {",
                "patch_diff": "private static final /*day*/int[] operand) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// value to take special cases (+0/+0, +0/-0, -0/;",
                "patch_diff": "// value to take special cases (+0/+0, +0/-0, -0/;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/;",
                "patch_diff": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/;",
                "patch_diff": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, - '+';",
                "patch_diff": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, - '+';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/-0, - '+';",
                "patch_diff": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/-0, - '+';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "patch_diff": "// parameter value to take special cases(+string+0, +0/-0, -0/-0, -0/-0,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// value to take special cases (+0/+0, +0/-0, -0/).util.checkState(text);",
                "patch_diff": "// value to take special cases (+0/+0, +0/-0, -0/).util.checkState(text);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, -0/;",
                "patch_diff": "// value to take special cases (+0/+0, +0/-0, -0/-0, -0/-0, -0/;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "result[resultOffset] = FastMath.atan2(y[yOffset], x[xOffset]);"
    },
    "Math-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (basic.contains(unmodifiableNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:07:49.728428086 +0200\n+++ /tmp/tmp2h9lft5l.java\t2022-07-12 16:07:50.088426211 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(unmodifiableNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (basic.contains(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:07:54.756401892 +0200\n+++ /tmp/tmp1m9ccnmv.java\t2022-07-12 16:07:54.864401330 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(value) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (basicRows.contains(unmodifiableNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:07:57.928385366 +0200\n+++ /tmp/tmp0y984dd7.java\t2022-07-12 16:07:57.944385281 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(unmodifiableNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (basic.contains(numNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:00.828370255 +0200\n+++ /tmp/tmpok7en668.java\t2022-07-12 16:08:00.856370109 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(numNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (basicRows.contains(value) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:03.568355977 +0200\n+++ /tmp/tmpnonlcpuk.java\t2022-07-12 16:08:03.568355977 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(value) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (basic.contains(cDefault) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:06.536340512 +0200\n+++ /tmp/tmpkma07iah.java\t2022-07-12 16:08:06.580340283 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(cDefault) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (basicRows.contains(numNegative) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:09.404325566 +0200\n+++ /tmp/tmpmc0vj20p.java\t2022-07-12 16:08:09.404325566 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(numNegative) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (basic.contains(o) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:12.508309390 +0200\n+++ /tmp/tmpxj5q92hu.java\t2022-07-12 16:08:12.512309369 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basic.contains(o) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (basicRows.contains(cDefault) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:15.360294526 +0200\n+++ /tmp/tmp87jx8aiu.java\t2022-07-12 16:08:15.360294526 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(cDefault) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (basicRows.contains(o) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-42/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 16:08:18.716277034 +0200\n+++ /tmp/tmpexyat3l9.java\t2022-07-12 16:08:18.716277034 +0200\n@@ -408,11 +408,11 @@\n           }\n           Integer basicRow = getBasicRow(colIndex);\n               // if the basic row is found to be the objective function row\n               // set the coefficient to 0 -> this case handles unconstrained \n               // variables that are still part of the objective function\n-          if (basicRows.contains(basicRow)) {\n+if (basicRows.contains(o) {\n               // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n           } else {\n               basicRows.add(basicRow);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (basicRows.contains(basicRow)) {",
        "fixed_line": "if (basicRow != null && basicRow == 0) { // if the basic row is found to be the objective function row // set the coefficient to 0 -> this case handles unconstrained // variables that are still part of the objective function coefficients[i] = 0; } else if (basicRows.contains(basicRow)) {"
    },
    "Closure-146": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new TypePair(this.d, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:22.360258042 +0200\n+++ /tmp/tmppty9wpsn.java\t2022-07-12 16:08:22.420257729 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.d, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new TypePair(this.null, that.testForEquality);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:24.512246824 +0200\n+++ /tmp/tmp320qq4pk.java\t2022-07-12 16:08:24.512246824 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.testForEquality);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new TypePair(this.testClass, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:26.080238652 +0200\n+++ /tmp/tmpjnvok0i0.java\t2022-07-12 16:08:26.080238652 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testClass, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new TypePair(this.null, that.millisecond);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:27.728230061 +0200\n+++ /tmp/tmpv88yvbv0.java\t2022-07-12 16:08:27.728230061 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.millisecond);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new TypePair(this.parameters, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:29.324221740 +0200\n+++ /tmp/tmp1z7hcp3u.java\t2022-07-12 16:08:29.328221718 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.parameters, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new TypePair(this.testForEquality, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:30.992213045 +0200\n+++ /tmp/tmpv4fznze5.java\t2022-07-12 16:08:30.992213045 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.testForEquality, null);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new TypePair(this.null, that.clazz;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:32.632204496 +0200\n+++ /tmp/tmpumh46t4m.java\t2022-07-12 16:08:32.636204475 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.clazz;\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new TypePair(this.null, that.iPair);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:34.220196215 +0200\n+++ /tmp/tmpnw_9139q.java\t2022-07-12 16:08:34.220196215 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.iPair);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new TypePair(this.null, that.testClass);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:35.712188438 +0200\n+++ /tmp/tmpjso1hh8l.java\t2022-07-12 16:08:35.712188438 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.null, that.testClass);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new TypePair(this.d, that.testForEquality);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-146/src/com/google/javascript/rhino/jstype/JSType.java\t2022-07-12 16:08:37.300180159 +0200\n+++ /tmp/tmphcfqs2fh.java\t2022-07-12 16:08:37.300180159 +0200\n@@ -701,11 +701,11 @@\n     }\n \n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+return new TypePair(this.d, that.testForEquality);\n \n       case FALSE:\n       case UNKNOWN:\n         return new TypePair(this, that);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new TypePair(null, null);",
        "fixed_line": "JSType noType = getNativeType(JSTypeNative.NO_TYPE); return new TypePair(noType, noType);"
    },
    "Lang-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:39.196170273 +0200\n+++ /tmp/tmpc6d8dgj_.java\t2022-07-12 16:08:39.232170086 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:41.024160742 +0200\n+++ /tmp/tmpx_rjbv2_.java\t2022-07-12 16:08:41.028160721 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return locale.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:42.528152898 +0200\n+++ /tmp/tmpuev6g_dv.java\t2022-07-12 16:08:42.528152898 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return locale.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:44.052144954 +0200\n+++ /tmp/tmpnvo81woh.java\t2022-07-12 16:08:44.052144954 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:45.560137091 +0200\n+++ /tmp/tmp8zi11acd.java\t2022-07-12 16:08:45.564137070 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:47.076129186 +0200\n+++ /tmp/tmpdvznpko8.java\t2022-07-12 16:08:47.076129186 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:48.652120968 +0200\n+++ /tmp/tmp580jhc9y.java\t2022-07-12 16:08:48.652120968 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return cAvailableLocaleSet.contains(\"\\LocaleSet.containsNoLocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:50.312112309 +0200\n+++ /tmp/tmpb3trmfe1.java\t2022-07-12 16:08:50.312112309 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.contains(\"\\LocaleSet.containsNoLocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:51.836104362 +0200\n+++ /tmp/tmp3u6rel0r.java\t2022-07-12 16:08:51.836104362 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return locale.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-57/src/java/org/apache/commons/lang/LocaleUtils.java\t2022-07-12 16:08:53.416096124 +0200\n+++ /tmp/tmpkhpuej5y.java\t2022-07-12 16:08:53.416096124 +0200\n@@ -218,11 +218,11 @@\n      *\n      * @param locale the Locale object to check if it is available\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return locale.containsNoLocaleSet.contains(\"\\LocaleSet.contains(locale;\n     }\n \n     //-----------------------------------------------------------------------\n     /**\n      * <p>Obtains the list of languages supported for a given country.</p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return cAvailableLocaleSet.contains(locale);",
        "fixed_line": "return availableLocaleList().contains(locale);"
    },
    "Codec-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (escapeic --// contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:08:55.324086172 +0200\n+++ /tmp/tmpbbvucrvc.java\t2022-07-12 16:08:55.388085840 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (escapeic --// contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (escapeic --// contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:08:57.148076661 +0200\n+++ /tmp/tmpznukl7a3.java\t2022-07-12 16:08:57.152076640 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (escapeic --// contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:08:58.708068525 +0200\n+++ /tmp/tmp_3ljs84i.java\t2022-07-12 16:08:58.708068525 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (VARSON.contains(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:00.336060034 +0200\n+++ /tmp/tmp8imipzhn.java\t2022-07-12 16:09:00.336060034 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (VARSON.contains(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:01.872052022 +0200\n+++ /tmp/tmpp6n0t_d1.java\t2022-07-12 16:09:01.872052022 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (isInline(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:04.984035790 +0200\n+++ /tmp/tmpc577xe7h.java\t2022-07-12 16:09:04.988035769 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (isInline(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (VARSON.contains(value, index + 1, 4, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:06.732026671 +0200\n+++ /tmp/tmpstug3pvg.java\t2022-07-12 16:09:06.732026671 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (VARSON.contains(value, index + 1, 4, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (isInline(value, index + 1, 4, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:08.456017680 +0200\n+++ /tmp/tmpijs6klk8.java\t2022-07-12 16:09:08.460017659 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (isInline(value, index + 1, 4, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (contains(value, index + 1, 3, \"IER) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:10.092009146 +0200\n+++ /tmp/tmpphhb8n14.java\t2022-07-12 16:09:10.092009146 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (contains(value, index + 1, 3, \"IER\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-3/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\t2022-07-12 16:09:11.672000904 +0200\n+++ /tmp/tmp6jwvu8n4.java\t2022-07-12 16:09:11.672000904 +0200\n@@ -450,11 +450,11 @@\n                    contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) {\n             //-- Italian \"biaggi\" --//\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');\n             }\n             index += 2;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "} else if (contains(value, index + 1, 4, \"IER\")) {",
        "fixed_line": "} else if (contains(value, index + 1, 3, \"IER\")) {"
    },
    "Closure-66": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "if (parent.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (parent.isObjectLitKey(n, n, STRING_TYPE);",
                "patch_diff": "if (parent.isObjectLitKey(n, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (n.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "if (n.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (NodeUtil.isObjectLitKey(n, n, STRING_TYPE);",
                "patch_diff": "if (NodeUtil.isObjectLitKey(n, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "// Object literal keys.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (var.isObjectLitKey(t, n, STRING_TYPE);",
                "patch_diff": "if (var.isObjectLitKey(t, n, STRING_TYPE);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (parent.isObjectLitKey(t, n, STRING_TYPE;",
                "patch_diff": "if (parent.isObjectLitKey(t, n, STRING_TYPE;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (NodeUtil.isObjectLitKey(n, parent)) {",
                "patch_diff": "if (NodeUtil.isObjectLitKey(n, parent)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.isObjectLitKey) {",
                "patch_diff": "if (parent.isObjectLitKey) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (NodeUtil.isObjectLitKey(n, n, STRING_TYPE;",
                "patch_diff": "if (NodeUtil.isObjectLitKey(n, n, STRING_TYPE;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { // Object literal keys are not typeable typeable = false;"
    },
    "Gson-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken);",
                "patch_diff": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken;",
                "patch_diff": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return default: throw new JsonSyntaxException( \"Expecting number: \" + jsonToken);",
                "patch_diff": "return default: throw new JsonSyntaxException( \"Expecting number: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return default: throw new JsonSyntaxException( \"Expecting number: \" + jsonToken;",
                "patch_diff": "return default: throw new JsonSyntaxException( \"Expecting number: \" + jsonToken;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return default: throw new JsonSyntaxException( \"Expecting number, got: \" + jsonToken);",
                "patch_diff": "return default: throw new JsonSyntaxException( \"Expecting number, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return default: throw new JsonSyntaxExceptionException( \"Expecting number, got: \" + jsonToken);",
                "patch_diff": "return default: throw new JsonSyntaxExceptionException( \"Expecting number, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken.END_ARRAY;",
                "patch_diff": "return default: throw new JsonSyntaxExceptionException( \"Expecting number: \" + jsonToken.END_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new LazParsedNumber(in.nextNull, got: \" + jsonToken);",
                "patch_diff": "return new LazParsedNumber(in.nextNull, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new LazParsedNumber(in, got: \" + jsonToken);",
                "patch_diff": "return new LazParsedNumber(in, got: \" + jsonToken);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new JsonSyntaxException(in.nextNull;",
                "patch_diff": "return new JsonSyntaxException(in.nextNull;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case STRING:"
    },
    "Lang-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:18.131967202 +0200\n+++ /tmp/tmpiuxmw0i7.java\t2022-07-12 16:09:18.227966704 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:20.055957164 +0200\n+++ /tmp/tmpy9eer1kx.java\t2022-07-12 16:09:20.055957164 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:21.671948735 +0200\n+++ /tmp/tmpmoux4jv0.java\t2022-07-12 16:09:21.671948735 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:23.207940721 +0200\n+++ /tmp/tmptqve_gos.java\t2022-07-12 16:09:23.207940721 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.HOUR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:24.763932602 +0200\n+++ /tmp/tmpr6_c5jbt.java\t2022-07-12 16:09:24.767932580 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.MINUTE;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:26.287924651 +0200\n+++ /tmp/tmp0ujbez87.java\t2022-07-12 16:09:26.287924651 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:27.835916574 +0200\n+++ /tmp/tmpu627dhz5.java\t2022-07-12 16:09:27.835916574 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:29.295908956 +0200\n+++ /tmp/tmptrtrt38e.java\t2022-07-12 16:09:29.295908956 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_YEAR)\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:30.863900774 +0200\n+++ /tmp/tmp38ofb_xe.java\t2022-07-12 16:09:30.863900774 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.HOUR) == cal2.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-21/src/main/java/org/apache/commons/lang3/time/DateUtils.java\t2022-07-12 16:09:32.475892363 +0200\n+++ /tmp/tmphhqkc8j5.java\t2022-07-12 16:09:32.475892363 +0200\n@@ -260,11 +260,11 @@\n             throw new IllegalArgumentException(\"The date must not be null\");\n         }\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && cal1.get(Calendar.DAY_OF_MONTH;\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&\n                 cal1.getClass() == cal2.getClass());\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
        "fixed_line": "cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&"
    },
    "Jsoup-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "Validate.notEmpty(baseUri);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:34.183883450 +0200\n+++ /tmp/tmpl6350wor.java\t2022-07-12 16:09:34.207883325 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(baseUri);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Validate.notEmpty(yUri);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:38.223862368 +0200\n+++ /tmp/tmppkc4i1g4.java\t2022-07-12 16:09:38.223862368 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(yUri);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Validate.notEmpty(SESSION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:39.903853601 +0200\n+++ /tmp/tmprmgl9k_n.java\t2022-07-12 16:09:39.903853601 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(SESSION;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Validate.notEmpty(baseUri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:41.391845835 +0200\n+++ /tmp/tmpfn91kqf8.java\t2022-07-12 16:09:41.391845835 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(baseUri;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Validate.notEmpty(closed;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:42.767838652 +0200\n+++ /tmp/tmpedc09ey_.java\t2022-07-12 16:09:42.767838652 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(closed;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Validate.notEmpty(yUri;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:44.227831034 +0200\n+++ /tmp/tmpy61355c0.java\t2022-07-12 16:09:44.231831012 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(yUri;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Validate.notEmpty(name;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:45.663823540 +0200\n+++ /tmp/tmpu5feixvg.java\t2022-07-12 16:09:45.663823540 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Validate.notEmpty(name);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:47.139815836 +0200\n+++ /tmp/tmpinvdi74w.java\t2022-07-12 16:09:47.139815836 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Validate.notEmpty(closed);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:50.083800471 +0200\n+++ /tmp/tmpe9fpe8uq.java\t2022-07-12 16:09:50.083800471 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(closed);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Validate.notEmpty(nameTest;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-40/src/main/java/org/jsoup/nodes/DocumentType.java\t2022-07-12 16:09:51.687792098 +0200\n+++ /tmp/tmpq5glcgsb.java\t2022-07-12 16:09:51.691792077 +0200\n@@ -17,11 +17,11 @@\n      * @param baseUri the doctype's base URI\n      */\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+Validate.notEmpty(nameTest;\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Validate.notEmpty(name);",
        "fixed_line": ""
    },
    "Mockito-29": {
        "fixes": [
            {
                "k": 1,
                "patch": "description.appendText;wanted isQu.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:09:53.307783642 +0200\n+++ /tmp/tmpmbtj25_6.java\t2022-07-12 16:09:53.363783355 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted isQu.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "description.appendText; appendQu.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:09:55.811770572 +0200\n+++ /tmp/tmp3076_trw.java\t2022-07-12 16:09:55.811770572 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText; appendQu.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "description.appendText(wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:09:57.611761176 +0200\n+++ /tmp/tmpz_akykzc.java\t2022-07-12 16:09:57.611761176 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "description.appendText; this.wanted forText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:17.095659456 +0200\n+++ /tmp/tmp_qspw5sm.java\t2022-07-12 16:10:17.099659435 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText; this.wanted forText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "description.appendText(description.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:18.947649786 +0200\n+++ /tmp/tmpsj3m5vfv.java\t2022-07-12 16:10:18.947649786 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "description.appendText;wanted forText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:38.507548257 +0200\n+++ /tmp/tmpqgmxvled.java\t2022-07-12 16:10:38.507548257 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted forText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "description.appendText;wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:40.295540656 +0200\n+++ /tmp/tmpwp_wwgyv.java\t2022-07-12 16:10:40.295540656 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "description.appendText(_wanted.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:42.059533151 +0200\n+++ /tmp/tmp8gwhzmih.java\t2022-07-12 16:10:42.059533151 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(_wanted.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "description.appendText;wanted isText.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:44.539522594 +0200\n+++ /tmp/tmp74iycxx2.java\t2022-07-12 16:10:44.543522575 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText;wanted isText.toString());\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "description.appendText(description;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-29/src/org/mockito/internal/matchers/Same.java\t2022-07-12 16:10:46.399514667 +0200\n+++ /tmp/tmptk9_bnx7.java\t2022-07-12 16:10:46.399514667 +0200\n@@ -24,11 +24,11 @@\n     }\n \n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+description.appendText(description;\n         appendQuoting(description);\n         description.appendText(\")\");\n     }\n \n     private void appendQuoting(Description description) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "description.appendText(wanted.toString());",
        "fixed_line": "description.appendText(wanted == null ? \"null\" : wanted.toString());"
    },
    "JacksonDatabind-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:48.519505627 +0200\n+++ /tmp/tmp1j_vu27o.java\t2022-07-12 16:10:48.551505493 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:50.519497092 +0200\n+++ /tmp/tmpcqz657p6.java\t2022-07-12 16:10:50.519497092 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:52.295489509 +0200\n+++ /tmp/tmpzwpoghin.java\t2022-07-12 16:10:52.295489509 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _valueHandler, _typeHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _bindings, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:54.007482191 +0200\n+++ /tmp/tmpt21cs6bi.java\t2022-07-12 16:10:54.007482191 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _bindings, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:55.651475163 +0200\n+++ /tmp/tmpfwaefgy_.java\t2022-07-12 16:10:55.655475144 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:57.367467818 +0200\n+++ /tmp/tmp_xirvk4x.java\t2022-07-12 16:10:57.367467818 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:10:58.931461124 +0200\n+++ /tmp/tmpmiwal0_z.java\t2022-07-12 16:10:58.931461124 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _valueHandler, _typeHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _valueHandler,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:11:00.611453927 +0200\n+++ /tmp/tmp0_0vl07m.java\t2022-07-12 16:11:00.611453927 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _valueHandler,\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _valueHandler, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:11:02.347446485 +0200\n+++ /tmp/tmp16cck469.java\t2022-07-12 16:11:02.347446485 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(_class, _superClass, _superClass, _bindings, _superClass, _valueHandler, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new SimpleType(subclass, _superClass, _superClass, _bindings, _typeHandler, _asStatic);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-37/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java\t2022-07-12 16:11:03.999439399 +0200\n+++ /tmp/tmp0s0lgfc6.java\t2022-07-12 16:11:04.003439382 +0200\n@@ -130,11 +130,11 @@\n             throw new IllegalArgumentException(\"Class \"+subclass.getName()+\" not sub-type of \"\n                     +_class.getName());\n         }\n         */\n         // 15-Jan-2015, tatu: Not correct; should really re-resolve...\n-        return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,\n+return new SimpleType(subclass, _superClass, _superClass, _bindings, _typeHandler, _asStatic);\n                 _valueHandler, _typeHandler, _asStatic);\n     }\n     \n     @Override\n     public JavaType withContentType(JavaType contentType) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
        "fixed_line": "return new SimpleType(subclass, _bindings, this, _superInterfaces,"
    },
    "Chart-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (dataset == null) { // block == null; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:05.803431655 +0200\n+++ /tmp/tmpnn4saaib.java\t2022-07-12 16:11:05.859431415 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "if (dataset == null) { // add a dataset with 0x result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:16.183387002 +0200\n+++ /tmp/tmpvka1zl_z.java\t2022-07-12 16:11:16.183387002 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset with 0x result; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 3,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:25.235347930 +0200\n+++ /tmp/tmp58vdsw_h.java\t2022-07-12 16:11:25.235347930 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "if (dataset == null) { // add a dataset with 0x result; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:34.499307811 +0200\n+++ /tmp/tmpktz7k56a.java\t2022-07-12 16:11:34.499307811 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset with 0x result; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 5,
                "patch": "if (dataset == null) { // add a dataset (dataset (this.dataset == null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:43.447268940 +0200\n+++ /tmp/tmpgts8ukom.java\t2022-07-12 16:11:43.447268940 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // add a dataset (dataset (this.dataset == null)\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "if (dataset == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:11:52.583229133 +0200\n+++ /tmp/tmpf46yj8m6.java\t2022-07-12 16:11:52.583229133 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block only override if more specific\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "if (dataset == null) { // block == null; non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:12:01.543189975 +0200\n+++ /tmp/tmp2bc8aven.java\t2022-07-12 16:12:01.543189975 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's do implicit re-parse\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 8,
                "patch": "if (this.dataset == null) { // block == null; non-empty enables",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:12:10.695149860 +0200\n+++ /tmp/tmp9whlhpiy.java\t2022-07-12 16:12:10.699149843 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (this.dataset == null) { // block == null; non-empty enables\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (dataset == null) { // block only override if the dataset with 0x result; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:12:12.507141905 +0200\n+++ /tmp/tmp2y9df__r.java\t2022-07-12 16:12:12.511141887 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block only override if the dataset with 0x result; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (dataset == null) { // block == null; non-empty's after name; return result; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-1/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\t2022-07-12 16:12:21.647101706 +0200\n+++ /tmp/tmpkfgrtr6c.java\t2022-07-12 16:12:21.647101706 +0200\n@@ -1792,11 +1792,11 @@\n         if (this.plot == null) {\n             return result;\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) { // block == null; non-empty's after name; return result; }\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();\n         if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n             for (int i = 0; i < seriesCount; i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            }
        ],
        "buggy_line": "if (dataset != null) {",
        "fixed_line": "if (dataset == null) {"
    },
    "Codec-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "long len = getEncodeLength(binaryData, cursor, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:30.851061108 +0200\n+++ /tmp/tmp5f4_dnnw.java\t2022-07-12 16:12:30.895060914 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, cursor, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "long len = getEncodeLength(binaryData, needResult, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:32.747052731 +0200\n+++ /tmp/tmpv6g61u1p.java\t2022-07-12 16:12:32.771052625 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, needResult, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "long len = getEncodeLength(binaryData, movedData, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:34.391045464 +0200\n+++ /tmp/tmptigfr5n5.java\t2022-07-12 16:12:34.391045464 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, movedData, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATORLength);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:35.987038406 +0200\n+++ /tmp/tmp08fpf2uy.java\t2022-07-12 16:12:35.991038388 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATORLength);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:37.639031096 +0200\n+++ /tmp/tmpfe7c_7zu.java\t2022-07-12 16:12:37.639031096 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, byteLen, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "long len = getEncodeLength(binaryData, Encoder_CHUNK_SIZE, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:39.371023428 +0200\n+++ /tmp/tmpl83hzhbk.java\t2022-07-12 16:12:39.371023428 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, Encoder_CHUNK_SIZE, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "long len = getEncodeLength(binaryData, binaryData, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:40.975016325 +0200\n+++ /tmp/tmpfrg3ior8.java\t2022-07-12 16:12:40.975016325 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, binaryData, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:42.635008969 +0200\n+++ /tmp/tmpfm_fzoh7.java\t2022-07-12 16:12:42.635008969 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR;\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "long len = getEncodeLength(binaryData, elementType, elementData);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:44.159002213 +0200\n+++ /tmp/tmpi84xda8a.java\t2022-07-12 16:12:44.159002213 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, elementData);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-9/src/java/org/apache/commons/codec/binary/Base64.java\t2022-07-12 16:12:45.818994850 +0200\n+++ /tmp/tmp0oo7p5ms.java\t2022-07-12 16:12:45.818994850 +0200\n@@ -822,11 +822,11 @@\n     public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n         if (binaryData == null || binaryData.length == 0) {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, elementType, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +\n                 \") than the specified maxium size of \" +\n                 maxResultSize);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
        "fixed_line": "long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, CHUNK_SEPARATOR);"
    },
    "Jsoup-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "// for (int c = start; i < this.tagName; ++i) {",
                "patch_diff": "// for (int c = start; i < this.tagName; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// for (int c = 0; i < this.tagName; ++i) {",
                "patch_diff": "// for (int c = 0; i < this.tagName; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// for (int c = start; c < this.tagName; ++i) {",
                "patch_diff": "// for (int c = start; c < this.tagName; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// for (int c = start; i < this.tagName; i++) {",
                "patch_diff": "// for (int c = start; i < this.tagName; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// for (int c = 0; i < this.tagName; i++) {",
                "patch_diff": "// for (int c = 0; i < this.tagName; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int c = start; i < this.tagName; ++i) { for (int i = 0; i < this.tagName; i++) {",
                "patch_diff": "// for (int c = start; i < this.tagName; ++i) { for (int i = 0; i < this.tagName; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int c = start; i < this.tagName; ++i) { for (int i = 0; i < this.tagName; ++i) {",
                "patch_diff": "// for (int c = start; i < this.tagName; ++i) { for (int i = 0; i < this.tagName; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// for (int c = start; c < this.tagName; i++) {",
                "patch_diff": "// for (int c = start; c < this.tagName; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// for (int c = start; i < this.tagName; ++i) { for (int c = 0; i < this.tagName; i++) {",
                "patch_diff": "// for (int c = start; i < this.tagName; ++i) { for (int c = 0; i < this.tagName; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// for (int c = start; i < this.tagName; ++i) { for (int c = 0; i < this.tagName; ++i) {",
                "patch_diff": "// for (int c = start; i < this.tagName; ++i) { for (int c = 0; i < this.tagName; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "tokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data"
    },
    "JacksonDatabind-74": {
        "fixes": [
            {
                "k": 1,
                "patch": "return type id (type == JsonToken.START_OBJECT) {",
                "patch_diff": "return type id (type == JsonToken.START_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) {",
                "patch_diff": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return type id (type == JsonToken.START_ARRAY;",
                "patch_diff": "return type id (type == JsonToken.START_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return type id (typeId == JsonToken.START_ARRAY;",
                "patch_diff": "return type id (typeId == JsonToken.START_ARRAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return type id (type == JsonToken.START_ARRAY) {",
                "patch_diff": "return type id (type == JsonToken.START_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { return null; }",
                "patch_diff": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { return null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return type id (typeId == JsonToken.START_OBJECT) {",
                "patch_diff": "return type id (typeId == JsonToken.START_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY)",
                "patch_diff": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { if (type == JsonToken.START_OBJECT) {",
                "patch_diff": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { if (type == JsonToken.START_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { throw ctxt; }",
                "patch_diff": "return type id '\"+_typePropertyName+\"' that is to contain type id (type == JsonToken.START_ARRAY) { throw ctxt; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (p.getCurrentToken() == JsonToken.VALUE_STRING) { if (ctxt.isEnabled(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT)) { String str = p.getText().trim(); if (str.isEmpty()) { return null; } }"
    },
    "Lang-43": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i == INT_QUOTE || c == null? null : format.length();",
                "patch_diff": "if (i == INT_QUOTE || c == null? null : format.length();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c == INT_QUOTE || c == null? null : format.length();",
                "patch_diff": "if (c == INT_QUOTE || c == null? null : format.length();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (i == INT_QUOTE || c == null? null : format.length() == 0) {",
                "patch_diff": "if (i == INT_QUOTE || c == null? null : format.length() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c == INT_QUOTE || c == null? null : format.length() == 0) {",
                "patch_diff": "if (c == INT_QUOTE || c == null? null : format.length() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c == EOF_CHAR) {",
                "patch_diff": "if (c == EOF_CHAR) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i == 0 || c == null? null : format.length();",
                "patch_diff": "if (i == 0 || c == null? null : format.length();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = start; i < end; i++) {",
                "patch_diff": "for (int i = start; i < end; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c == INT_QUOTE || c == null? null : appendTo.length();",
                "patch_diff": "if (c == INT_QUOTE || c == null? null : appendTo.length();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c == null) {",
                "patch_diff": "if (c == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i == 0 || c == null? null : format.length() == 0) {",
                "patch_diff": "if (i == 0 || c == null? null : format.length() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "next(pos);"
    },
    "Math-63": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:12:53.138962341 +0200\n+++ /tmp/tmpr93rf21e.java\t2022-07-12 16:12:53.162962233 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (Double.isNaN || Double.isNaN(x) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:12:55.594951417 +0200\n+++ /tmp/tmpi9p2nr5j.java\t2022-07-12 16:12:55.594951417 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (Double.isNaN || Double.isNaN(x || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:12:57.654942250 +0200\n+++ /tmp/tmpzscg8vic.java\t2022-07-12 16:12:57.658942232 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (Double.isNaN || Double.isNaN(x) || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:12:59.690933183 +0200\n+++ /tmp/tmp9s8ohgsl.java\t2022-07-12 16:12:59.690933183 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x) || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (Double.isNaN(x) || Double.isNaN(y)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:01.810923737 +0200\n+++ /tmp/tmp39m_fsbs.java\t2022-07-12 16:13:01.814923720 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN(y)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (x.isNaN || Double.isNaN(y || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:39.890753138 +0200\n+++ /tmp/tmpudiswpto.java\t2022-07-12 16:13:39.894753117 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (x.isNaN || Double.isNaN(y || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (Double.isNaN || Double.isNaN(x)) || y == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:42.010743587 +0200\n+++ /tmp/tmpd6iqff40.java\t2022-07-12 16:13:42.010743587 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x)) || y == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (Double.isNaN(x || Double.isNaN(y || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:44.306733243 +0200\n+++ /tmp/tmpgubl5hl2.java\t2022-07-12 16:13:44.306733243 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x || Double.isNaN(y || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (Double.isNaN || Double.isNaN(x)) || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:46.310724205 +0200\n+++ /tmp/tmpmdrj1vfy.java\t2022-07-12 16:13:46.310724205 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN || Double.isNaN(x)) || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (Double.isNaN(x) || Double.isNaN || x == y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-63/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 16:13:48.446714570 +0200\n+++ /tmp/tmp3id7jdbq.java\t2022-07-12 16:13:48.450714549 +0200\n@@ -412,11 +412,11 @@\n      * @param x first value\n      * @param y second value\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+return (Double.isNaN(x) || Double.isNaN || x == y;\n     }\n \n     /**\n      * Returns true if both arguments are NaN or neither is NaN and they are\n      * equal as defined by {@link #equals(double,double) this method}.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
        "fixed_line": "return equals(x, y, 1);"
    },
    "Codec-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for 2;",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for 2;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for 2;",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for 2;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for unchecked as we have not reached",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for unchecked as we have not reached",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for unchecked as we have not reached",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for unchecked as we have not reached",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping fornot real number",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping fornot real number",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping fornot real number) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping fornot real number) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-407] -- allow disabling wrapping fornot real number) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping fornot real number) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions;",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for unchecked exceptions;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public long skip(long n) throws IOException { if (n < 0) { throw new IllegalArgumentException(\"Negative skip length\"); } // skip in chunks of 512 bytes final byte[] b = new byte[512]; final int max = (int) Math.min(n, Integer.MAX_VALUE); int total = 0; while (total < max) { int len = max - total; if (len > b.length) { len = b.length; } len = read(b, 0, len); if (len == EOF) { break; } total += len; } return total; } /** * {@inheritDoc} * * @return <code>0</code> if the {@link InputStream} has reached <code>EOF</code>, * <code>1</code> otherwise */ public int available() throws IOException { // Note: the logic is similar to the InflaterInputStream: // as long as we have not reached EOF, indicate that there is more // data available. As we do not know for sure how much data is left, // just return 1 as a safe guess. // use the EOF flag of the underlying codec instance if (baseNCodec.eof) { return 0; } else { return 1; } }"
    },
    "JacksonDatabind-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "} else if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer; if (ser == null) {",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer; if (ser == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull;",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull; if (ser == null) {",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull; if (ser == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer; if (ser == null) {",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer; if (ser == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer;",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer; if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer; if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull; if (ser == null) { // can NOT suppress entries in tabular output",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer.writeNull; if (ser == null) { // can NOT suppress entries in tabular output",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer.writeNull; if (ser == null) {",
                "patch_diff": "// can NOT suppress entries in tabular output = _nullSerializer<Object> ser = _nullSerializer.writeNull; if (ser == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return;"
    },
    "Cli-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (valueList == null) || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:13:54.294688158 +0200\n+++ /tmp/tmp5yxbspv7.java\t2022-07-12 16:13:54.346687922 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (valueList!= null && valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:13:56.174679659 +0200\n+++ /tmp/tmpzmm1e6gg.java\t2022-07-12 16:13:56.174679659 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null && valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (valueList == null || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:13:57.814672245 +0200\n+++ /tmp/tmpowij_7ob.java\t2022-07-12 16:13:57.814672245 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (valueList!= null) || valueList = valueList; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:13:59.362665239 +0200\n+++ /tmp/tmppmu7braw.java\t2022-07-12 16:13:59.362665239 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null) || valueList = valueList; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (valueList == null) || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:00.946658071 +0200\n+++ /tmp/tmppqarx9xf.java\t2022-07-12 16:14:00.950658055 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (valueList!= null) || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:02.502651025 +0200\n+++ /tmp/tmpkschb8bh.java\t2022-07-12 16:14:02.502651025 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null) || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (valueList!= null && valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:04.078643890 +0200\n+++ /tmp/tmpmqblb9_v.java\t2022-07-12 16:14:04.078643890 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList!= null && valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (valueList == null || valueList = defaultValues; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:05.570637127 +0200\n+++ /tmp/tmpb6j66qmi.java\t2022-07-12 16:14:05.570637127 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = defaultValues; }\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (valueList == null) || valueList = defaultValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:07.130630056 +0200\n+++ /tmp/tmpp7f08oeb.java\t2022-07-12 16:14:07.130630056 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null) || valueList = defaultValues;\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (valueList == null || valueList = defaultValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-15/src/java/org/apache/commons/cli2/commandline/WriteableCommandLineImpl.java\t2022-07-12 16:14:08.658623127 +0200\n+++ /tmp/tmpq64dnfne.java\t2022-07-12 16:14:08.658623127 +0200\n@@ -112,18 +112,11 @@\n                           List defaultValues) {\n         // initialize the return list\n         List valueList = (List) values.get(option);\n \n         // grab the correct default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = defaultValues;\n-        }\n-\n-        // augment the list with the default values\n-        if ((valueList == null) || valueList.isEmpty()) {\n-            valueList = (List) this.defaultValues.get(option);\n-        }\n+if (valueList == null || valueList = defaultValues;\n                 // if there are more default values as specified, add them to\n                 // the list.\n                     // copy the list first\n         \n         return valueList == null ? Collections.EMPTY_LIST : valueList;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((valueList == null) || valueList.isEmpty()) { valueList = defaultValues; } // augment the list with the default values if ((valueList == null) || valueList.isEmpty()) { valueList = (List) this.defaultValues.get(option); }",
        "fixed_line": "if (defaultValues == null || defaultValues.isEmpty()) { defaultValues = (List) this.defaultValues.get(option); } // augment the list with the default values if (defaultValues != null && !defaultValues.isEmpty()) { if (valueList == null || valueList.isEmpty()) { valueList = defaultValues; } else { // if there are more default values as specified, add them to // the list. if (defaultValues.size() > valueList.size()) { // copy the list first valueList = new ArrayList(valueList); for (int i=valueList.size(); i<defaultValues.size(); i++) { valueList.add(defaultValues.get(i)); } } } }"
    },
    "JacksonDatabind-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++i) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++i) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++j) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; ++j) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int j = 0; i < padding.length; i++) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int j = 0; i < padding.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) { return URI; }",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) { return URI; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) { return URI; } }",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < padding.length; i++) { return URI; } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int j = 0; i < padding.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int j = 0; i < padding.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (_kind == STD_LOCALE) { return Locale.ROOT; }"
    },
    "Closure-81": {
        "fixes": [
            {
                "k": 1,
                "patch": "Name name = false; if (name!= null) {",
                "patch_diff": "Name name = false; if (name!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Name name = false; if (name == null) {",
                "patch_diff": "Name name = false; if (name == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "functionNode = false; if (name!= null) {",
                "patch_diff": "functionNode = false; if (name!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "functionNode = false; if (name == null) {",
                "patch_diff": "functionNode = false; if (name == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "name = false; if (name == null) {",
                "patch_diff": "name = false; if (name == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Name name = functionNode.getFunctionName();",
                "patch_diff": "Name name = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "name = false; if (name!= null) {",
                "patch_diff": "name = false; if (name!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Name name = true; if (name == null) {",
                "patch_diff": "Name name = true; if (name == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Name name = functionNode;",
                "patch_diff": "Name name = functionNode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "FunctionFunction = functionNode.getFunctionName();",
                "patch_diff": "FunctionFunction = functionNode.getFunctionName();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int functionType = functionNode.getFunctionType(); if (functionType != FunctionNode.FUNCTION_EXPRESSION) { errorReporter.error( \"unnamed function statement\", sourceName, functionNode.getLineno(), \"\", 0); }"
    },
    "Closure-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] EASTER = this.numberOfArgs;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberOfArgs;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] EASTER = this.number;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.number;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] EASTER = this.numberBigDecimal;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberBigDecimal;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// this is a record type.",
                "patch_diff": "// this is a record type.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] EASTER = this.numberFormatterObj;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberFormatterObj;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] EASTER = this.numberNegativeNegatives;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberNegativeNegatives;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] EASTER = this.numberNegativeNegative;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberNegativeNegative;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = this.numberNegative;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberNegative;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] EASTER = this.numberDouble;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.numberDouble;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// this is a record type. // value is a record type.",
                "patch_diff": "// this is a record type. // value is a record type.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (hasReferenceName()) { return; }"
    },
    "Math-55": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:15.610591569 +0200\n+++ /tmp/tmp7y9undwr.java\t2022-07-12 16:14:15.662591334 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:18.034580555 +0200\n+++ /tmp/tmpcoxg5k13.java\t2022-07-12 16:14:18.034580555 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y * v1.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:20.202570698 +0200\n+++ /tmp/tmp4sxazh8q.java\t2022-07-12 16:14:20.202570698 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:22.178561709 +0200\n+++ /tmp/tmp862375y8.java\t2022-07-12 16:14:22.178561709 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:24.178552607 +0200\n+++ /tmp/tmpqdyl127k.java\t2022-07-12 16:14:24.182552591 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y - v1.y * v2.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:26.134543701 +0200\n+++ /tmp/tmpvc2v_j96.java\t2022-07-12 16:14:26.134543701 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y * v1.y - v2.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:28.198534301 +0200\n+++ /tmp/tmpaclncp21.java\t2022-07-12 16:14:28.198534301 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1 - v1.x, v2.y * v1.y - v2.y * v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:30.242524983 +0200\n+++ /tmp/tmpohpo5o_2.java\t2022-07-12 16:14:30.242524983 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:32.270515736 +0200\n+++ /tmp/tmptprwslsb.java\t2022-07-12 16:14:32.270515736 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v2Constants.MILLIS_PER_HOUR; v1.x - v2.x * v1.x, v2.y);\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new Vector3D(v1 * v1.x - v2.x, v2.y - v1.y * v2.y - v1.y;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-55/src/main/java/org/apache/commons/math/geometry/Vector3D.java\t2022-07-12 16:14:34.254506686 +0200\n+++ /tmp/tmpie1oul94.java\t2022-07-12 16:14:34.254506686 +0200\n@@ -468,11 +468,11 @@\n \n       // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n \n \n       // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n+return new Vector3D(v1 * v1.x - v2.x, v2.y - v1.y * v2.y - v1.y;\n \n   }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);",
        "fixed_line": "final double n1 = v1.getNormSq(); final double n2 = v2.getNormSq(); if ((n1 * n2) < MathUtils.SAFE_MIN) { return ZERO; } // rescale both vectors without losing precision, // to ensure their norm are the same order of magnitude final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4; final double x1 = FastMath.scalb(v1.x, -deltaExp); final double y1 = FastMath.scalb(v1.y, -deltaExp); final double z1 = FastMath.scalb(v1.z, -deltaExp); final double x2 = FastMath.scalb(v2.x, deltaExp); final double y2 = FastMath.scalb(v2.y, deltaExp); final double z2 = FastMath.scalb(v2.z, deltaExp); // we reduce cancellation errors by preconditioning, // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute // v3 without loss of precision. See Kahan lecture // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\" // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf // compute rho as an 8 bits approximation of v1.v2 / v2.v2 final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp); final double rho = FastMath.rint(256 * ratio) / 256; final double x3 = x1 - rho * x2; final double y3 = y1 - rho * y2; final double z3 = z1 - rho * z2; // compute cross product from v3 and v2 instead of v1 and v2 return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);"
    },
    "Closure-122": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:14:36.434496737 +0200\n+++ /tmp/tmpxcww5x9w.java\t2022-07-12 16:14:36.518496352 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:14:41.782472308 +0200\n+++ /tmp/tmpvdywiqmm.java\t2022-07-12 16:14:41.782472308 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:14:45.314456159 +0200\n+++ /tmp/tmprlj0awvh.java\t2022-07-12 16:14:45.314456159 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:14:48.898439756 +0200\n+++ /tmp/tmpwu2hj0ub.java\t2022-07-12 16:14:48.902439738 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:15:41.174199101 +0200\n+++ /tmp/tmpfird18to.java\t2022-07-12 16:15:41.178199080 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:16:30.913967782 +0200\n+++ /tmp/tmptyznn74f.java\t2022-07-12 16:16:30.917967763 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @+ -1)!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:16:34.613950490 +0200\n+++ /tmp/tmpvuf5j2kw.java\t2022-07-12 16:16:34.613950490 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @+ -1)!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:16:38.017934573 +0200\n+++ /tmp/tmpa0fsf7ws.java\t2022-07-12 16:16:38.017934573 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:17:27.909700197 +0200\n+++ /tmp/tmpnnfzww72.java\t2022-07-12 16:17:27.913700178 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") == -1 || comment.getValue().indexOf(\"\\n * @ @ @\")!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @+ -1)!= -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-122/src/com/google/javascript/jscomp/parsing/IRFactory.java\t2022-07-12 16:18:17.313466284 +0200\n+++ /tmp/tmpw9pj21ju.java\t2022-07-12 16:18:17.317466264 +0200\n@@ -247,11 +247,11 @@\n \n   /**\n    * Check to see if the given block comment looks like it should be JSDoc.\n    */\n   private void handleBlockComment(Comment comment) {\n-    if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {\n+if (comment.getValue().indexOf(\"/* @\") || comment.getValue().indexOf(\"\\n * @ @+ -1)!= -1) {\n       errorReporter.warning(\n           SUSPICIOUS_COMMENT_WARNING,\n           sourceName,\n           comment.getLineno(), \"\", 0);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {",
        "fixed_line": "Pattern p = Pattern.compile(\"(/|(\\n[ \\t]*))\\\\*[ \\t]*@[a-zA-Z]\"); if (p.matcher(comment.getValue()).find()) {"
    },
    "Closure-160": {
        "fixes": [
            {
                "k": 1,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:21.065448451 +0200\n+++ /tmp/tmp_ociubkj.java\t2022-07-12 16:18:21.097448299 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:24.153433766 +0200\n+++ /tmp/tmpxzjgf4xv.java\t2022-07-12 16:18:24.153433766 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:26.745421434 +0200\n+++ /tmp/tmpsaichi87.java\t2022-07-12 16:18:26.745421434 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "(warningsGuard == null ||!warningsGuard.disables) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:29.209409708 +0200\n+++ /tmp/tmp6wjsnw0g.java\t2022-07-12 16:18:29.213409689 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:31.769397521 +0200\n+++ /tmp/tmpt61s8q49.java\t2022-07-12 16:18:31.773397501 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDEDDEDWarningsGuard) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:34.273385596 +0200\n+++ /tmp/tmp6tbmwi5f.java\t2022-07-12 16:18:34.273385596 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDEDDEDWarningsGuard) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) { state.CHECK_VARIABLE, CheckLevel.OFF; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:36.809373514 +0200\n+++ /tmp/tmpfo7z7x7q.java\t2022-07-12 16:18:36.809373514 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLES) { state.CHECK_VARIABLE, CheckLevel.OFF; }\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "(warningsGuard!= null &&!warningsGuard.disables.CHECK_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:39.329361505 +0200\n+++ /tmp/tmpxrysab7r.java\t2022-07-12 16:18:39.329361505 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard!= null &&!warningsGuard.disables.CHECK_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:41.837349547 +0200\n+++ /tmp/tmpp8l3s1aw.java\t2022-07-12 16:18:41.841349527 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLES) {\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-160/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:18:44.353337549 +0200\n+++ /tmp/tmpuwthwv_8.java\t2022-07-12 16:18:44.353337549 +0200\n@@ -270,17 +270,11 @@\n     // variables later so that the compiler doesn't crash. It also\n     // checks the externs file for validity. If you don't want to warn\n     // about missing variable declarations, we shut that specific\n     // error off.\n     if (!options.checkSymbols &&\n-        (warningsGuard == null || !warningsGuard.disables(\n-            DiagnosticGroups.CHECK_VARIABLES))) {\n-      guards.add(new DiagnosticGroupWarningsGuard(\n-          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n-    }\n-\n-    this.warningsGuard = new ComposeWarningsGuard(guards);\n+(warningsGuard == null ||!warningsGuard.disables.CHECK_VARIABLESUSPENDED_VARIABLESUSPENDED_VARIABLES;\n   }\n \n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "(warningsGuard == null || !warningsGuard.disables( DiagnosticGroups.CHECK_VARIABLES))) { guards.add(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = new ComposeWarningsGuard(guards);",
        "fixed_line": "ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); // All passes must run the variable check. This synthesizes // variables later so that the compiler doesn't crash. It also // checks the externs file for validity. If you don't want to warn // about missing variable declarations, we shut that specific // error off. if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards;"
    },
    "Csv-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "final boolean emptyHeader = header.trim().isEmptysHeader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:47.005324897 +0200\n+++ /tmp/tmp7x2c3k7h.java\t2022-07-12 16:18:47.025324802 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptysHeader;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final boolean emptyHeader = header.trim().isEmptys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:48.833316173 +0200\n+++ /tmp/tmp9wfskzys.java\t2022-07-12 16:18:48.833316173 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptys;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final boolean emptyHeader = header.trim().isEmptys()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:50.469308364 +0200\n+++ /tmp/tmpkpxfrz11.java\t2022-07-12 16:18:50.469308364 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptys()) {\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final boolean emptyHeader = header.trim().isEmptyssHeader;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:51.961301242 +0200\n+++ /tmp/tmpjr1qqupv.java\t2022-07-12 16:18:51.961301242 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyssHeader;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final boolean emptyHeader = header.trim().isEmpty;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:53.773292588 +0200\n+++ /tmp/tmp4tnleqax.java\t2022-07-12 16:18:53.777292571 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final boolean emptyHeader = header.trim().isEmpty()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:55.477284450 +0200\n+++ /tmp/tmp3h2nacl2.java\t2022-07-12 16:18:55.477284450 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty()) {\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final boolean emptyHeader = header.trim().isEmptyType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:57.009277132 +0200\n+++ /tmp/tmphfyp7twx.java\t2022-07-12 16:18:57.009277132 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyType;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final boolean emptyHeader = header.trim().isEmpty - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:18:58.781268663 +0200\n+++ /tmp/tmpi6dks1oi.java\t2022-07-12 16:18:58.781268663 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmpty - 1;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final boolean emptyHeader = header.trim().isEmptyss;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:19:00.481260539 +0200\n+++ /tmp/tmp17r43h76.java\t2022-07-12 16:19:00.481260539 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyss;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final boolean emptyHeader = header.trim().isEmptyTable;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-11/src/main/java/org/apache/commons/csv/CSVParser.java\t2022-07-12 16:19:02.137252623 +0200\n+++ /tmp/tmph4r5em5t.java\t2022-07-12 16:19:02.137252623 +0200\n@@ -379,11 +379,11 @@\n             // build the name to index mappings\n             if (headerRecord != null) {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header.trim().isEmptyTable;\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));\n                     }\n                     hdrMap.put(header, Integer.valueOf(i));\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final boolean emptyHeader = header.trim().isEmpty();",
        "fixed_line": "final boolean emptyHeader = header == null || header.trim().isEmpty();"
    },
    "Closure-152": {
        "fixes": [
            {
                "k": 1,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope!= scope) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:03.989243767 +0200\n+++ /tmp/tmp0cmazp39.java\t2022-07-12 16:19:04.049243481 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope!= scope) {\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope,",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:06.049233915 +0200\n+++ /tmp/tmp1o_w4kbp.java\t2022-07-12 16:19:06.049233915 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope,\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:07.621226394 +0200\n+++ /tmp/tmp0g73ijwf.java\t2022-07-12 16:19:07.621226394 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope = typeOfThis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:09.145219102 +0200\n+++ /tmp/tmpmvpa7h7z.java\t2022-07-12 16:19:09.145219102 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope = typeOfThis;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope!= scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:10.661211848 +0200\n+++ /tmp/tmpwcxdfubq.java\t2022-07-12 16:19:10.661211848 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope!= scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope) scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:12.181204572 +0200\n+++ /tmp/tmpp6eq55gd.java\t2022-07-12 16:19:12.181204572 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope) scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:13.697197314 +0200\n+++ /tmp/tmpb_mm5o_s.java\t2022-07-12 16:19:13.697197314 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope = scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:15.189190170 +0200\n+++ /tmp/tmp3b2l2l4d.java\t2022-07-12 16:19:15.189190170 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope = scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, scope;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:16.745182718 +0200\n+++ /tmp/tmp7fr1g6_9.java\t2022-07-12 16:19:16.749182698 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, scope;\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "typeOfThis = (ObjectType) typeOfThis; t, node, scope);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-152/src/com/google/javascript/rhino/jstype/FunctionType.java\t2022-07-12 16:19:18.269175417 +0200\n+++ /tmp/tmpo2c2ofx0.java\t2022-07-12 16:19:18.269175417 +0200\n@@ -866,11 +866,11 @@\n     prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n \n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+typeOfThis = (ObjectType) typeOfThis; t, node, scope);\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces =\n         ImmutableList.builder();\n     for (ObjectType iface : implementedInterfaces) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
        "fixed_line": "JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope); if (maybeTypeOfThis instanceof ObjectType) { typeOfThis = (ObjectType) maybeTypeOfThis; }"
    },
    "Cli-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:20.317165605 +0200\n+++ /tmp/tmpcajwx72a.java\t2022-07-12 16:19:20.381165298 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c == '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:22.085157131 +0200\n+++ /tmp/tmppg6l70nz.java\t2022-07-12 16:19:22.085157131 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c == '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c == '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:23.573149998 +0200\n+++ /tmp/tmpwqdtnhtg.java\t2022-07-12 16:19:23.573149998 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c == '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:25.117142595 +0200\n+++ /tmp/tmpaup30_1y.java\t2022-07-12 16:19:25.117142595 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:26.597135498 +0200\n+++ /tmp/tmpzf9nd6zc.java\t2022-07-12 16:19:26.601135478 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:28.069128439 +0200\n+++ /tmp/tmpi47k6ehi.java\t2022-07-12 16:19:28.069128439 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pospos - 1)!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:29.625120974 +0200\n+++ /tmp/tmprzbsgomf.java\t2022-07-12 16:19:29.625120974 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "while (pos < text.length()) || ((c = text.charAt(pospos - 1)!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:31.109113854 +0200\n+++ /tmp/tmpj9uq425n.java\t2022-07-12 16:19:31.109113854 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) || ((c = text.charAt(pospos - 1)!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:32.661106405 +0200\n+++ /tmp/tmpvifdxa_3.java\t2022-07-12 16:19:32.661106405 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length || ((c = text.charAt(pos))!='') && (c!= '\\n') || (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "while (pos < text.length()) || ((c =='') && (c!= '\\n') && (c!= '\\r')) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-32/src/main/java/org/apache/commons/cli/HelpFormatter.java\t2022-07-12 16:19:34.185099090 +0200\n+++ /tmp/tmp8x3swd46.java\t2022-07-12 16:19:34.185099090 +0200\n@@ -932,15 +932,11 @@\n             return pos;\n         }\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n-        {\n-            ++pos;\n-        }        \n+while (pos < text.length()) || ((c =='') && (c!= '\\n') && (c!= '\\r')) {\n         return pos == text.length() ? -1 : pos;\n     }\n \n     /**\n      * Return a String of padding of length <code>len</code>.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; }",
        "fixed_line": ""
    },
    "Mockito-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "return 0; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:19:35.933090701 +0200\n+++ /tmp/tmpx2zq6loe.java\t2022-07-12 16:19:36.037090199 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-literals\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return 0; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:20:13.532909772 +0200\n+++ /tmp/tmp8xin1kx9.java\t2022-07-12 16:20:13.532909772 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-closed\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return 0; // let's do implicit rereturnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:20:47.828744078 +0200\n+++ /tmp/tmpp7z975fg.java\t2022-07-12 16:20:47.828744078 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit rereturnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return 0; // let's do implicit re-returnType",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:21:22.148577672 +0200\n+++ /tmp/tmpbf9vo014.java\t2022-07-12 16:21:22.148577672 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-returnType\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return JsonToken.VALUE_NUMBER_INT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:21:56.872408743 +0200\n+++ /tmp/tmpmk2r79bm.java\t2022-07-12 16:21:56.872408743 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return 0; // let's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:21:59.568395605 +0200\n+++ /tmp/tmphhmbccuh.java\t2022-07-12 16:21:59.568395605 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-parse\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return JsonToken.VALUE_NUMBER_FLOAT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:22:34.040227338 +0200\n+++ /tmp/tmpgysschek.java\t2022-07-12 16:22:34.040227338 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_FLOAT;\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-literals",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:22:36.744214118 +0200\n+++ /tmp/tmp2gu9skow.java\t2022-07-12 16:22:36.744214118 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-literals\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return 0; // let's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:22:39.392201171 +0200\n+++ /tmp/tmp76iopo2e.java\t2022-07-12 16:22:39.396201149 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return 0; // let's do implicit re-initialized or EMPTY\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-closed",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-24/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\t2022-07-12 16:23:13.792032696 +0200\n+++ /tmp/tmp_tchgzqk.java\t2022-07-12 16:23:13.796032677 +0200\n@@ -71,11 +71,11 @@\n             }\n         } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n             //see issue 184.\n             //mocks by default should return 0 if references are the same, otherwise some other value because they are not the same. Hence we return 1 (anything but 0 is good).\n             //Only for compareTo() method by the Comparable interface\n-            return 1;\n+return JsonToken.VALUE_NUMBER_INT; // let's do implicit re-closed\n         }\n         \n         Class<?> returnType = invocation.getMethod().getReturnType();\n         return returnValueFor(returnType);\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;"
    },
    "Closure-69": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (type == TYPE_NOT_CALLABLE) {",
                "patch_diff": "} else if (type == TYPE_NOT_CALLABLE) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n, functionType);",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n, functionType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType.getReturnType());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType);",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, childType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n.getReturnType());",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n.getReturnType());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n, functionType.toString());",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n, functionType.toString());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// should never be called with explcit 'this' types must be called in a GETPROP",
                "patch_diff": "// should never be called with explcit 'this' types must be called in a GETPROP",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// should never be called with explcit 'this' types must be called in a GETPROP // or GET",
                "patch_diff": "// should never be called with explcit 'this' types must be called in a GETPROP // or GET",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n);",
                "patch_diff": "} else if (t, n, CONSTRUCTOR_NOT_CALLABLE, n);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (functionType.isOrdinaryFunction() && !functionType.getTypeOfThis().isUnknownType() && !functionType.getTypeOfThis().isNativeObjectType() && !(child.getType() == Token.GETELEM || child.getType() == Token.GETPROP)) { report(t, n, EXPECTED_THIS_TYPE, functionType.toString()); }"
    },
    "JacksonDatabind-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "sb.append(_valueType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:18.388010153 +0200\n+++ /tmp/tmp9cyk1dhg.java\t2022-07-12 16:23:18.432009939 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_valueType;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "sb.append(_ns;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:20.224001147 +0200\n+++ /tmp/tmp908ru7h7.java\t2022-07-12 16:23:20.228001125 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_ns;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "sb.append(_append;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:21.819993315 +0200\n+++ /tmp/tmpzbeiq32u.java\t2022-07-12 16:23:21.819993315 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_append;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "sb.append(_valueType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:23.419985462 +0200\n+++ /tmp/tmpc_03agcu.java\t2022-07-12 16:23:23.419985462 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_valueType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "sb.append(_referencedType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:25.087977274 +0200\n+++ /tmp/tmpm2ienk28.java\t2022-07-12 16:23:25.087977274 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_referencedType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "sb.append(_defaultNewLine;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:26.723969244 +0200\n+++ /tmp/tmpxb6t00o4.java\t2022-07-12 16:23:26.723969244 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_defaultNewLine;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "sb.append(_appendType;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:28.247961763 +0200\n+++ /tmp/tmpj9irnvw5.java\t2022-07-12 16:23:28.247961763 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_appendType;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "sb.append(_ns;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:29.791954182 +0200\n+++ /tmp/tmpnbalk6hl.java\t2022-07-12 16:23:29.791954182 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_ns;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "sb.append(_defaultNewLine;');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:31.391946325 +0200\n+++ /tmp/tmphqorbp88.java\t2022-07-12 16:23:31.391946325 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_defaultNewLine;');\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "sb.append(_referencedType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-46/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\t2022-07-12 16:23:33.027938290 +0200\n+++ /tmp/tmpbv_fehjb.java\t2022-07-12 16:23:33.027938290 +0200\n@@ -151,11 +151,11 @@\n     public StringBuilder getGenericSignature(StringBuilder sb)\n     {\n         _classSignature(_class, sb, false);\n         sb.append('<');\n         sb = _referencedType.getGenericSignature(sb);\n-        sb.append(';');\n+sb.append(_referencedType;\n         return sb;\n     }\n     \n     /*\n     /**********************************************************\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "sb.append(';');",
        "fixed_line": "sb.append(\">;\");"
    },
    "Lang-53": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:34.923928978 +0200\n+++ /tmp/tmpdy0hsvt_.java\t2022-07-12 16:23:34.979928703 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:36.719920156 +0200\n+++ /tmp/tmp8dkw0u2g.java\t2022-07-12 16:23:36.723920136 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:38.315912317 +0200\n+++ /tmp/tmp2pua1now.java\t2022-07-12 16:23:38.315912317 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:39.879904631 +0200\n+++ /tmp/tmpnxzyrvre.java\t2022-07-12 16:23:39.879904631 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:41.403897142 +0200\n+++ /tmp/tmpxqwbk6it.java\t2022-07-12 16:23:41.407897123 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || minutes < 30 || seconds > 59) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MILLIS_PER_MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:42.967889455 +0200\n+++ /tmp/tmpdssn_yhp.java\t2022-07-12 16:23:42.971889437 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MILLIS_PER_MINUTE;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MINUTE || minutes == Calendar.MINUTE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:44.503881904 +0200\n+++ /tmp/tmp_lm3i_1r.java\t2022-07-12 16:23:44.507881885 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (seconds = val.get(Calendar.SECOND - 1) * DateTimeConstants.MINUTE || minutes == Calendar.MINUTE;\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (field.get(Calendar.SECOND) && (!round || minutes < 30) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:46.103874039 +0200\n+++ /tmp/tmpr2g3a89f.java\t2022-07-12 16:23:46.103874039 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field.get(Calendar.SECOND) && (!round || minutes < 30) {\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (field == val.SECOND && (!round || minutes < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:47.675866313 +0200\n+++ /tmp/tmpji8r08i5.java\t2022-07-12 16:23:47.675866313 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.SECOND && (!round || minutes < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (field == val.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-53/src/java/org/apache/commons/lang/time/DateUtils.java\t2022-07-12 16:23:49.199858818 +0200\n+++ /tmp/tmpgnnyf5xg.java\t2022-07-12 16:23:49.199858818 +0200\n@@ -640,20 +640,11 @@\n         int millisecs = val.get(Calendar.MILLISECOND);\n         if (!round || millisecs < 500) {\n             time = time - millisecs;\n         if (field == Calendar.SECOND) {\n             done = true;\n-            }\n-        }\n-\n-        // truncate seconds\n-        int seconds = val.get(Calendar.SECOND);\n-        if (!done && (!round || seconds < 30)) {\n-            time = time - (seconds * 1000L);\n-        if (field == Calendar.MINUTE) {\n-            done = true;\n-            }\n+} else if (field == val.get(Calendar.SECOND) && (!round || seconds < 30 || seconds > 30 * 1000L; }\n         }\n \n         // truncate minutes\n         int minutes = val.get(Calendar.MINUTE);\n         if (!done && (!round || minutes < 30)) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); if (field == Calendar.MINUTE) { done = true; }",
        "fixed_line": "} if (field == Calendar.SECOND) { done = true; } // truncate seconds int seconds = val.get(Calendar.SECOND); if (!done && (!round || seconds < 30)) { time = time - (seconds * 1000L); }"
    },
    "JacksonDatabind-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (previous!= null && previous.equals(ann;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:50.927850321 +0200\n+++ /tmp/tmpv96dlfk8.java\t2022-07-12 16:23:51.023849848 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann;\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return previous!= null && previous.equals(ann;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:52.787841173 +0200\n+++ /tmp/tmp3liul1nz.java\t2022-07-12 16:23:52.787841173 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(ann;\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (previous!= null && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:54.399833245 +0200\n+++ /tmp/tmp3w1nfl7i.java\t2022-07-12 16:23:54.399833245 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (previous!= null && previous.equals(annName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:55.935825689 +0200\n+++ /tmp/tmpig720z7e.java\t2022-07-12 16:23:55.935825689 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(annName);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (previous!= null) && previous.equals(ann;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:57.635817327 +0200\n+++ /tmp/tmplut606y1.java\t2022-07-12 16:23:57.635817327 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann;\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (previous!= null && previous.equals(ann));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:23:59.215809551 +0200\n+++ /tmp/tmpt5troghk.java\t2022-07-12 16:23:59.215809551 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals(ann));\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return previous!= null && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:24:30.647654718 +0200\n+++ /tmp/tmplvdq3c1b.java\t2022-07-12 16:24:30.647654718 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (previous!= null) && previous.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:24:59.759511028 +0200\n+++ /tmp/tmpt66t6xeb.java\t2022-07-12 16:24:59.759511028 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null) && previous.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (previous!= null && previous.equals;ann.equals(ann);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:25:29.331364798 +0200\n+++ /tmp/tmptwv5oskk.java\t2022-07-12 16:25:29.335364776 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return (previous!= null && previous.equals;ann.equals(ann);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return previous!= null && previous.equals(annName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-16/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\t2022-07-12 16:25:30.875357155 +0200\n+++ /tmp/tmp_xtuc729.java\t2022-07-12 16:25:30.879357135 +0200\n@@ -107,10 +107,10 @@\n     protected final boolean _add(Annotation ann) {\n         if (_annotations == null) {\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+return previous!= null && previous.equals(annName);\n     }\n }\n \n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (previous != null) && previous.equals(ann);",
        "fixed_line": "return (previous == null) || !previous.equals(ann);"
    },
    "Closure-112": {
        "fixes": [
            {
                "k": 1,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:25:32.719348027 +0200\n+++ /tmp/tmp4mowlwdh.java\t2022-07-12 16:25:32.803347609 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:26:27.095078440 +0200\n+++ /tmp/tmpmo7z46b4.java\t2022-07-12 16:26:27.095078440 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:17.198829352 +0200\n+++ /tmp/tmp51qyyvmp.java\t2022-07-12 16:27:17.198829352 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:20.938810737 +0200\n+++ /tmp/tmpx2iz7l8w.java\t2022-07-12 16:27:20.938810737 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:24.510792952 +0200\n+++ /tmp/tmprh2f2auj.java\t2022-07-12 16:27:24.510792952 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, templateTypeName);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, fnType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:28.154774805 +0200\n+++ /tmp/tmp5jaae8sq.java\t2022-07-12 16:27:28.154774805 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, fnType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:31.842756436 +0200\n+++ /tmp/tmp6mnnd4j0.java\t2022-07-12 16:27:31.842756436 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName, n);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:35.410738663 +0200\n+++ /tmp/tmpla_aimkh.java\t2022-07-12 16:27:35.410738663 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters( fnType, templateTypeName, n);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, templateType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:38.890721325 +0200\n+++ /tmp/tmpa0y9dn7f.java\t2022-07-12 16:27:38.890721325 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnNode, n, templateType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n, fnType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-112/src/com/google/javascript/jscomp/TypeInference.java\t2022-07-12 16:27:42.350704084 +0200\n+++ /tmp/tmph6rs39wi.java\t2022-07-12 16:27:42.350704084 +0200\n@@ -1187,12 +1187,11 @@\n     if (keys.isEmpty()) {\n       return false;\n     }\n \n     // Try to infer the template types\n-    Map<TemplateType, JSType> inferred = \n-        inferTemplateTypesFromParameters(fnType, n);\n+Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n, fnType);\n \n \n     // Replace all template types. If we couldn't find a replacement, we\n     // replace it with UNKNOWN.\n     TemplateTypeReplacer replacer = new TemplateTypeReplacer(\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Map<TemplateType, JSType> inferred = inferTemplateTypesFromParameters(fnType, n);",
        "fixed_line": "Map<TemplateType, JSType> inferred = Maps.filterKeys( inferTemplateTypesFromParameters(fnType, n), new Predicate<TemplateType>() { @Override public boolean apply(TemplateType key) { return keys.contains(key); }} );"
    },
    "Closure-65": {
        "fixes": [
            {
                "k": 1,
                "patch": "case '\\0': sb.append(\"\\\\0token; break, i.ch) break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:46.074685527 +0200\n+++ /tmp/tmpi8qksvl3.java\t2022-07-12 16:27:46.126685265 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0token; break, i.ch) break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "case '\\0': sb.append(\"\\\\0token; break = i.next) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:49.462668638 +0200\n+++ /tmp/tmpbskecmvx.java\t2022-07-12 16:27:49.462668638 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0token; break = i.next) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "case '\\0': sb.append(\"\\\\0token; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:51.986656057 +0200\n+++ /tmp/tmpnsoj5_my.java\t2022-07-12 16:27:51.986656057 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0token; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "case '\\0': sb.append(\"\\\\0FUNCTION; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:54.438643830 +0200\n+++ /tmp/tmpr2s64ob7.java\t2022-07-12 16:27:54.438643830 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0FUNCTION; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:56.854631784 +0200\n+++ /tmp/tmpuo_c_haz.java\t2022-07-12 16:27:56.854631784 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break, i.ch) break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:27:59.358619298 +0200\n+++ /tmp/tmp508n9_ho.java\t2022-07-12 16:27:59.358619298 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "case '\\0': sb = s.append(\"\\\\0token; break = i.next) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:28:01.846606890 +0200\n+++ /tmp/tmp322m_3q4.java\t2022-07-12 16:28:01.846606890 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0token; break = i.next) {\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "case '\\0': sb.append(\"\\\\0ListList; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:28:04.378594259 +0200\n+++ /tmp/tmphllmnvt8.java\t2022-07-12 16:28:04.378594259 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0ListList; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "case '\\0': sb = s.append(\"\\\\0\"); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:28:06.814582109 +0200\n+++ /tmp/tmpedbif21_.java\t2022-07-12 16:28:06.814582109 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb = s.append(\"\\\\0\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "case '\\0': sb.append(\"\\\\0List; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-65/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 16:28:09.706567681 +0200\n+++ /tmp/tmp7xagvan2.java\t2022-07-12 16:28:09.706567681 +0200\n@@ -1010,11 +1010,11 @@\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+case '\\0': sb.append(\"\\\\0List; break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;\n         case '\\\\': sb.append(backslashEscape); break;\n         case '\\\"': sb.append(doublequoteEscape); break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "case '\\0': sb.append(\"\\\\0\"); break;",
        "fixed_line": "case '\\0': sb.append(\"\\\\000\"); break;"
    },
    "Closure-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "addToSetIfLocal(lhs, gen, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "addToSetIfLocal(lhs, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (lhs.isVar(rhs, gen, kill, conditional);",
                "patch_diff": "} else if (lhs.isVar(rhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "addToSetIfLocal(rhs, gen, kill, conditional);",
                "patch_diff": "addToSetIfLocal(rhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (rhs.isVar(lhs, gen, kill, conditional);",
                "patch_diff": "} else if (rhs.isVar(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "addToSetIfLocal(lhs, gen, kill, conditional) {...}SetIfLocal(rhs, gen, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, gen, kill, conditional) {...}SetIfLocal(rhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (lhs.isVar(rhs, gen) {...}SetIfLocal(rhs, gen, kill, conditional);",
                "patch_diff": "} else if (lhs.isVar(rhs, gen) {...}SetIfLocal(rhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (rhs.isVar(lhs, gen, kill, conditional);",
                "patch_diff": "if (rhs.isVar(lhs, gen, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "addToSetIfLocal(lhs, gen, kill, conditional) {...}SetIfLocal(rhs, kill, conditional);",
                "patch_diff": "addToSetIfLocal(lhs, gen, kill, conditional) {...}SetIfLocal(rhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (lhs.isVar(rhs, gen) {...}SetIfLocal(rhs, kill, conditional);",
                "patch_diff": "} else if (lhs.isVar(rhs, gen) {...}SetIfLocal(rhs, kill, conditional);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (NodeUtil.isName(lhs)) { addToSetIfLocal(lhs, kill); addToSetIfLocal(lhs, gen); } else { computeGenKill(lhs, gen, kill, conditional); }"
    },
    "JacksonXml-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "_currText = _parsingContext.getText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:14.234545084 +0200\n+++ /tmp/tmpsyqn8k1b.java\t2022-07-12 16:28:14.270544905 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_currText = JsonToken.getText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:16.502533769 +0200\n+++ /tmp/tmp0h476eig.java\t2022-07-12 16:28:16.502533769 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = JsonToken.getText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:18.162525481 +0200\n+++ /tmp/tmp0_1wak2z.java\t2022-07-12 16:28:18.162525481 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_currText = _currText; break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:19.874516939 +0200\n+++ /tmp/tmpvqe0c25i.java\t2022-07-12 16:28:19.878516916 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:29.714467812 +0200\n+++ /tmp/tmp8t56buae.java\t2022-07-12 16:28:29.718467794 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_currText = _currText; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:31.302459882 +0200\n+++ /tmp/tmpf8_3802z.java\t2022-07-12 16:28:31.302459882 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _currText; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_currText = _parsingContext.getText();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:32.906451874 +0200\n+++ /tmp/tmp53bklx3u.java\t2022-07-12 16:28:32.910451851 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText();\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:34.522443801 +0200\n+++ /tmp/tmp6rayg4n1.java\t2022-07-12 16:28:34.522443801 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = JsonToken.VALUE_STRING; break = JsonToken.VALUE_STRING;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.getText;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:36.054436149 +0200\n+++ /tmp/tmp1r4qfzpc.java\t2022-07-12 16:28:36.054436149 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); _currText = JsonToken.VALUE_STRING; break = JsonToken.getText;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_currText = _parsingContext.getText(); break;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-3/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\t2022-07-12 16:28:37.514428859 +0200\n+++ /tmp/tmp1jlb42s9.java\t2022-07-12 16:28:37.514428859 +0200\n@@ -664,13 +664,11 @@\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n             }\n             break;\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n-            _currText = _xmlTokens.getText();\n-            _currToken = JsonToken.VALUE_STRING;\n-            break;\n+_currText = _parsingContext.getText(); break;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n                 _mayBeLeaf = false;\n                 // Also: must skip following END_ELEMENT\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "_currText = _xmlTokens.getText(); _currToken = JsonToken.VALUE_STRING; break;",
        "fixed_line": "return (_currText = _xmlTokens.getText());"
    },
    "JxPath-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "return containsMatch((Iterator) right,",
                "patch_diff": "return containsMatch((Iterator) right,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (o instanceof SelfContext) {",
                "patch_diff": "if (o instanceof SelfContext) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return containsMatch((Iterator == rd? -1 : ld;",
                "patch_diff": "return containsMatch((Iterator == rd? -1 : ld;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return containsMatch((Iterator == rd? 0 : ld) {",
                "patch_diff": "return containsMatch((Iterator == rd? 0 : ld) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return containsMatch((Iterator == rd? -1 : ld) {",
                "patch_diff": "return containsMatch((Iterator == rd? -1 : ld) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return containsMatch((type == rd? -1 : ld;",
                "patch_diff": "return containsMatch((type == rd? -1 : ld;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return containsMatch((Iterator == rd? 0 : ld;",
                "patch_diff": "return containsMatch((Iterator == rd? 0 : ld;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return containsMatch((Iterator) right, rd) {",
                "patch_diff": "return containsMatch((Iterator) right, rd) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return containsMatch((type == rd? -1 : ld) {",
                "patch_diff": "return containsMatch((type == rd? -1 : ld) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return containsMatch((Iterator == rd? 0 : rhs;",
                "patch_diff": "return containsMatch((Iterator == rd? 0 : rhs;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(ld)) { return false; } double rd = InfoSetUtil.doubleValue(right); if (Double.isNaN(rd)) { return false; }"
    },
    "Lang-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "int len = Character.length; pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:40.934411773 +0200\n+++ /tmp/tmpkoopeb86.java\t2022-07-12 16:28:40.970411596 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int len = Character.length; pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:42.758402662 +0200\n+++ /tmp/tmpw0k9x8sp.java\t2022-07-12 16:28:42.758402662 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int len = Character.length - pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:44.218395365 +0200\n+++ /tmp/tmpqsg03mrs.java\t2022-07-12 16:28:44.218395365 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int len = Character.length - pos pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:45.826387331 +0200\n+++ /tmp/tmpa_k2guzg.java\t2022-07-12 16:28:45.826387331 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int len = Character.length; pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:47.278380078 +0200\n+++ /tmp/tmpljackyrq.java\t2022-07-12 16:28:47.278380078 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int len = Character.length; pos pos pos pos pos < len;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:48.754372702 +0200\n+++ /tmp/tmpsk6d5_9t.java\t2022-07-12 16:28:48.754372702 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length; pos pos pos pos pos < len;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int len = Character.length - pos]; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:50.178365584 +0200\n+++ /tmp/tmpbk9tnsqk.java\t2022-07-12 16:28:50.178365584 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos]; }\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int len = Character.codePointCount, 0, pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:51.734357806 +0200\n+++ /tmp/tmpn3yhm4tp.java\t2022-07-12 16:28:51.734357806 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.codePointCount, 0, pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int len = Character.length - pos pos pos;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:53.214350412 +0200\n+++ /tmp/tmp9slx4fcp.java\t2022-07-12 16:28:53.214350412 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos pos pos;\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int len = Character.length - pos];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-17/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 16:28:54.686343052 +0200\n+++ /tmp/tmp0r6nxczh.java\t2022-07-12 16:28:54.686343052 +0200\n@@ -78,30 +78,11 @@\n         }\n         if (input == null) {\n             return;\n         }\n         int pos = 0;\n-        int len = Character.codePointCount(input, 0, input.length());\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-            }\n-            else {\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                    if (pos < len - 2) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n-                    } else {\n-                        pos++;\n-                    }\n-                }\n-                pos--;\n-            }\n-            pos++;\n+int len = Character.length - pos];\n         }\n     }\n \n     /**\n      * Helper method to create a merger of this translator with another set of \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int len = Character.codePointCount(input, 0, input.length()); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); } else { // // contract with translators is that they have to understand codepoints // // and they just took care of a surrogate pair for (int pt = 0; pt < consumed; pt++) { if (pos < len - 2) { pos += Character.charCount(Character.codePointAt(input, pos)); } else { pos++; } } pos--; } pos++;",
        "fixed_line": "int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue;"
    },
    "Closure-121": {
        "fixes": [
            {
                "k": 1,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate.references;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:28:56.358334694 +0200\n+++ /tmp/tmpib_6038e.java\t2022-07-12 16:28:56.386334557 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate.references;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "referenceInfo.isAssignedOnceInLit(candidate) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:01.342309781 +0200\n+++ /tmp/tmph7mkvsct.java\t2022-07-12 16:29:01.342309781 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit(candidate) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "referenceInfo.isAssignedOnceInLvisible;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:04.830292338 +0200\n+++ /tmp/tmp3nnt39th.java\t2022-07-12 16:29:04.830292338 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLvisible;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "referenceInfo.isAssignedOnceInLit(candidate)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:08.218275399 +0200\n+++ /tmp/tmpk3unitjj.java\t2022-07-12 16:29:08.218275399 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit(candidate)) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:11.950256731 +0200\n+++ /tmp/tmprmnon362.java\t2022-07-12 16:29:11.950256731 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "referenceInfo.isAssignedOnceInLTA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:15.262240167 +0200\n+++ /tmp/tmpdcekl8b5.java\t2022-07-12 16:29:15.262240167 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLTA;\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "referenceInfo.isAssignedOnceInLifetime()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:29:18.798222477 +0200\n+++ /tmp/tmpvzxcozmi.java\t2022-07-12 16:29:18.798222477 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLifetime()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "referenceInfo.isAssignedOnceInLTA; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:30:11.433958889 +0200\n+++ /tmp/tmp0ngj_bjw.java\t2022-07-12 16:30:11.433958889 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLTA; {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "referenceInfo.isAssignedOnceInLit()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:30:14.989941064 +0200\n+++ /tmp/tmpbf_9jtbk.java\t2022-07-12 16:30:14.989941064 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit()) {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "referenceInfo.isAssignedOnceInLit = candidate.references; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-121/src/com/google/javascript/jscomp/InlineVariables.java\t2022-07-12 16:30:18.769922115 +0200\n+++ /tmp/tmpzy6ftzyk.java\t2022-07-12 16:30:18.773922093 +0200\n@@ -299,11 +299,11 @@\n       // reference data is out of sync. We're better off just waiting for\n       // the next pass.)\n       if (!maybeModifiedArguments &&\n           !staleVars.contains(v) &&\n           referenceInfo.isWellDefined() &&\n-          referenceInfo.isAssignedOnceInLifetime()) {\n+referenceInfo.isAssignedOnceInLit = candidate.references; {\n           // Inlining the variable based solely on well-defined and assigned\n           // once is *NOT* correct. We relax the correctness requirement if\n           // the variable is declared constant.\n         List<Reference> refs = referenceInfo.references;\n         for (int i = 1 /* start from a read */; i < refs.size(); i++) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "referenceInfo.isAssignedOnceInLifetime()) {",
        "fixed_line": "referenceInfo.isAssignedOnceInLifetime() && // Inlining the variable based solely on well-defined and assigned // once is *NOT* correct. We relax the correctness requirement if // the variable is declared constant. (isInlineableDeclaredConstant(v, referenceInfo) || referenceInfo.isOnlyAssignmentSameScopeAsDeclaration())) {"
    },
    "Time-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "Partial newPartial = newPartial(minChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:22.469903561 +0200\n+++ /tmp/tmps1yhwj7q.java\t2022-07-12 16:30:22.513903344 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(minChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:24.677892491 +0200\n+++ /tmp/tmpc9_8bbn0.java\t2022-07-12 16:30:24.677892491 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Partial newPartial = new Partial[iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:35.361838908 +0200\n+++ /tmp/tmpbt59ew4c.java\t2022-07-12 16:30:35.361838908 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial[iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Partial newPartial = new PartialContext, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:36.965830861 +0200\n+++ /tmp/tmpp_trviyz.java\t2022-07-12 16:30:36.965830861 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new PartialContext, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Partial newPartial = new Partial(iChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:38.525823036 +0200\n+++ /tmp/tmp167fkie2.java\t2022-07-12 16:30:38.525823036 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(iChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Partial newPartial = new Partial; iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:40.221814527 +0200\n+++ /tmp/tmpgrosefgn.java\t2022-07-12 16:30:40.221814527 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial; iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Partial newPartial = new Partial(0, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:41.721807002 +0200\n+++ /tmp/tmpv9rc9_mp.java\t2022-07-12 16:30:41.721807002 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial(0, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Partial newPartial = newPartial(iChronology, newTypes, newValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:43.513798011 +0200\n+++ /tmp/tmp0tnnqkvs.java\t2022-07-12 16:30:43.517797990 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(iChronology, newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Partial newPartial = newPartial(minChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:45.341788838 +0200\n+++ /tmp/tmpodhn6st3.java\t2022-07-12 16:30:45.341788838 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = newPartial(minChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Partial newPartial = new Partial[iChronology, newTypes, newValues;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-4/src/main/java/org/joda/time/Partial.java\t2022-07-12 16:30:46.805781492 +0200\n+++ /tmp/tmpa7yxclrt.java\t2022-07-12 16:30:46.809781471 +0200\n@@ -459,11 +459,11 @@\n             newValues[i] = value;\n             System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+Partial newPartial = new Partial[iChronology, newTypes, newValues;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }\n         if (value == getValue(index)) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Partial newPartial = new Partial(iChronology, newTypes, newValues);",
        "fixed_line": "Partial newPartial = new Partial(newTypes, newValues, iChronology);"
    },
    "Math-102": {
        "fixes": [
            {
                "k": 1,
                "patch": "return dev; double dev = 0.0d;",
                "patch_diff": "return dev; double dev = 0.0d;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < expected[i]; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < expected[i]; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < n; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < n; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < expected.length; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < expected.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return dev; double dSq = 0.0d;",
                "patch_diff": "return dev; double dSq = 0.0d;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < classes.length; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < classes.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < v.length; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < v.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < expected[i]); i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < expected[i]); i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < alphaSize; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < alphaSize; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return dev; double dev = 0.0d; for (int i = 0; i < m.length; i++) {",
                "patch_diff": "return dev; double dev = 0.0d; for (int i = 0; i < m.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "double sumExpected = 0d; double sumObserved = 0d; for (int i = 0; i < observed.length; i++) { sumExpected += expected[i]; sumObserved += observed[i]; } double ratio = 1.0d; boolean rescale = false; if (Math.abs(sumExpected - sumObserved) > 10E-6) { ratio = sumObserved / sumExpected; rescale = true; } double sumSq = 0.0d; double dev = 0.0d; for (int i = 0; i < observed.length; i++) { if (rescale) { dev = ((double) observed[i] - ratio * expected[i]); sumSq += dev * dev / (ratio * expected[i]); } else { dev = ((double) observed[i] - expected[i]); sumSq += dev * dev / expected[i]; }"
    },
    "Gson-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:50.529762804 +0200\n+++ /tmp/tmpodk97yv4.java\t2022-07-12 16:30:50.549762704 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:52.525752785 +0200\n+++ /tmp/tmpknph91ky.java\t2022-07-12 16:30:52.525752785 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE && value)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:54.381743471 +0200\n+++ /tmp/tmpt7azj033.java\t2022-07-12 16:30:54.381743471 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE && value)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (millis >= 1 && value <= Long.MIN_VALUE || negative == Long.MIN_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:56.125734717 +0200\n+++ /tmp/tmpb1cbkgqr.java\t2022-07-12 16:30:56.129734698 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && value <= Long.MIN_VALUE || negative == Long.MIN_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:57.877725923 +0200\n+++ /tmp/tmpogcwlfbp.java\t2022-07-12 16:30:57.881725904 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong && (value < Long.MIN_VALUE || negative > Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:30:59.561717469 +0200\n+++ /tmp/tmpbm5g66up.java\t2022-07-12 16:30:59.561717469 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value < Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative > Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:31:01.401708233 +0200\n+++ /tmp/tmpaso2bk9z.java\t2022-07-12 16:31:01.401708233 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative > Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MIN_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:31:03.161699396 +0200\n+++ /tmp/tmpl_3o2r6q.java\t2022-07-12 16:31:03.161699396 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MIN_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:31:04.801691163 +0200\n+++ /tmp/tmpo61fkqje.java\t2022-07-12 16:31:04.801691163 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && lowerBoundVal < Long.MIN_VALUE || negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MAX_VALUE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Gson-13/gson/src/main/java/com/google/gson/stream/JsonReader.java\t2022-07-12 16:31:06.425683009 +0200\n+++ /tmp/tmpdt2ql14s.java\t2022-07-12 16:31:06.425683009 +0200\n@@ -726,11 +726,11 @@\n         }\n       }\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+if (millis >= 1 && fitsInLong || (value instanceof Long.MIN_VALUE || negative == Long.MAX_VALUE) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;\n     } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n         || last == NUMBER_CHAR_EXP_DIGIT) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {",
        "fixed_line": "if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && (value!=0 || false==negative)) {"
    },
    "Jsoup-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "body().appendChild(new TextNode(\" \", \" + node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:08.221673991 +0200\n+++ /tmp/tmpsyitimp9.java\t2022-07-12 16:31:08.265673771 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "body.appendChild(new TextNode(\" \", \" + node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:10.617661960 +0200\n+++ /tmp/tmpq7tcs_go.java\t2022-07-12 16:31:10.617661960 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "body().appendChild(new TextNode(\" \", \" + node;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:12.233653843 +0200\n+++ /tmp/tmp75qz8j6h.java\t2022-07-12 16:31:12.237653824 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + node;\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "body().appendChild(new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:13.845645749 +0200\n+++ /tmp/tmp85y8v9cs.java\t2022-07-12 16:31:13.845645749 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "body.appendChild(new TextNode(\" \", \" + node;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:15.585637009 +0200\n+++ /tmp/tmpfvkjwjto.java\t2022-07-12 16:31:15.585637009 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + node;\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "body().appendChild(new TextNode(\" \", \" + body; node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:17.225628772 +0200\n+++ /tmp/tmpyzltj6tw.java\t2022-07-12 16:31:17.225628772 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\" \", \" + body; node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "body.appendChild(new TextNode(\" \", \" + body; node);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:18.701621359 +0200\n+++ /tmp/tmps_emgs8y.java\t2022-07-12 16:31:18.705621340 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\" \", \" + body; node);\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "body.appendChild(new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:20.289613383 +0200\n+++ /tmp/tmpmm3w7ktl.java\t2022-07-12 16:31:20.289613383 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body.appendChild(new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "body().appendChild(new TextNode(\"2), \"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:22.205603760 +0200\n+++ /tmp/tmp6w8bxc8a.java\t2022-07-12 16:31:22.205603760 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(new TextNode(\"2), \"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "body().appendChild(node, new TextNode(\"\"));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-1/src/main/java/org/jsoup/nodes/Document.java\t2022-07-12 16:31:23.681596345 +0200\n+++ /tmp/tmpya5r41si.java\t2022-07-12 16:31:23.681596345 +0200\n@@ -120,12 +120,11 @@\n             }\n         }\n \n         for (Node node: toMove) {\n             element.removeChild(node);\n-            body().appendChild(new TextNode(\" \", \"\"));\n-            body().appendChild(node);\n+body().appendChild(node, new TextNode(\"\"));\n         }\n     }\n \n     @Override\n     public String outerHtml() {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node);",
        "fixed_line": "body().prependChild(node); body().prependChild(new TextNode(\" \", \"\"));"
    },
    "Jsoup-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute).util.group(0.0, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:25.525587081 +0200\n+++ /tmp/tmp57_wh04m.java\t2022-07-12 16:31:25.669586357 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute).util.group(0.0, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "m.appendReplacement(accum, c, d.appendReplacement, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:27.809575606 +0200\n+++ /tmp/tmpsf6zkyax.java\t2022-07-12 16:31:27.813575585 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c, d.appendReplacement, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:29.645566381 +0200\n+++ /tmp/tmp16izbbm3.java\t2022-07-12 16:31:29.649566362 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "m.appendReplacement(accum, c.appendReplacement constraint, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:31.481557155 +0200\n+++ /tmp/tmpa4y0kz8s.java\t2022-07-12 16:31:31.481557155 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement constraint, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "m.appendReplacement(accum, c).appendReplacement {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:33.065549197 +0200\n+++ /tmp/tmpbtvmcema.java\t2022-07-12 16:31:33.065549197 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c).appendReplacement {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "m.appendReplacement(accum, c.appendReplacement raw, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:34.693541015 +0200\n+++ /tmp/tmpcji5q431.java\t2022-07-12 16:31:34.693541015 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement raw, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "m.appendReplacement(accum, c.appendReplacement(c, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:36.261533137 +0200\n+++ /tmp/tmpw8zr262y.java\t2022-07-12 16:31:36.261533137 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement(c, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0.0, m.group(0));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:37.937524714 +0200\n+++ /tmp/tmpk_w2l_ax.java\t2022-07-12 16:31:37.937524714 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacementAttribute, m.group(0.0, m.group(0));\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "m.appendReplacement(accum, c); } else if (c.appendReplacementf) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:39.485516934 +0200\n+++ /tmp/tmpn4y1fl8q.java\t2022-07-12 16:31:39.489516915 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c); } else if (c.appendReplacementf) {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "m.appendReplacement(accum, c.appendReplacement {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-6/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:31:41.213508249 +0200\n+++ /tmp/tmp7af7j85y.java\t2022-07-12 16:31:41.213508249 +0200\n@@ -65,13 +65,11 @@\n                     charval = full.get(name);\n             }\n \n             if (charval != -1 || charval > 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n-            } else {\n-                m.appendReplacement(accum, m.group(0));\n+m.appendReplacement(accum, c.appendReplacement {\n             }\n         }\n         m.appendTail(accum);\n         return accum.toString();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "m.appendReplacement(accum, c); } else { m.appendReplacement(accum, m.group(0));",
        "fixed_line": "m.appendReplacement(accum, Matcher.quoteReplacement(c)); } else { m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0))); // replace with original string"
    },
    "Mockito-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "return m1.equals(m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:31:43.189498317 +0200\n+++ /tmp/tmps0q0lvld.java\t2022-07-12 16:31:43.269497914 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return m1.equals(m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:31:45.797485207 +0200\n+++ /tmp/tmpsp1hoqzz.java\t2022-07-12 16:31:45.801485188 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return m1.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:31:47.745475415 +0200\n+++ /tmp/tmpstnfx48w.java\t2022-07-12 16:31:47.745475415 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:32:07.281377181 +0200\n+++ /tmp/tmpkh00yfwx.java\t2022-07-12 16:32:07.285377162 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return m1.equals(m2.equals(m2.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:32:26.181282098 +0200\n+++ /tmp/tmp4_7cg9hp.java\t2022-07-12 16:32:26.185282078 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return m1.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:32:28.129272296 +0200\n+++ /tmp/tmph2qt541r.java\t2022-07-12 16:32:28.129272296 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return m1.equals(m2.equals(m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:32:47.349175549 +0200\n+++ /tmp/tmp56um3gtv.java\t2022-07-12 16:32:47.349175549 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return m2.equals(m2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:32:49.421165119 +0200\n+++ /tmp/tmp7ibad9hc.java\t2022-07-12 16:32:49.425165097 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m2.equals(m2);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return m1.equals(m2.equals(m1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:33:08.457069250 +0200\n+++ /tmp/tmpdgq1o6a7.java\t2022-07-12 16:33:08.461069228 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m1));\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return m1.equals(m2.equals(m3.equals(m1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-33/src/org/mockito/internal/invocation/InvocationMatcher.java\t2022-07-12 16:33:26.020980755 +0200\n+++ /tmp/tmpajxtvgtd.java\t2022-07-12 16:33:26.020980755 +0200\n@@ -94,11 +94,11 @@\n         //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n         Method m1 = invocation.getMethod();\n         Method m2 = candidate.getMethod();\n         \n         \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+return m1.equals(m2.equals(m3.equals(m1);\n     }\n     \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return m1.equals(m2);",
        "fixed_line": "if (m1.getName() != null && m1.getName().equals(m2.getName())) { /* Avoid unnecessary cloning */ Class[] params1 = m1.getParameterTypes(); Class[] params2 = m2.getParameterTypes(); if (params1.length == params2.length) { for (int i = 0; i < params1.length; i++) { if (params1[i] != params2[i]) return false; } return true; } } return false;"
    },
    "Time-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "this(duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:33:27.924971161 +0200\n+++ /tmp/tmplg79nudc.java\t2022-07-12 16:33:27.956970996 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this(0, duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:33:39.972910435 +0200\n+++ /tmp/tmpq5p6jun2.java\t2022-07-12 16:33:39.972910435 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(0, duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this(duration, null, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:33:51.628851670 +0200\n+++ /tmp/tmpfzd38p1f.java\t2022-07-12 16:33:51.628851670 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this(duration, null, nullText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:33:54.296838215 +0200\n+++ /tmp/tmpi8a1sg17.java\t2022-07-12 16:33:55.024834546 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, nullText);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this(duration, null, nullText, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:33:58.168818691 +0200\n+++ /tmp/tmp24coznni.java\t2022-07-12 16:33:58.172818670 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, nullText, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.duration, null, null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:34:00.092808988 +0200\n+++ /tmp/tmpbk1o9oi_.java\t2022-07-12 16:34:00.092808988 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this.duration, null, null);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this(duration, null, millis);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:34:02.344797629 +0200\n+++ /tmp/tmpnuuu9j6r.java\t2022-07-12 16:34:02.344797629 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, millis);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this(duration, null, null;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:34:05.032784074 +0200\n+++ /tmp/tmpgxzoqo29.java\t2022-07-12 16:34:05.032784074 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null;\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this(duration, null, null });",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:34:07.512771564 +0200\n+++ /tmp/tmpm_wbturz.java\t2022-07-12 16:34:07.512771564 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null });\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this(duration, null, null, nullText);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-22/src/main/java/org/joda/time/base/BasePeriod.java\t2022-07-12 16:34:09.888759581 +0200\n+++ /tmp/tmpgydmsxyg.java\t2022-07-12 16:34:09.892759559 +0200\n@@ -217,11 +217,11 @@\n      * The calculation uses the hour, minute, second and millisecond fields.\n      *\n      * @param duration  the duration, in milliseconds\n      */\n     protected BasePeriod(long duration) {\n-        this(duration, null, null);\n+this(duration, null, null, nullText);\n         // bug [3264409]\n     }\n \n     /**\n      * Creates a period from the given millisecond duration, which is only really\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "this(duration, null, null);",
        "fixed_line": "super(); // bug [3264409] iType = PeriodType.time(); int[] values = ISOChronology.getInstanceUTC().get(this, duration); iType = PeriodType.standard(); iValues = new int[8]; System.arraycopy(values, 0, iValues, 4, 4);"
    },
    "Closure-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "patch_diff": "return Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return valid.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "patch_diff": "return valid.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "patch_diff": "return Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return true;",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "patch_diff": "return this.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: return;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return valid.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "patch_diff": "return valid.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case Token.BITNOT: case",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.ADD: case Token.BITAND: case Token.BITNOT: case Token.BITOR: case Token.BITXOR: case Token.DIV: case Token.EQ: case Token.GE: case Token.GT: case Token.LE: case Token.LSH: case Token.LT: case Token.MOD: case Token.MUL: case Token.NE: case Token.RSH: case Token.SHEQ: case Token.SHNE: case Token.SUB: case Token.URSH: return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines); // Uniary operators are valid if the child is valid. case Token.NOT: case Token.NEG: case Token.POS:"
    },
    "Mockito-21": {
        "fixes": [
            {
                "k": 1,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:34:16.852724447 +0200\n+++ /tmp/tmpq3joszv6.java\t2022-07-12 16:34:17.664720359 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:34:44.612584363 +0200\n+++ /tmp/tmpelkoobbz.java\t2022-07-12 16:34:44.612584363 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:34:55.584528975 +0200\n+++ /tmp/tmpz7pb3nbi.java\t2022-07-12 16:34:55.584528975 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:06.184475452 +0200\n+++ /tmp/tmp6g5fwtj1.java\t2022-07-12 16:35:06.184475452 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:15.552428141 +0200\n+++ /tmp/tmp3k_6mwmi.java\t2022-07-12 16:35:15.552428141 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:25.784376458 +0200\n+++ /tmp/tmp1tifiup9.java\t2022-07-12 16:35:25.784376458 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:36.272323472 +0200\n+++ /tmp/tmpchyzqizm.java\t2022-07-12 16:35:36.276323450 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls) {\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:46.928269626 +0200\n+++ /tmp/tmp_976vefl.java\t2022-07-12 16:35:46.928269626 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:35:56.608220704 +0200\n+++ /tmp/tmppbqj0meg.java\t2022-07-12 16:35:56.608220704 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-21/src/org/mockito/internal/creation/instance/ConstructorInstantiator.java\t2022-07-12 16:36:07.316166579 +0200\n+++ /tmp/tmphu8y8cr4.java\t2022-07-12 16:36:07.316166579 +0200\n@@ -12,19 +12,11 @@\n \n     public <T> T newInstance(Class<T> cls) {\n         if (outerClassInstance == null) {\n             return noArgConstructor(cls);\n         }\n-        return withOuterClass(cls);\n-    }\n-\n-    private <T> T withOuterClass(Class<T> cls) {\n-        try {\n-            //this is kind of overengineered because we don't need to support more params\n-            //however, I know we will be needing it :)\n-            Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass());\n-            return c.newInstance(outerClassInstance);\n+return cls;T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T withOuterClass<T>(cls;\n         } catch (Exception e) {\n             throw paramsException(cls, e);\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return withOuterClass(cls); } private <T> T withOuterClass(Class<T> cls) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) Constructor<T> c = cls.getDeclaredConstructor(outerClassInstance.getClass()); return c.newInstance(outerClassInstance);",
        "fixed_line": "return withParams(cls, outerClassInstance); } private static <T> T withParams(Class<T> cls, Object... params) { try { //this is kind of overengineered because we don't need to support more params //however, I know we will be needing it :) for (Constructor<?> constructor : cls.getDeclaredConstructors()) { Class<?>[] types = constructor.getParameterTypes(); if (paramsMatch(types, params)) { return (T) constructor.newInstance(params); } } } catch (Exception e) { throw paramsException(cls, e); } throw paramsException(cls, null); } private static <T> InstantationException paramsException(Class<T> cls, Exception e) { return new InstantationException(\"Unable to create mock instance of '\" + cls.getSimpleName() + \"'.\\nPlease ensure that the outer instance has correct type and that the target class has parameter-less constructor.\", e); } private static boolean paramsMatch(Class<?>[] types, Object[] params) { if (params.length != types.length) { return false; } for (int i = 0; i < params.length; i++) { if (!types[i].isInstance(params[i])) { return false; } } return true; }"
    },
    "Math-80": {
        "fixes": [
            {
                "k": 1,
                "patch": "int j = n / 3;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:17.896113089 +0200\n+++ /tmp/tmpjseh4jsv.java\t2022-07-12 16:36:18.184111633 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 3;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "int j = n / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:28.412059914 +0200\n+++ /tmp/tmp1za3uar6.java\t2022-07-12 16:36:28.412059914 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 2;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int j = n / 4 - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:35.020026496 +0200\n+++ /tmp/tmppdkipah7.java\t2022-07-12 16:36:35.020026496 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4 - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 4,
                "patch": "int j = k * n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:41.595993238 +0200\n+++ /tmp/tmp1vyhju0r.java\t2022-07-12 16:36:41.599993216 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int j = n / n - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:43.923981461 +0200\n+++ /tmp/tmpvtnhlbr8.java\t2022-07-12 16:36:43.923981461 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / n - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 6,
                "patch": "int j = k * n / 2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:50.559947893 +0200\n+++ /tmp/tmps355kq6g.java\t2022-07-12 16:36:50.563947875 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 2;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int j = n / 4;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:52.783936642 +0200\n+++ /tmp/tmpkvshxbxl.java\t2022-07-12 16:36:52.815936483 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 4;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int j = k * n / 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:36:59.491902708 +0200\n+++ /tmp/tmpkulevtqj.java\t2022-07-12 16:36:59.495902686 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int j = n / 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:37:01.707891494 +0200\n+++ /tmp/tmpp9ztx8h9.java\t2022-07-12 16:37:01.707891494 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = n / 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int j = k * n / 4 - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-80/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\t2022-07-12 16:37:08.291858181 +0200\n+++ /tmp/tmppoksb171.java\t2022-07-12 16:37:08.291858181 +0200\n@@ -1130,11 +1130,11 @@\n      * @return true if qd array was flipped\n      */\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+int j = k * n / 4 - 1;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];\n                     work[i + k] = work[j - k];\n                     work[j - k] = tmp;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int j = 4 * n - 1;",
        "fixed_line": "int j = 4 * (n - 1);"
    },
    "JacksonDatabind-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:37:10.707845956 +0200\n+++ /tmp/tmp4i31java.java\t2022-07-12 16:37:10.731845836 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (format.getShape()!= JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:37:50.583644118 +0200\n+++ /tmp/tmp6bjbfqsi.java\t2022-07-12 16:37:50.587644099 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape()!= JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (format.getShape() instanceof JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:38:26.883460286 +0200\n+++ /tmp/tmpirgvmpo5.java\t2022-07-12 16:38:26.887460268 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() instanceof JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (format.getShapeClass == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:38:28.575451717 +0200\n+++ /tmp/tmp9vd4z9lt.java\t2022-07-12 16:38:28.575451717 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeClass == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (format.getShapeType == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:38:30.255443207 +0200\n+++ /tmp/tmpxi9fbdce.java\t2022-07-12 16:38:30.255443207 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeType == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:38:31.995434391 +0200\n+++ /tmp/tmpxamf9bmt.java\t2022-07-12 16:38:31.995434391 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape() == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (format.getShapeCount == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:39:08.067251621 +0200\n+++ /tmp/tmpp6cmbmmv.java\t2022-07-12 16:39:08.071251599 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeCount == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (format.getShape == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:39:09.795242864 +0200\n+++ /tmp/tmppqna57na.java\t2022-07-12 16:39:09.795242864 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShape == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (format.getShapeOffset == JsonFormat.Shape.STRING) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:39:11.531234063 +0200\n+++ /tmp/tmpi93xbin3.java\t2022-07-12 16:39:11.531234063 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeOffset == JsonFormat.Shape.STRING) {\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (format.getShapeClass == JsonFormat.Shape.STRING) { // could still be null",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-45/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java\t2022-07-12 16:39:13.179225713 +0200\n+++ /tmp/tmpmq_idhxl.java\t2022-07-12 16:39:13.179225713 +0200\n@@ -58,11 +58,11 @@\n                 JsonFormat.Shape shape = format.getShape();\n                 if (shape.isNumeric()) {\n                     return withFormat(Boolean.TRUE, null);\n                 }\n \n-                if (format.getShape() == JsonFormat.Shape.STRING) {\n+if (format.getShapeClass == JsonFormat.Shape.STRING) { // could still be null\n                     TimeZone tz = format.getTimeZone();\n                     final String pattern = format.hasPattern()\n                                     ? format.getPattern()\n                                     : StdDateFormat.DATE_FORMAT_STR_ISO8601;\n                     final Locale loc = format.hasLocale()\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (format.getShape() == JsonFormat.Shape.STRING) {",
        "fixed_line": "if ((shape == JsonFormat.Shape.STRING) || format.hasPattern() || format.hasLocale() || format.hasTimeZone()) {"
    },
    "Closure-62": {
        "fixes": [
            {
                "k": 1,
                "patch": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:39:15.139215781 +0200\n+++ /tmp/tmpf0hoqa7w.java\t2022-07-12 16:39:15.163215657 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "&& 0 <= charno && charno < lineno;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:39:54.007018740 +0200\n+++ /tmp/tmpi3kplwv3.java\t2022-07-12 16:39:54.015018700 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < lineno;\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:39:57.351001784 +0200\n+++ /tmp/tmpd4zo_da8.java\t2022-07-12 16:39:57.355001762 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "&& 0 <= charno && charno < EOFcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:40:32.678822615 +0200\n+++ /tmp/tmplpzhjj67.java\t2022-07-12 16:40:32.690822551 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < EOFcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "&& 0 <= charno && charno < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:40:36.090805308 +0200\n+++ /tmp/tmpnv3z5prq.java\t2022-07-12 16:40:36.090805308 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < 0) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "&& 0 <= charno && charno < charno && charno < EOFcerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:41:11.434625985 +0200\n+++ /tmp/tmp75mm0m7f.java\t2022-07-12 16:41:11.446625927 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < EOFcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "&& 0 <= charno && charno < linenocerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:41:14.766609080 +0200\n+++ /tmp/tmp2qiaz0ih.java\t2022-07-12 16:41:14.770609057 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < linenocerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "&& 0 <= charno && charno < charno) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:41:18.150591908 +0200\n+++ /tmp/tmp2p5n_mji.java\t2022-07-12 16:41:18.154591885 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "&& 0 <= charno && charno < datacerpt.length()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:41:53.654411709 +0200\n+++ /tmp/tmpgeigqrac.java\t2022-07-12 16:41:53.670411626 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < datacerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "&& 0 <= charno && charno < charno && charno < lineno;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-62/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\t2022-07-12 16:41:57.086394284 +0200\n+++ /tmp/tmpkz47nb81.java\t2022-07-12 16:41:57.086394284 +0200\n@@ -93,11 +93,11 @@\n \n       // padding equal to the excerpt and arrow at the end\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+&& 0 <= charno && charno < charno && charno < lineno;\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {\n             b.append(c);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "&& 0 <= charno && charno < sourceExcerpt.length()) {",
        "fixed_line": "&& 0 <= charno && charno <= sourceExcerpt.length()) {"
    },
    "Math-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:00.706375910 +0200\n+++ /tmp/tmpdl5uxq8m.java\t2022-07-12 16:42:00.754375663 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return (a == b)? a : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:03.410362180 +0200\n+++ /tmp/tmp06v9k5aj.java\t2022-07-12 16:42:03.410362180 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return (a == b)? a : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:05.510351519 +0200\n+++ /tmp/tmpp4xwapbc.java\t2022-07-12 16:42:05.510351519 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return (a == b)? b : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:07.810339845 +0200\n+++ /tmp/tmpzkyhf883.java\t2022-07-12 16:42:07.810339845 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:09.998328735 +0200\n+++ /tmp/tmpo0u3lxek.java\t2022-07-12 16:42:10.002328717 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:12.150317812 +0200\n+++ /tmp/tmpppsqjgw9.java\t2022-07-12 16:42:12.154317789 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(b + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return (a < b)? a : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:14.454306111 +0200\n+++ /tmp/tmpdeerj4ww.java\t2022-07-12 16:42:14.454306111 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? a : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return (a < b)? b : (Float.isNaN(b + a)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:16.502295713 +0200\n+++ /tmp/tmp46y558wq.java\t2022-07-12 16:42:16.506295696 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a < b)? b : (Float.isNaN(b + a)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:18.694284587 +0200\n+++ /tmp/tmpjutzqg11.java\t2022-07-12 16:42:18.698284564 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? b : (Float.isNaN(a + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-59/src/main/java/org/apache/commons/math/util/FastMath.java\t2022-07-12 16:42:20.922273272 +0200\n+++ /tmp/tmpk7_8_ykp.java\t2022-07-12 16:42:20.926273254 +0200\n@@ -3477,11 +3477,11 @@\n      * @param a first value\n      * @param b second value\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return (a == b)? a : (Float.isNaN(a + b)? Float.NaN : b;\n     }\n \n     /** Compute the maximum of two values\n      * @param a first value\n      * @param b second value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
        "fixed_line": "return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);"
    },
    "Lang-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "return joinedArray = array1.length + array2.length;",
                "patch_diff": "return joinedArray = array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray, 0, array1.length);",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray, 0, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return joinedArray = (T[]) Array.newInstance(array1.length + array2.length;",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length);",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return joinedArray = (T[]) joinedArray.length + array1.length;",
                "patch_diff": "return joinedArray = (T[]) joinedArray.length + array1.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return joinedArray = (array1.length + array2.length;",
                "patch_diff": "return joinedArray = (array1.length + array2.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray.length);",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length, array2.length);",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length, array2.length);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray, 0, array1.length;",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array1, 0, joinedArray, 0, array1.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length;",
                "patch_diff": "return joinedArray = (T[]) Array.newInstance(array2, 0, joinedArray, array1.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { System.arraycopy(array2, 0, joinedArray, array1.length, array2.length); } catch (ArrayStoreException ase) { // Check if problem is incompatible types final Class<?> type2 = array2.getClass().getComponentType(); if (!type1.isAssignableFrom(type2)){ throw new IllegalArgumentException(\"Cannot store \"+type2.getName()+\" in an array of \"+type1.getName()); } throw ase; // No, so rethrow original }"
    },
    "Jsoup-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (info.inAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:25.034252391 +0200\n+++ /tmp/tmpovj1yxoi.java\t2022-07-12 16:42:25.146251824 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (info.inAttribute) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c == val) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:27.210241344 +0200\n+++ /tmp/tmph192nph7.java\t2022-07-12 16:42:27.210241344 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c == val) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (intr)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:28.662233972 +0200\n+++ /tmp/tmpo_h3i7bt.java\t2022-07-12 16:42:28.662233972 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (intr)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if ( accum) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:30.426225017 +0200\n+++ /tmp/tmpcwur7mc7.java\t2022-07-12 16:42:30.426225017 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if ( accum) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (info.inAttribute)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:31.926217398 +0200\n+++ /tmp/tmpzi_s5u51.java\t2022-07-12 16:42:31.926217398 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (info.inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (accum)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:33.582208991 +0200\n+++ /tmp/tmpa7wkutt1.java\t2022-07-12 16:42:33.586208969 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (accum)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (section) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:35.262200458 +0200\n+++ /tmp/tmpfqdsmonk.java\t2022-07-12 16:42:35.262200458 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (section) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:36.790192701 +0200\n+++ /tmp/tmpjka2luro.java\t2022-07-12 16:42:36.790192701 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c!= val) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:38.254185265 +0200\n+++ /tmp/tmpvqabzh7s.java\t2022-07-12 16:42:38.254185265 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (c!= val) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (intr) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-47/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 16:42:39.734177752 +0200\n+++ /tmp/tmp1539erj1.java\t2022-07-12 16:42:39.734177752 +0200\n@@ -117,11 +117,11 @@\n                         else\n                             accum.append(\"&#xa0;\");\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+if (intr) {\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);\n                         break;\n                     case '>':\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!inAttribute)",
        "fixed_line": "if (!inAttribute || escapeMode == EscapeMode.xhtml)"
    },
    "Closure-92": {
        "fixes": [
            {
                "k": 1,
                "patch": "int indexOfDot = info.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:41.354169523 +0200\n+++ /tmp/tmpefsglt_9.java\t2022-07-12 16:42:41.382169383 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = info.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int indexOfDot = this.rawNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:43.902156586 +0200\n+++ /tmp/tmpo4pzwajh.java\t2022-07-12 16:42:43.902156586 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.rawNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int indexOfDot = NodeUtil.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:45.726147323 +0200\n+++ /tmp/tmpnie3xh3q.java\t2022-07-12 16:42:45.726147323 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = NodeUtil.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int indexOfDot = map.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:47.542138099 +0200\n+++ /tmp/tmpy9niy70p.java\t2022-07-12 16:42:47.542138099 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = map.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int indexOfDot = this.namespaceNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:49.366128837 +0200\n+++ /tmp/tmp99li3rpj.java\t2022-07-12 16:42:49.366128837 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = this.namespaceNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int indexOfDot = classNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:51.198119534 +0200\n+++ /tmp/tmpdapl4vn5.java\t2022-07-12 16:42:51.198119534 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = classNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int indexOfDot = Node.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:52.954110616 +0200\n+++ /tmp/tmpi44f1d2y.java\t2022-07-12 16:42:52.954110616 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = Node.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int indexOfDot = nsNode.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:54.726101614 +0200\n+++ /tmp/tmph8j9cf3d.java\t2022-07-12 16:42:54.726101614 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = nsNode.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int indexOfDot = fn.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:56.498092617 +0200\n+++ /tmp/tmpba7bxk5r.java\t2022-07-12 16:42:56.498092617 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = fn.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int indexOfDot = code.indexOf('.');",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-92/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\t2022-07-12 16:42:58.322083351 +0200\n+++ /tmp/tmpy0ujda_s.java\t2022-07-12 16:42:58.322083351 +0200\n@@ -784,11 +784,11 @@\n         if (firstModule == minimumModule) {\n           firstNode.getParent().addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+int indexOfDot = code.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)\n                 .addChildToBack(replacementNode);\n           } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int indexOfDot = namespace.indexOf('.');",
        "fixed_line": "int indexOfDot = namespace.lastIndexOf('.');"
    },
    "Closure-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (parent.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:00.338073114 +0200\n+++ /tmp/tmpkfhqh915.java\t2022-07-12 16:43:00.374072928 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (rValue!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:05.318047818 +0200\n+++ /tmp/tmpxhod3ooh.java\t2022-07-12 16:43:05.318047818 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (parent.getJSType() == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:47.577833147 +0200\n+++ /tmp/tmpehcf0p6v.java\t2022-07-12 16:43:47.577833147 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType() == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (parent.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:51.325814106 +0200\n+++ /tmp/tmpbyhn8x7e.java\t2022-07-12 16:43:51.329814085 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (parent.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (type == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:54.905795915 +0200\n+++ /tmp/tmpqqb3tlc0.java\t2022-07-12 16:43:54.909795896 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (type == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:43:58.533777482 +0200\n+++ /tmp/tmpvf6ko21v.java\t2022-07-12 16:43:58.533777482 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType()!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:44:38.329575256 +0200\n+++ /tmp/tmp5tvyb8bs.java\t2022-07-12 16:44:38.329575256 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:45:18.093393027 +0200\n+++ /tmp/tmphoqldif0.java\t2022-07-12 16:45:18.093393027 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType() == null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (rValue.getJSType!= null &&!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:45:57.661214874 +0200\n+++ /tmp/tmptmfyu11_.java\t2022-07-12 16:45:57.665214857 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (rValue.getJSType!= null &&!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (instanceType == null ||!rValue.getJSType().isUnknownType()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-17/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 16:46:01.241198679 +0200\n+++ /tmp/tmpa7h0be8b.java\t2022-07-12 16:46:01.241198679 +0200\n@@ -1286,11 +1286,11 @@\n         } else {\n           // Check if this is constant, and if it has a known type.\n           if (info.isConstant()) {\n             JSType knownType = null;\n             if (rValue != null) {\n-              if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {\n+if (instanceType == null ||!rValue.getJSType().isUnknownType()) {\n                 // If rValue has a type-cast, we use the type in the type-cast.\n                 // If rValue's type was already computed during scope creation,\n                 // then we can safely use that.\n                 return rValue.getJSType();\n               } else if (rValue.isOr()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {",
        "fixed_line": "JSDocInfo rValueInfo = rValue.getJSDocInfo(); if (rValueInfo != null && rValueInfo.hasType()) { // If rValue has a type-cast, we use the type in the type-cast. return rValueInfo.getType().evaluate(scope, typeRegistry); } else if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {"
    },
    "JacksonDatabind-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] EASTER = _typeFactory;",
                "patch_diff": "private static final /*day*/int[] EASTER = _typeFactory;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tatu:: declaredType.isAssignableFrom(tatu:",
                "patch_diff": "if (tatu:: declaredType.isAssignableFrom(tatu:",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (; i!= JsonToken.VALUE_NUMBER_INT; i++) {",
                "patch_diff": "for (; i!= JsonToken.VALUE_NUMBER_INT; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] EASTER = _type;",
                "patch_diff": "private static final /*day*/int[] EASTER = _type;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0, len = value.length; i < len; ++i) {",
                "patch_diff": "for (int i = 0, len = value.length; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0, len = value.length; i < len;",
                "patch_diff": "for (int i = 0, len = value.length; i < len;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] EASTER = _value;",
                "patch_diff": "private static final /*day*/int[] EASTER = _value;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = 0, len = value.length; i < len; i++) {",
                "patch_diff": "for (int i = 0, len = value.length; i < len; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (; i!= JsonToken.VALUE_NUMBER_INT;",
                "patch_diff": "for (; i!= JsonToken.VALUE_NUMBER_INT;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (value == null) { writeNull(); return; } Class<?> raw = value.getClass(); if (raw == byte[].class) { _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); return; } else if (_objectCodec == null) { /* 28-May-2014, tatu: Tricky choice here; if no codec, should we * err out, or just embed? For now, do latter. */ // throw new JsonMappingException(\"No ObjectCodec configured for TokenBuffer, writeObject() called\"); _append(JsonToken.VALUE_EMBEDDED_OBJECT, value); } else { _objectCodec.writeValue(this, value); } } @Override public void writeTree(TreeNode node) throws IOException { if (node == null) { writeNull(); return; } if (_objectCodec == null) { // as with 'writeObject()', is codec optional? _append(JsonToken.VALUE_EMBEDDED_OBJECT, node); } else { _objectCodec.writeTree(this, node); }"
    },
    "Mockito-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "catch (e.mockito.Pie.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:06.649174187 +0200\n+++ /tmp/tmp8fx69eqy.java\t2022-07-12 16:46:06.729173824 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "catch (e.mockito.Pie.junit.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:22.801100875 +0200\n+++ /tmp/tmpf5i2bcud.java\t2022-07-12 16:46:22.801100875 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.class) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "catch (e.mockito.junit.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:30.929063890 +0200\n+++ /tmp/tmprcn08fcq.java\t2022-07-12 16:46:30.929063890 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.junit.class) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "catch (e.mockito.Pie.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:38.917027484 +0200\n+++ /tmp/tmp4kdy5vsu.java\t2022-07-12 16:46:38.921027464 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "catch (e.mockito.verification.junit.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:48.092985591 +0200\n+++ /tmp/tmpt6dqi8op.java\t2022-07-12 16:46:48.096985571 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.verification.junit.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "catch (e.mockito.junit.class.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:46:57.208943895 +0200\n+++ /tmp/tmpwou3oew6.java\t2022-07-12 16:46:57.208943895 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.junit.class.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "catch (e.mockito.verification.junit.CharAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:47:05.176907394 +0200\n+++ /tmp/tmpa7fm10jd.java\t2022-07-12 16:47:05.176907394 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.verification.junit.CharAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "catch (e.mockito.Pie.junit. containsValue.ArgumentsAreDifferent e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:47:14.436864901 +0200\n+++ /tmp/tmp4z0g2ius.java\t2022-07-12 16:47:14.436864901 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit. containsValue.ArgumentsAreDifferent e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "catch (e.mockito.verification.millisecond) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:47:23.504823224 +0200\n+++ /tmp/tmpwwuj0ikq.java\t2022-07-12 16:47:23.504823224 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.verification.millisecond) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "catch (e.mockito.Pie.junit, e) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-5/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\t2022-07-12 16:47:31.312787279 +0200\n+++ /tmp/tmpr3rcclho.java\t2022-07-12 16:47:31.312787279 +0200\n@@ -86,11 +86,11 @@\n                     error = null;\n                 }\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+catch (e.mockito.Pie.junit, e) {\n                 error = handleVerifyException(e);\n             }\n         }\n \n         if (error != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
        "fixed_line": "catch (AssertionError e) {"
    },
    "Closure-105": {
        "fixes": [
            {
                "k": 1,
                "patch": "StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:39.488749588 +0200\n+++ /tmp/tmp9axxassp.java\t2022-07-12 16:47:39.532749385 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "StringBuilder sb = new StringBuilder(\"{\") > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:41.460740490 +0200\n+++ /tmp/tmpjkds93j_.java\t2022-07-12 16:47:41.460740490 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(\"{\") > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "StringBuilder sb = new StringBuilder(16.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:43.076733030 +0200\n+++ /tmp/tmp5jvuw98a.java\t2022-07-12 16:47:43.076733030 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "StringBuilder sb = new StringBuilder.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:44.636725828 +0200\n+++ /tmp/tmpxl3daee8.java\t2022-07-12 16:47:44.636725828 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:46.232718459 +0200\n+++ /tmp/tmp1aw3bj0u.java\t2022-07-12 16:47:46.232718459 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem = arrayNode.length() > 0;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "StringBuilder sb = new StringBuilder(elem; // the type",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:47.872710883 +0200\n+++ /tmp/tmpafb6u8wt.java\t2022-07-12 16:47:47.872710883 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem; // the type\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "StringBuilder sb = new StringBuilder(16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:49.800701974 +0200\n+++ /tmp/tmp2fw25z2y.java\t2022-07-12 16:47:49.800701974 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "StringBuilder sb = new StringBuilder(elem;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:51.536693949 +0200\n+++ /tmp/tmpxcidvgjh.java\t2022-07-12 16:47:51.536693949 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem;\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "StringBuilder sb = new StringBuilder(16);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:53.304685776 +0200\n+++ /tmp/tmpuivpc00i.java\t2022-07-12 16:47:53.304685776 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(16);\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "StringBuilder sb = new StringBuilder(elem.length() > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-105/src/com/google/javascript/jscomp/FoldConstants.java\t2022-07-12 16:47:54.968678081 +0200\n+++ /tmp/tmpua5_9ovx.java\t2022-07-12 16:47:54.972678061 +0200\n@@ -1472,34 +1472,11 @@\n       return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n-    int foldedSize = 0;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n-    }\n-\n-    if (sb.length() > 0) {\n+StringBuilder sb = new StringBuilder(elem.length() > 0) {\n       // + 2 for the quotes.\n       foldedSize += sb.length() + 2;\n       arrayFoldedChildren.add(Node.newString(sb.toString()));\n     }\n     // one for each comma.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "StringBuilder sb = new StringBuilder(); int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb.length() > 0) { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb.length() > 0) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = new StringBuilder(); } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb.length() > 0) {",
        "fixed_line": "StringBuilder sb = null; int foldedSize = 0; Node elem = arrayNode.getFirstChild(); // Merges adjacent String nodes. while (elem != null) { if (NodeUtil.isImmutableValue(elem)) { if (sb == null) { sb = new StringBuilder(); } else { sb.append(joinString); } sb.append(NodeUtil.getStringValue(elem)); } else { if (sb != null) { // + 2 for the quotes. foldedSize += sb.length() + 2; arrayFoldedChildren.add(Node.newString(sb.toString())); sb = null; } foldedSize += InlineCostEstimator.getCost(elem); arrayFoldedChildren.add(elem); } elem = elem.getNext(); } if (sb != null) {"
    },
    "Lang-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (length == 0 || upper > 0) {",
                "patch_diff": "if (length == 0 || upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (upper == -1 || upper > 0) {",
                "patch_diff": "if (upper == -1 || upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (length == -1 || upper > 0) {",
                "patch_diff": "if (length == -1 || upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (upper == -1 || upper == -1) {",
                "patch_diff": "if (upper == -1 || upper == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (upper == -1 || upper > -1 || upper < 0) {",
                "patch_diff": "if (upper == -1 || upper > -1 || upper < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (length == 0 || upper == -1 || upper > 0) {",
                "patch_diff": "if (length == 0 || upper == -1 || upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (length == 0 || upper > -1 || upper < 0) {",
                "patch_diff": "if (length == 0 || upper > -1 || upper < 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (upper == -1 || upper > 0) {",
                "patch_diff": "} else if (upper == -1 || upper > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (upper == -1 || upper > -1) {",
                "patch_diff": "if (upper == -1 || upper > -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (length == 0 || upper == -1 || upper == -1) {",
                "patch_diff": "if (length == 0 || upper == -1 || upper == -1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (lower > str.length()) { lower = str.length(); }"
    },
    "Lang-33": {
        "fixes": [
            {
                "k": 1,
                "patch": "classes[i] = array[i].getClassLink;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:47:58.608661237 +0200\n+++ /tmp/tmpomr6r97t.java\t2022-07-12 16:47:58.660660997 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClassLink;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "classes[i] = array[i].getClass - 1].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:00.788651147 +0200\n+++ /tmp/tmp5m_rx_n9.java\t2022-07-12 16:48:00.788651147 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "classes[i] = array[i].getClass - 1].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:02.320644052 +0200\n+++ /tmp/tmpyj_5r1fi.java\t2022-07-12 16:48:02.320644052 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "classes[i] = array[i].getClass - 1].getClassLink;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:03.920636641 +0200\n+++ /tmp/tmpvooc14l3.java\t2022-07-12 16:48:03.920636641 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClassLink;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "classes[i] = array[i].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:05.548629099 +0200\n+++ /tmp/tmpp8ogyla1.java\t2022-07-12 16:48:05.548629099 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "classes[i] = array[i].getClass - 1].getClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:07.260621166 +0200\n+++ /tmp/tmp3p0inqyw.java\t2022-07-12 16:48:07.260621166 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "classes[i] = array[i].getClass();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:08.792614063 +0200\n+++ /tmp/tmpbhf31fot.java\t2022-07-12 16:48:08.792614063 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass();\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "classes[i] = array[i].getClass;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:18.788567683 +0200\n+++ /tmp/tmptduzjpjg.java\t2022-07-12 16:48:18.788567683 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "classes[i] = array[i].getClass - 1].getClass - 1].getClassVal;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:20.688558857 +0200\n+++ /tmp/tmpeai5k9ob.java\t2022-07-12 16:48:20.692558840 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass - 1].getClassVal;\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "classes[i] = array[i].getClass - 1].getClass(array[i]);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-33/src/main/java/org/apache/commons/lang3/ClassUtils.java\t2022-07-12 16:48:22.252551591 +0200\n+++ /tmp/tmpv1017ldk.java\t2022-07-12 16:48:22.252551591 +0200\n@@ -905,11 +905,11 @@\n         } else if (array.length == 0) {\n             return ArrayUtils.EMPTY_CLASS_ARRAY;\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+classes[i] = array[i].getClass - 1].getClass(array[i]);\n         }\n         return classes;\n     }\n \n     // Short canonical name\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "classes[i] = array[i].getClass();",
        "fixed_line": "classes[i] = array[i] == null ? null : array[i].getClass();"
    },
    "JacksonDatabind-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "final T getNullValue() { return _nullValue; }",
                "patch_diff": "final T getNullValue() { return _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final T getNullValue = _nullValue;",
                "patch_diff": "final T getNullValue = _nullValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return _nullValue; }",
                "patch_diff": "return _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final T getNullValue = _nullValue; }",
                "patch_diff": "final T getNullValue = _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final T getNullValue() {",
                "patch_diff": "final T getNullValue() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private final T getNullValue() { return _nullValue; }",
                "patch_diff": "private final T getNullValue() { return _nullValue; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return _nullValue;",
                "patch_diff": "return _nullValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final T getNullValue() { return _nullValue; } else {",
                "patch_diff": "final T getNullValue() { return _nullValue; } else {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final T getNullValue;",
                "patch_diff": "final T getNullValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping /*",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping /*",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public T getEmptyValue(DeserializationContext ctxt) throws JsonMappingException { // [databind#1095]: Should not allow coercion from into null from Empty String // either, if `null` not allowed if (_primitive && ctxt.isEnabled(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES)) { throw ctxt.mappingException( \"Can not map Empty String as null into type %s (set DeserializationConfig.DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES to 'false' to allow)\", handledType().toString()); } return _nullValue; }"
    },
    "JacksonDatabind-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:25.708535530 +0200\n+++ /tmp/tmpvmn_nl9n.java\t2022-07-12 16:48:25.780535196 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:27.632526585 +0200\n+++ /tmp/tmpp242p7a8.java\t2022-07-12 16:48:27.632526585 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:29.436518194 +0200\n+++ /tmp/tmpcu_n1jy5.java\t2022-07-12 16:48:29.436518194 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:31.044510714 +0200\n+++ /tmp/tmpt4uqxjwx.java\t2022-07-12 16:48:31.044510714 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am;\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:32.556503677 +0200\n+++ /tmp/tmpkghaa1wv.java\t2022-07-12 16:48:32.556503677 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:34.368495242 +0200\n+++ /tmp/tmpa62zfme_.java\t2022-07-12 16:48:34.368495242 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:35.936487944 +0200\n+++ /tmp/tmpmaohitlp.java\t2022-07-12 16:48:35.936487944 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am;\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:37.692479766 +0200\n+++ /tmp/tmp0fx2auwc.java\t2022-07-12 16:48:37.692479766 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(MapperFeature.CANONICALIZE_OVERRIDE, am);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:39.232472592 +0200\n+++ /tmp/tmpn1rd2__3.java\t2022-07-12 16:48:39.232472592 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am, declaredType);\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-64/src/main/java/com/fasterxml/jackson/databind/ser/PropertyBuilder.java\t2022-07-12 16:48:40.852465045 +0200\n+++ /tmp/tmpg5x9875p.java\t2022-07-12 16:48:40.852465045 +0200\n@@ -152,16 +152,11 @@\n \n             // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n             //    revert logic to the case of general/per-property handling, so both\n             //    type-default AND null are to be excluded.\n             //    (as per [databind#1417]\n-            if (_useRealPropertyDefaults) {\n-                // 07-Sep-2016, tatu: may also need to front-load access forcing now\n-                if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n-                    am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-                }\n-                valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n+if (tatu:: declaredType.isEnabled(Feature.CANONICALIZE_OVERRIDE, am)) {\n             } else {\n                 valueToSuppress = getDefaultValue(actualType);\n                 suppressNulls = true;\n             }\n             if (valueToSuppress == null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_useRealPropertyDefaults) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);",
        "fixed_line": "Object defaultBean; // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\", // revert logic to the case of general/per-property handling, so both // type-default AND null are to be excluded. // (as per [databind#1417] if (_useRealPropertyDefaults && (defaultBean = getDefaultBean()) != null) { // 07-Sep-2016, tatu: may also need to front-load access forcing now if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) { am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)); } try { valueToSuppress = am.getValue(defaultBean); } catch (Exception e) { _throwWrapped(e, propDef.getName(), defaultBean); }"
    },
    "Collections-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "class: \" + clazz, ex); }",
                "patch_diff": "class: \" + clazz, ex); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "class: \" + clazz, ex;",
                "patch_diff": "class: \" + clazz, ex;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (Exception ex",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (Exception ex",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (Exception ex",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; } catch (Exception ex",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; }",
                "patch_diff": "class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz, ex); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz); } catch (Exception ex) { throw new FunctorException(\"Cannot instantiate class: \" + clazz; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "private void readObject(ObjectInputStream is) throws IOException, ClassNotFoundException { is.defaultReadObject(); // ensure that the de-serialized class is a Collection, COLLECTIONS-580 if (clazz != null && !Collection.class.isAssignableFrom(clazz)) { throw new UnsupportedOperationException(); } }"
    },
    "Closure-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.remove /* declared iff there'sRoot || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:48:45.180444870 +0200\n+++ /tmp/tmpx7adq1gl.java\t2022-07-12 16:48:45.204444756 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.PopOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:48:50.152421676 +0200\n+++ /tmp/tmppzcejayu.java\t2022-07-12 16:48:50.156421659 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.PopOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.okOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:48:54.292402350 +0200\n+++ /tmp/tmpb_fh8x9o.java\t2022-07-12 16:48:54.292402350 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.okOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.PopOptions && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:48:58.128384433 +0200\n+++ /tmp/tmp24f6slx_.java\t2022-07-12 16:48:58.128384433 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.PopOptions && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.remove /* declared iff there'sRoot.closurePass && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:01.916366732 +0200\n+++ /tmp/tmps438clqh.java\t2022-07-12 16:49:01.916366732 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot.closurePass && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.OutlineOptions || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:05.552349729 +0200\n+++ /tmp/tmp4zmxcdc_.java\t2022-07-12 16:49:05.552349729 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.OutlineOptions || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.removeRequire && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:09.612330736 +0200\n+++ /tmp/tmpav5dpmxn.java\t2022-07-12 16:49:09.612330736 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.removeRequire && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options. version || options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:14.644307177 +0200\n+++ /tmp/tmp_8cuscue.java\t2022-07-12 16:49:14.648307161 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options. version || options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.instance && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:19.516284353 +0200\n+++ /tmp/tmpqlp9gu4f.java\t2022-07-12 16:49:19.536284260 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.instance && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.remove /* declared iff there'sRoot || options.closurePass && options.closurePass) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-18/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 16:49:24.984258719 +0200\n+++ /tmp/tmpg5cqec5_.java\t2022-07-12 16:49:25.016258569 +0200\n@@ -1283,11 +1283,11 @@\n \n       hoistExterns(externsRoot);\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+if (options.remove /* declared iff there'sRoot || options.closurePass && options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.\n           for (String provide : input.getProvides()) {\n             getTypeRegistry().forwardDeclareType(provide);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.dependencyOptions.needsManagement() && options.closurePass) {",
        "fixed_line": "if (options.dependencyOptions.needsManagement()) {"
    },
    "JacksonDatabind-9": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:30.004235163 +0200\n+++ /tmp/tmp15mpytog.java\t2022-07-12 16:49:30.280233869 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value instanceof Date instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:32.968221252 +0200\n+++ /tmp/tmpsm9a5yt4.java\t2022-07-12 16:49:32.968221252 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (value instanceof Date instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:35.624208777 +0200\n+++ /tmp/tmp7_z8t3gt.java\t2022-07-12 16:49:35.652208647 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (value instanceof Date)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:38.044197410 +0200\n+++ /tmp/tmpzhrckra5.java\t2022-07-12 16:49:38.044197410 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date)) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value instanceof Date instanceof Date)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:40.916183914 +0200\n+++ /tmp/tmp455nsdr5.java\t2022-07-12 16:49:40.948183762 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date instanceof Date)) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_value instanceof Date;DateKey) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:43.704170804 +0200\n+++ /tmp/tmpse9t9t45.java\t2022-07-12 16:49:43.704170804 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date;DateKey) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (_value instanceof Date instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:46.168159218 +0200\n+++ /tmp/tmppo29tqx9.java\t2022-07-12 16:49:46.212159015 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (_value instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:48.836146667 +0200\n+++ /tmp/tmpxaxbgacp.java\t2022-07-12 16:49:48.836146667 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (_value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value instanceof Date; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:51.676133301 +0200\n+++ /tmp/tmp2uvxngy2.java\t2022-07-12 16:49:51.708133151 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date; {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value instanceof Date) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-9/src/main/java/com/fasterxml/jackson/databind/ser/std/StdKeySerializer.java\t2022-07-12 16:49:54.256121152 +0200\n+++ /tmp/tmpnbx25wy6.java\t2022-07-12 16:49:54.256121152 +0200\n@@ -23,11 +23,11 @@\n \n     @Override\n     public void serialize(Object value, JsonGenerator jgen, SerializerProvider provider) throws IOException {\n         String str;\n         \n-        if (value instanceof Date) {\n+if (value instanceof Date) {\n             provider.defaultSerializeDateKey((Date) value, jgen);\n             return;\n         } else {\n             str = value.toString();\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value instanceof Date) {",
        "fixed_line": "Class<?> cls = value.getClass(); if (cls == String.class) { str = (String) value; } else if (Date.class.isAssignableFrom(cls)) { provider.defaultSerializeDateKey((Date) value, jgen); return; } else if (cls == Class.class) { str = ((Class<?>) value).getName();"
    },
    "Math-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] v) {",
                "patch_diff": "private static final /*day*/int[] v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "@Deprecated public void addValue(Comparable<?> v) {",
                "patch_diff": "@Deprecated public void addValue(Comparable<?> v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] v) { addValue((Comparable<?> v) v); }",
                "patch_diff": "private static final /*day*/int[] v) { addValue((Comparable<?> v) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] v) { addValue((Comparable<?>) v); }",
                "patch_diff": "private static final /*day*/int[] v) { addValue((Comparable<?>) v); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] v = this.getComponentType;",
                "patch_diff": "private static final /*day*/int[] v = this.getComponentType;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] v = {",
                "patch_diff": "private static final /*day*/int[] v = {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] v = this.getParsers;",
                "patch_diff": "private static final /*day*/int[] v = this.getParsers;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "@Deprecated(Comparable<?> v) {",
                "patch_diff": "@Deprecated(Comparable<?> v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] v) { addValue((Comparable<?>)v; }",
                "patch_diff": "private static final /*day*/int[] v) { addValue((Comparable<?>)v; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /*day*/int[] v) { addValue((Comparable<?>) v; }",
                "patch_diff": "private static final /*day*/int[] v) { addValue((Comparable<?>) v; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (v instanceof Comparable<?>){ addValue((Comparable<?>) v); } else { throw new IllegalArgumentException(\"Object must implement Comparable\"); }"
    },
    "Math-85": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (fa * fb!= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:50:32.451940856 +0200\n+++ /tmp/tmp75ivlf8x.java\t2022-07-12 16:50:32.735939512 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (fa * fb >= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:50:42.679892433 +0200\n+++ /tmp/tmpx9zrc5jy.java\t2022-07-12 16:50:42.731892186 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (fa * fb == 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:50:51.831849053 +0200\n+++ /tmp/tmpfosezs8d.java\t2022-07-12 16:50:51.835849034 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb == 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (fa * fb!= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:50:58.463817589 +0200\n+++ /tmp/tmpsukcl8bk.java\t2022-07-12 16:50:58.463817589 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb!= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (fa / fb!= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:05.135785910 +0200\n+++ /tmp/tmp4m9cjoiy.java\t2022-07-12 16:51:05.135785910 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa / fb!= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (fa * fb > 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:11.731754567 +0200\n+++ /tmp/tmp60hx_yx9.java\t2022-07-12 16:51:11.731754567 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 7,
                "patch": "if (fafa * fb >= 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:18.387722919 +0200\n+++ /tmp/tmpf7oced31.java\t2022-07-12 16:51:18.387722919 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fafa * fb >= 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (fa * fb >= 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:20.547712641 +0200\n+++ /tmp/tmpdkp80wjh.java\t2022-07-12 16:51:20.547712641 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (fa * fb > 0.0 ) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:27.327680372 +0200\n+++ /tmp/tmprx0m53y9.java\t2022-07-12 16:51:27.327680372 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (fa * fb >= 0.0){",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-85/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\t2022-07-12 16:51:33.843649335 +0200\n+++ /tmp/tmp_8f_kozi.java\t2022-07-12 16:51:33.847649315 +0200\n@@ -193,11 +193,11 @@\n             fb = function.value(b);\n             numIterations++ ;\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if (fa * fb >= 0.0){\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                       \"final b value={6}, f(a)={7}, f(b)={8}\",\n                       numIterations, maximumIterations, initial,\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fa * fb >= 0.0 ) {",
        "fixed_line": "if (fa * fb > 0.0 ) {"
    },
    "Closure-78": {
        "fixes": [
            {
                "k": 1,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:40.743616447 +0200\n+++ /tmp/tmps8jnvfbj.java\t2022-07-12 16:51:40.799616179 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:43.927601261 +0200\n+++ /tmp/tmpzwn0u9gv.java\t2022-07-12 16:51:43.927601261 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:46.563588686 +0200\n+++ /tmp/tmp_swaog41.java\t2022-07-12 16:51:46.563588686 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:49.199576108 +0200\n+++ /tmp/tmp54bk3kce.java\t2022-07-12 16:51:49.199576108 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0) {\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:51.643564442 +0200\n+++ /tmp/tmpcs_3f2ic.java\t2022-07-12 16:51:51.647564423 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:54.411551226 +0200\n+++ /tmp/tmpaje1fmgr.java\t2022-07-12 16:51:54.415551207 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right; break default\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:57.059538580 +0200\n+++ /tmp/tmpjn5a9bun.java\t2022-07-12 16:51:57.059538580 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by lval % rval == 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:51:59.635526275 +0200\n+++ /tmp/tmp5ikdld2z.java\t2022-07-12 16:51:59.635526275 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:52:02.407513029 +0200\n+++ /tmp/tmpgi5ote8d.java\t2022-07-12 16:52:02.411513009 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+error(JSType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-78/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 16:52:04.995500660 +0200\n+++ /tmp/tmpe9k2axo2.java\t2022-07-12 16:52:04.995500660 +0200\n@@ -706,18 +706,11 @@\n       case Token.MUL:\n         result = lval * rval;\n         break;\n       case Token.MOD:\n         if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+errorReporterType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), rightType.error;\n           return null;\n         }\n         result = lval / rval;\n         break;\n       default:\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right); return null; } result = lval % rval; break; case Token.DIV: if (rval == 0) { error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);",
        "fixed_line": ""
    },
    "Lang-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (count == 0 && end == 0) {",
                "patch_diff": "} else if (count == 0 && end == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (count == 0 &&!numbers) {",
                "patch_diff": "} else if (count == 0 &&!numbers) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (count == 0 && end == 0) {",
                "patch_diff": "if (count == 0 && end == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (start == 0 && end == 0) {",
                "patch_diff": "} else if (start == 0 && end == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (count == 0 && start == 0) {",
                "patch_diff": "} else if (count == 0 && start == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (count == 0 && start == 0) {",
                "patch_diff": "if (count == 0 && start == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (count == 0 &&!numbers.length == 0) {",
                "patch_diff": "} else if (count == 0 &&!numbers.length == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int start = 0; }",
                "patch_diff": "int start = 0; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int start = end + \" is less than 2 &&!numbers) {",
                "patch_diff": "int start = end + \" is less than 2 &&!numbers) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "else if (count == 0 && end == 0) {",
                "patch_diff": "else if (count == 0 && end == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (chars != null && chars.length == 0) { throw new IllegalArgumentException(\"The chars array must not be empty\"); } if (start == 0 && end == 0) { if (chars != null) { end = chars.length; } else { if (!letters && !numbers) { end = Integer.MAX_VALUE; } else { end = 'z' + 1; start = ' '; } }"
    },
    "Jsoup-45": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (\"-td\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:09.723478050 +0200\n+++ /tmp/tmpf9zyr15y.java\t2022-07-12 16:52:09.843477479 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (\"-i\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:11.739468409 +0200\n+++ /tmp/tmp6pmra5r6.java\t2022-07-12 16:52:11.739468409 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-i\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (\"-td\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:13.267461100 +0200\n+++ /tmp/tmpwizxmqtb.java\t2022-07-12 16:52:13.267461100 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (\"-name\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:14.855453503 +0200\n+++ /tmp/tmp7oapq8l2.java\t2022-07-12 16:52:14.883453369 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-name\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (\"+\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:16.775444315 +0200\n+++ /tmp/tmplh0myy_e.java\t2022-07-12 16:52:16.775444315 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"+\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (\"-i\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:18.299437021 +0200\n+++ /tmp/tmp9s_ub50p.java\t2022-07-12 16:52:18.303437002 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-i\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:19.883429438 +0200\n+++ /tmp/tmp2cvw5b0_.java\t2022-07-12 16:52:19.883429438 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if ((\"td\".equals(name) && \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (\"-name\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:24.263408467 +0200\n+++ /tmp/tmpbaapk35m.java\t2022-07-12 16:52:24.263408467 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-name\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (\"+\".equals(name) || \"td\".equals(name) &&!last)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:25.887400688 +0200\n+++ /tmp/tmpsdgpt0cz.java\t2022-07-12 16:52:25.887400688 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"+\".equals(name) || \"td\".equals(name) &&!last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (\"-td\".equals(name) && \"td\".equals(name) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-45/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\t2022-07-12 16:52:27.555392697 +0200\n+++ /tmp/tmp2tdt4s0j.java\t2022-07-12 16:52:27.555392697 +0200\n@@ -389,11 +389,11 @@\n             }\n             String name = node.nodeName();\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+} else if (\"-td\".equals(name) && \"td\".equals(name) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InRow);\n                 break;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
        "fixed_line": "} else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {"
    },
    "Lang-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "int start = 'z' + 1;",
                "patch_diff": "int start = 'z' + 1;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int start = 'z' + 1; }",
                "patch_diff": "int start = 'z' + 1; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int start = 'z' + 1; start =''; }",
                "patch_diff": "int start = 'z' + 1; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int start = 'z' + start =''; }",
                "patch_diff": "int start = 'z' + start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int start = 'z' + 2; start =''; }",
                "patch_diff": "int start = 'z' + 2; start =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int start = 'z' + 1; // end =''; }",
                "patch_diff": "int start = 'z' + 1; // end =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int start = 'z' + 1; end =''; }",
                "patch_diff": "int start = 'z' + 1; end =''; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int start = 'z' + start - end;",
                "patch_diff": "int start = 'z' + start - end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int start = 'z' + 1; start ='';",
                "patch_diff": "int start = 'z' + 1; start ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int start = 'z' + 1; // end ='';",
                "patch_diff": "int start = 'z' + 1; // end ='';",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else { if (end <= start) { throw new IllegalArgumentException(\"Parameter end (\" + end + \") must be greater than start (\" + start + \")\"); }"
    },
    "Jsoup-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:31.035376021 +0200\n+++ /tmp/tmpf1g3n_4u.java\t2022-07-12 16:52:31.103375702 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "clone.classNames if (clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:32.971366741 +0200\n+++ /tmp/tmpd9_e8y1h.java\t2022-07-12 16:52:32.975366725 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames if (clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "clone.classNames.cloneNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:34.675358574 +0200\n+++ /tmp/tmpjd_auxpf.java\t2022-07-12 16:52:34.675358574 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames.cloneNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "clone.classNamesFor(clone.classNames);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:36.787348449 +0200\n+++ /tmp/tmp00jrh8l0.java\t2022-07-12 16:52:36.787348449 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames);\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "clone.classNamesFor(clone.classNames;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:38.743339069 +0200\n+++ /tmp/tmprjnhkqum.java\t2022-07-12 16:52:38.743339069 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNames;\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "clone.classNames if (clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:40.247331855 +0200\n+++ /tmp/tmppcyqjqtc.java\t2022-07-12 16:52:40.247331855 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames if (clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "clone.classNamesFor(clone.classNamesFor(clone.classNames();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:42.027323316 +0200\n+++ /tmp/tmpi3gamzfq.java\t2022-07-12 16:52:42.027323316 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNamesFor(clone.classNames();\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "clone.classNames = clone;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:43.651315525 +0200\n+++ /tmp/tmpee_at_hz.java\t2022-07-12 16:52:43.651315525 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNames = clone;\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "clone.classNamesFor(clone.classNamesFor(this.classNames);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:45.599306178 +0200\n+++ /tmp/tmpx5rhz1mo.java\t2022-07-12 16:52:45.599306178 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor(clone.classNamesFor(this.classNames);\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "clone.classNamesFor!= clone.classNames;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-32/src/main/java/org/jsoup/nodes/Element.java\t2022-07-12 16:52:47.111298922 +0200\n+++ /tmp/tmpel4s3q70.java\t2022-07-12 16:52:47.111298922 +0200\n@@ -1133,9 +1133,9 @@\n     }\n \n     @Override\n     public Element clone() {\n         Element clone = (Element) super.clone();\n-        clone.classNames();\n+clone.classNamesFor!= clone.classNames;\n         return clone;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "clone.classNames();",
        "fixed_line": "clone.classNames = null; // derived on first hit, otherwise gets a pointer to source classnames"
    },
    "Chart-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "Object clone = createCopy(0, getItemCount) - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:52:48.923290222 +0200\n+++ /tmp/tmpsi4lx6ir.java\t2022-07-12 16:52:49.067289532 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount) - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Object clone = createCopy(0, getItemCount - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:52:51.215279219 +0200\n+++ /tmp/tmp7scoyck4.java\t2022-07-12 16:52:51.219279200 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Object clone = createCopy(0, getItemCount() - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:52:53.143269960 +0200\n+++ /tmp/tmpu1bfefnq.java\t2022-07-12 16:52:53.147269943 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Object clone = createCopy(0, getItemCount()-1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:03.139221934 +0200\n+++ /tmp/tmpnyj9yuwm.java\t2022-07-12 16:53:03.139221934 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount()-1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Object clone = createCopy(0, getItemCount * 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:11.351182451 +0200\n+++ /tmp/tmpq92oxw69.java\t2022-07-12 16:53:11.363182393 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount * 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Object clone = createCopy(0, getItemCount;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:13.363172771 +0200\n+++ /tmp/tmp0gmscojy.java\t2022-07-12 16:53:13.363172771 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount;\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Object clone = createCopy(0, getItemCount) - 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:15.155164150 +0200\n+++ /tmp/tmpjseb9r0u.java\t2022-07-12 16:53:15.155164150 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount) - 1;\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Object clone = createCopy(0, getItemCountID - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:16.911155699 +0200\n+++ /tmp/tmpkte56vu6.java\t2022-07-12 16:53:16.911155699 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCountID - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Object clone = createCopy(0, getItemCount% - 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:18.783146690 +0200\n+++ /tmp/tmp85vzewc3.java\t2022-07-12 16:53:18.783146690 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount% - 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Object clone = createCopy(0, getItemCount() * 1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-17/source/org/jfree/data/time/TimeSeries.java\t2022-07-12 16:53:20.699137467 +0200\n+++ /tmp/tmplew5wrwq.java\t2022-07-12 16:53:20.699137467 +0200\n@@ -852,11 +852,11 @@\n      * \n      * @throws CloneNotSupportedException not thrown by this class, but \n      *         subclasses may differ.\n      */\n     public Object clone() throws CloneNotSupportedException {\n-        Object clone = createCopy(0, getItemCount() - 1);\n+Object clone = createCopy(0, getItemCount() * 1);\n         return clone;\n     }\n \n     /**\n      * Creates a new timeseries by copying a subset of the data in this time\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "Object clone = createCopy(0, getItemCount() - 1);",
        "fixed_line": "TimeSeries clone = (TimeSeries) super.clone(); clone.data = (List) ObjectUtilities.deepClone(this.data);"
    },
    "Mockito-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); }",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) {",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } }",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOnData);",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOnData);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); } registerTypeVariablesOn(type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "patch_diff": "} else if (typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOnData); }",
                "patch_diff": "private static final /*day*/int[] type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOnData); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (typeVariableTypeVariables.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "patch_diff": "} else if (typeVariableTypeVariables.getBounds()) { registerTypeVariablesOn(type); } registerTypeVariablesOn(type); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "registerTypeParametersOn(new TypeVariable[] { typeVariable });"
    },
    "Collections-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "private Object readResolve; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:30.735089133 +0200\n+++ /tmp/tmps_lb8etb.java\t2022-07-12 16:53:30.755089036 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private Object readResolve = this.keys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:34.215072364 +0200\n+++ /tmp/tmpk7iujv8k.java\t2022-07-12 16:53:34.219072344 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.keys;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private Object readResolve = this;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:36.899059426 +0200\n+++ /tmp/tmp6kdg33w_.java\t2022-07-12 16:53:36.899059426 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private Object readResolve; keys) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:39.611046351 +0200\n+++ /tmp/tmpru_dgqu2.java\t2022-07-12 16:53:39.611046351 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; keys) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private Object readResolve = this.keys; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:42.367033061 +0200\n+++ /tmp/tmpmsj_qyew.java\t2022-07-12 16:53:42.367033061 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.keys; {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private Object readResolve = this.readOnly;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:45.163019576 +0200\n+++ /tmp/tmpnjsthrb1.java\t2022-07-12 16:53:45.163019576 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.readOnly;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private Object readResolve = this.input;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:47.755007070 +0200\n+++ /tmp/tmp7v2rvpao.java\t2022-07-12 16:53:47.755007070 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.input;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private Object readResolve; 8) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:50.426994178 +0200\n+++ /tmp/tmptrqo3o5x.java\t2022-07-12 16:53:50.426994178 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve; 8) {\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private Object readResolve = this.readResolve;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:53.106981242 +0200\n+++ /tmp/tmpbirccb2u.java\t2022-07-12 16:53:53.106981242 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve = this.readResolve;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private Object readResolve(this.keys;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Collections-26/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java\t2022-07-12 16:53:55.622969097 +0200\n+++ /tmp/tmpwz7n5q1n.java\t2022-07-12 16:53:55.622969097 +0200\n@@ -272,10 +272,10 @@\n      * Recalculate the hash code after deserialization. The hash code of some\n      * keys might have change (hash codes based on the system hash code are\n      * only stable for the same process).\n      * @return the instance with recalculated hash code\n      */\n-    private Object readResolve() {\n+private Object readResolve(this.keys;\n         calculateHashCode(keys);\n         return this;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private Object readResolve() {",
        "fixed_line": "protected Object readResolve() {"
    },
    "Closure-170": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (n.isName; n.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:53:58.462955383 +0200\n+++ /tmp/tmpxle73ov3.java\t2022-07-12 16:53:58.566954883 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName; n.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (n.isName && n == parent) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:03.742929882 +0200\n+++ /tmp/tmp2_lvjuwy.java\t2022-07-12 16:54:03.742929882 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (n.isName) && n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:07.722910651 +0200\n+++ /tmp/tmpgg27qd8s.java\t2022-07-12 16:54:07.722910651 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (n.isName) && n.getString().equals(varName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:11.266893521 +0200\n+++ /tmp/tmpva3fce6p.java\t2022-07-12 16:54:11.266893521 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (n.isName && n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:14.634877236 +0200\n+++ /tmp/tmpyrr5ozml.java\t2022-07-12 16:54:14.634877236 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (n.isName && n == parent.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:18.158860197 +0200\n+++ /tmp/tmppu339kud.java\t2022-07-12 16:54:18.158860197 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (n.isName) && n.getString().equals(varName) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:21.766842744 +0200\n+++ /tmp/tmpyyaq4oq9.java\t2022-07-12 16:54:21.766842744 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (n.isName; n.getString().equals(varName) == n;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:25.182826217 +0200\n+++ /tmp/tmpm02qtfov.java\t2022-07-12 16:54:25.182826217 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName; n.getString().equals(varName) == n;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (n.isName && n == parent.getString().equals(varName)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:28.642809471 +0200\n+++ /tmp/tmpcdc8buxv.java\t2022-07-12 16:54:28.642809471 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName && n == parent.getString().equals(varName)) {\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.isName) && n.getString().equals(varName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-170/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\t2022-07-12 16:54:32.402791268 +0200\n+++ /tmp/tmp9kt521dy.java\t2022-07-12 16:54:32.406791249 +0200\n@@ -477,18 +477,11 @@\n       AbstractCfgNodeTraversalCallback gatherCb =\n           new AbstractCfgNodeTraversalCallback() {\n \n         @Override\n         public void visit(NodeTraversal t, Node n, Node parent) {\n-          if (n.isName() && n.getString().equals(varName) &&\n-            // We make a special exception when the entire cfgNode is a chain\n-            // of assignments, since in that case the assignment statements\n-            // will happen after the inlining of the right hand side.\n-            // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact\n-            //   and remove this special case.\n-              !(parent.isAssign() &&\n-               (parent.getFirstChild() == n))) {\n+if (n.isName) && n.getString().equals(varName;\n               // Don't count lhs of top-level assignment chain\n               numUsesWithinCfgNode++;\n           }\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (n.isName() && n.getString().equals(varName) && // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. !(parent.isAssign() && (parent.getFirstChild() == n))) {",
        "fixed_line": "if (n.isName() && n.getString().equals(varName)) { // We make a special exception when the entire cfgNode is a chain // of assignments, since in that case the assignment statements // will happen after the inlining of the right hand side. // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact // and remove this special case. if (parent.isAssign() && (parent.getFirstChild() == n) && isAssignChain(parent, cfgNode)) { // Don't count lhs of top-level assignment chain return; } else { numUsesWithinCfgNode++; } } } private boolean isAssignChain(Node child, Node ancestor) { for (Node n = child; n != ancestor; n = n.getParent()) { if (!n.isAssign()) { return false; } } return true; }"
    },
    "Time-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "} else if (nextAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:54:36.086773429 +0200\n+++ /tmp/tmpyyp3daqh.java\t2022-07-12 16:54:36.146773138 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "} else if (nextAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:54:38.530761592 +0200\n+++ /tmp/tmp1r0uk0ae.java\t2022-07-12 16:54:38.530761592 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (fLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:54:40.306752988 +0200\n+++ /tmp/tmp1hghqvun.java\t2022-07-12 16:54:40.310752969 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (fLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (offsetLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:54:42.134744132 +0200\n+++ /tmp/tmpqiz5s643.java\t2022-07-12 16:54:42.134744132 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (prevAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:54:57.866667872 +0200\n+++ /tmp/tmpwcv2bsd9.java\t2022-07-12 16:54:57.870667852 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (prevAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "} else if (nextLocal!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:55:00.698654126 +0200\n+++ /tmp/tmpmbs8yhl0.java\t2022-07-12 16:55:00.698654126 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextLocal!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "} else if (iAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:55:03.342641291 +0200\n+++ /tmp/tmpxtowyh6q.java\t2022-07-12 16:55:03.342641291 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (iAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (prevAdjusted > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:55:05.614630270 +0200\n+++ /tmp/tmpzhbtu_bp.java\t2022-07-12 16:55:05.650630096 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (prevAdjusted > 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (nextAdjusted!= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:55:08.358616943 +0200\n+++ /tmp/tmpgk10idcp.java\t2022-07-12 16:55:08.358616943 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (nextAdjusted!= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "} else if (iAdjusted == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-19/src/main/java/org/joda/time/DateTimeZone.java\t2022-07-12 16:55:11.418602089 +0200\n+++ /tmp/tmpndc5aod7.java\t2022-07-12 16:55:11.490601739 +0200\n@@ -895,11 +895,11 @@\n                 long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                 if (nextLocal != nextAdjusted) {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (iAdjusted == 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);\n                 int diff = offsetPrev - offsetLocal;\n                 if (instantAdjusted - prev <= diff) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "} else if (offsetLocal > 0) {",
        "fixed_line": "} else if (offsetLocal >= 0) {"
    },
    "Closure-159": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (node.getType() == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:14.118588983 +0200\n+++ /tmp/tmprbgegojp.java\t2022-07-12 16:55:14.270588245 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (node.getType() == Token.CALL) { Node child = Node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:20.882556126 +0200\n+++ /tmp/tmp5f3rqcyt.java\t2022-07-12 16:55:20.886556107 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = Node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:24.290539563 +0200\n+++ /tmp/tmpzwj9nulz.java\t2022-07-12 16:55:24.290539563 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.getType() == Token.CALL) { Node child = c.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:27.834522349 +0200\n+++ /tmp/tmpj063wc_8.java\t2022-07-12 16:55:27.834522349 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = c.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (node.getType() == Token.CALL) { Node child = child.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:31.006506931 +0200\n+++ /tmp/tmpg5npioxn.java\t2022-07-12 16:55:31.006506931 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType() == Token.CALL) { Node child = child.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (node.getType == Token.CALL) { Node child = Node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:34.414490360 +0200\n+++ /tmp/tmpeyo956wv.java\t2022-07-12 16:55:34.414490360 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { Node child = Node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (node.getType == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:37.734474215 +0200\n+++ /tmp/tmpgzqxz2rx.java\t2022-07-12 16:55:37.754474118 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (node.getType == Token.CALL) { Node child = node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:41.162457528 +0200\n+++ /tmp/tmpwh866ncn.java\t2022-07-12 16:55:41.166457509 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (node.getType == Token.CALL) { Node child = node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == Token.CALL) { Node child = node.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:44.566440977 +0200\n+++ /tmp/tmp9tz85ap_.java\t2022-07-12 16:55:44.566440977 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (type == Token.CALL) { Node child = node.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == Token.CALL) { NodeUtil.getFirstChild();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-159/src/com/google/javascript/jscomp/InlineFunctions.java\t2022-07-12 16:55:47.694425756 +0200\n+++ /tmp/tmpqw8fjqcj.java\t2022-07-12 16:55:47.714425659 +0200\n@@ -772,14 +772,11 @@\n    */\n   private void findCalledFunctions(\n       Node node, Set<String> changed) {\n     Preconditions.checkArgument(changed != null);\n     // For each referenced function, add a new reference\n-    if (node.getType() == Token.CALL) {\n-      Node child = node.getFirstChild();\n-      if (child.getType() == Token.NAME) {\n-        changed.add(child.getString());\n+if (type == Token.CALL) { NodeUtil.getFirstChild();\n       }\n     }\n \n     for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n       findCalledFunctions(c, changed);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString());",
        "fixed_line": "if (node.getType() == Token.NAME) { if (isCandidateUsage(node)) { changed.add(node.getString());"
    },
    "JacksonCore-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0, len = _inputEnd; _inputPtr = start;",
                "patch_diff": "for (int i = 0, len = _inputEnd; _inputPtr = start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0, len = _inputBuffer.length; _inputPtr = start;",
                "patch_diff": "for (int i = 0, len = _inputBuffer.length; _inputPtr = start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0, len = _inputBuffer.length; i < len; ++i) {",
                "patch_diff": "for (int i = 0, len = _inputBuffer.length; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0, len = _inputEnd; _inputPtr = start; i++) {",
                "patch_diff": "for (int i = 0, len = _inputEnd; _inputPtr = start; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0, len = _inputEnd; _inputPtr = end;",
                "patch_diff": "for (int i = 0, len = _inputEnd; _inputPtr = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (; _symbols = start; _inputPtr = start;",
                "patch_diff": "for (; _symbols = start; _inputPtr = start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0, len = _inputBuffer.length; _inputPtr = 0; i < len; ++i) {",
                "patch_diff": "for (int i = 0, len = _inputBuffer.length; _inputPtr = 0; i < len; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (c == INT_QUOTE) { _inputPtr = 0; _inputEnd = end; _inputPtr = 0;",
                "patch_diff": "} else if (c == INT_QUOTE) { _inputPtr = 0; _inputEnd = end; _inputPtr = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (c == INT_QUOTE) { _inputPtr = 0; _inputEnd = end; _inputPtr = 0; }",
                "patch_diff": "} else if (c == INT_QUOTE) { _inputPtr = 0; _inputEnd = end; _inputPtr = 0; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0, len = _inputBuffer.length; _inputPtr = start; i++) {",
                "patch_diff": "for (int i = 0, len = _inputBuffer.length; _inputPtr = start; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currInputRowStart = start; // If we have offset, need to omit that from byte offset, so: _currInputProcessed = -start;"
    },
    "Jsoup-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:55:55.302388717 +0200\n+++ /tmp/tmps4wu2615.java\t2022-07-12 16:55:55.690386831 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:55:59.862366513 +0200\n+++ /tmp/tmp7pmhd4t7.java\t2022-07-12 16:55:59.862366513 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, ownerDocument().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:02.278354745 +0200\n+++ /tmp/tmp5k96ddv8.java\t2022-07-12 16:56:02.278354745 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:04.774342588 +0200\n+++ /tmp/tmp1i5uleh9.java\t2022-07-12 16:56:04.774342588 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum, binarySearch().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:07.346330053 +0200\n+++ /tmp/tmpemtgm9gt.java\t2022-07-12 16:56:07.346330053 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new NodeTraversor(accum,Insert().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:09.982317203 +0200\n+++ /tmp/tmpo1ik3og6.java\t2022-07-12 16:56:10.002317106 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum,Insert().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:12.914302915 +0200\n+++ /tmp/tmpqiqzc7_b.java\t2022-07-12 16:56:13.706299043 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, ownerDocument().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new NodeTraversor(accum,Insert().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:17.414280979 +0200\n+++ /tmp/tmphqf1jreu.java\t2022-07-12 16:56:18.242276937 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversor(accum,Insert().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:20.882264067 +0200\n+++ /tmp/tmpkug9tr0i.java\t2022-07-12 16:56:21.766259754 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum;\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-8/src/main/java/org/jsoup/nodes/Node.java\t2022-07-12 16:56:25.062243680 +0200\n+++ /tmp/tmp58erza__.java\t2022-07-12 16:56:25.154243229 +0200\n@@ -358,11 +358,11 @@\n         outerHtml(accum);\n         return accum.toString();\n     }\n \n     protected void outerHtml(StringBuilder accum) {\n-        new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);\n+new NodeTraversorVisitor(accum, binarySearch().outputSettings())).traverse( accum);\n     }\n \n     // if this node has no document (or parent), retrieve the default output settings\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new NodeTraversor(new OuterHtmlVisitor(accum, ownerDocument().outputSettings())).traverse(this);",
        "fixed_line": "new NodeTraversor(new OuterHtmlVisitor(accum, getOutputSettings())).traverse(this); } // if this node has no document (or parent), retrieve the default output settings private Document.OutputSettings getOutputSettings() { return ownerDocument() != null ? ownerDocument().outputSettings() : (new Document(\"\")).outputSettings(); }"
    },
    "Math-73": {
        "fixes": [
            {
                "k": 1,
                "patch": "return solve(f, initial, max, yMin, yMax, maximalIterationCount);",
                "patch_diff": "return solve(f, initial, max, yMin, yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return solve(f, max, yMin, yMax, maximalIterationCount);",
                "patch_diff": "return solve(f, max, yMin, yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return solve(f, initial, max, yMin, yMax, yInitial);",
                "patch_diff": "return solve(f, initial, max, yMin, yMax, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return solve(min, max, yMin, yMax, max, yMin, yMax, maximalIterationCount);",
                "patch_diff": "return solve(min, max, yMin, yMax, max, yMin, yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return solve(f, max, yMin, yMax, maximalIterationCount, yMin, yMax, maximalIterationCount);",
                "patch_diff": "return solve(f, max, yMin, yMax, maximalIterationCount, yMin, yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return solve(f, min, max, yMin, yMax, maximalIterationCount);",
                "patch_diff": "return solve(f, min, max, yMin, yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return solve(min, max, yMin, yMax, max, yMin, yMax, yInitial);",
                "patch_diff": "return solve(min, max, yMin, yMax, max, yMin, yMax, yInitial);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return solve(f, initial, max, yMin, yMax, maximalIterationCount;",
                "patch_diff": "return solve(f, initial, max, yMin, yMax, maximalIterationCount;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return solve(f, initial, max, yMin, yMax, maximalIterationCount); }",
                "patch_diff": "return solve(f, initial, max, yMin, yMax, maximalIterationCount); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return solve(min, max, yMin, yMax, max, yMin, y yMax, maximalIterationCount);",
                "patch_diff": "return solve(min, max, yMin, yMax, max, yMin, y yMax, maximalIterationCount);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (yMin * yMax > 0) { throw MathRuntimeException.createIllegalArgumentException( NON_BRACKETING_MESSAGE, min, max, yMin, yMax); }"
    },
    "Lang-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (expPos < 2) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:56:29.514221960 +0200\n+++ /tmp/tmpvi3v7_ji.java\t2022-07-12 16:56:29.818220469 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 2) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (expPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:56:45.730142800 +0200\n+++ /tmp/tmpuvk0mh54.java\t2022-07-12 16:56:46.566138717 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (expPos < 5) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:56:57.990082902 +0200\n+++ /tmp/tmpdwcwqxz3.java\t2022-07-12 16:56:57.990082902 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 5) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (expPos < expPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:08.826029928 +0200\n+++ /tmp/tmp70g3jrhb.java\t2022-07-12 16:57:08.846029831 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < expPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (expPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:21.337968720 +0200\n+++ /tmp/tmpbpjnpars.java\t2022-07-12 16:57:21.337968720 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (expPos < minPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:33.001911627 +0200\n+++ /tmp/tmpttjog0ex.java\t2022-07-12 16:57:33.001911627 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < minPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (decPos < decPos) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:35.625898779 +0200\n+++ /tmp/tmpk6obe778.java\t2022-07-12 16:57:35.809897878 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (expPos < -1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:47.109842525 +0200\n+++ /tmp/tmp_3noo9zn.java\t2022-07-12 16:57:47.109842525 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < -1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (expPos < 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:57:56.541796298 +0200\n+++ /tmp/tmpeq2t5r80.java\t2022-07-12 16:57:56.545796278 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (expPos < 0) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (decPos < decPos + 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-27/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 16:58:05.953750147 +0200\n+++ /tmp/tmp0wauxl6v.java\t2022-07-12 16:58:05.957750128 +0200\n@@ -474,11 +474,11 @@\n         int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n \n         if (decPos > -1) {\n \n             if (expPos > -1) {\n-                if (expPos < decPos) {\n+if (decPos < decPos + 1) {\n                     throw new NumberFormatException(str + \" is not a valid number.\");\n                 }\n                 dec = str.substring(decPos + 1, expPos);\n             } else {\n                 dec = str.substring(decPos + 1);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (expPos < decPos) {",
        "fixed_line": "if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); }"
    },
    "Math-57": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 1; // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 16:58:15.441703603 +0200\n+++ /tmp/tmpk25y6u0i.java\t2022-07-12 16:58:15.473703446 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it.\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 1; // we didn't really modify it was last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 16:58:59.685486290 +0200\n+++ /tmp/tmp8vrsuhot.java\t2022-07-12 16:58:59.685486290 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was last\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 1; // we didn't really modify it was copied",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 16:59:41.821278943 +0200\n+++ /tmp/tmpoxju7kjv.java\t2022-07-12 16:59:41.821278943 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was copied\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 1; // we didn't really modify it's parent",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:00:23.885071602 +0200\n+++ /tmp/tmpw2pse62v.java\t2022-07-12 17:00:23.885071602 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it's parent\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 1; // we didn't really modify it was x",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:01:05.832864511 +0200\n+++ /tmp/tmphj08iod6.java\t2022-07-12 17:01:05.836864492 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was x\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:01:48.028655902 +0200\n+++ /tmp/tmpd3v25opc.java\t2022-07-12 17:01:48.028655902 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 1; // we didn't really gets this.x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:02:30.900443671 +0200\n+++ /tmp/tmpbkb6twnh.java\t2022-07-12 17:02:30.900443671 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really gets this.x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 1; // we didn't really modify it",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:03:13.064234692 +0200\n+++ /tmp/tmpb51iqza8.java\t2022-07-12 17:03:13.064234692 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:03:55.300025125 +0200\n+++ /tmp/tmp7ye6numb.java\t2022-07-12 17:03:55.300025125 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that were // we didn't really modify it.\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 1; // we didn't really modify it was non-literal characters that might be valid (x0",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-57/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\t2022-07-12 17:04:37.423815898 +0200\n+++ /tmp/tmprfd5q4di.java\t2022-07-12 17:04:37.423815898 +0200\n@@ -170,11 +170,11 @@\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+int sum = 1; // we didn't really modify it was non-literal characters that might be valid (x0\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                 final double d = p.distanceFrom(nearest.getCenter());\n                 sum += d * d;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0;",
        "fixed_line": "double sum = 0;"
    },
    "Lang-31": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (searchLength == 0) {",
                "patch_diff": "if (searchLength == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (searchChars[j] == ch) {",
                "patch_diff": "if (searchChars[j] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; i < searchLength; i++) {",
                "patch_diff": "for (int i = 0; i < searchLength; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int j = searchChars.length; i < searchLength; i++) {",
                "patch_diff": "for (int j = searchChars.length; i < searchLength; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int i = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int j = searchChars.length; i < searchChars.length; i++) {",
                "patch_diff": "for (int j = searchChars.length; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int j = 0; i < searchChars.length; i++) {",
                "patch_diff": "for (int j = 0; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (searchLength > 0) {",
                "patch_diff": "if (searchLength > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int j = searchChars[j] == ch; i < searchChars.length; i++) {",
                "patch_diff": "for (int j = searchChars[j] == ch; i < searchChars.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (searchChars[i] == ch) {",
                "patch_diff": "if (searchChars[i] == ch) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "int csLastIndex = csLength - 1; int searchLastIndex = searchLength - 1; for (int i = 0; i < csLength; i++) { char ch = cs.charAt(i); for (int j = 0; j < searchLength; j++) { if (searchChars[j] == ch) { if (i < csLastIndex && j < searchLastIndex && ch >= Character.MIN_HIGH_SURROGATE && ch <= Character.MAX_HIGH_SURROGATE) { // ch is a supplementary character if (searchChars[j + 1] == cs.charAt(i + 1)) { return true; } } else { // ch is in the Basic Multilingual Plane return true; }"
    },
    "JacksonDatabind-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(type, _property);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(type, _property);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser = ctxt.findContextualValueDeserializer(type, _property);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser = ctxt.findContextualValueDeserializer(type, _property);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw ctxt.findContextualValueDeserializer(type, deser = _typeExceptionType.findContextualValueDeserializer(type, _property);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, deser = _typeExceptionType.findContextualValueDeserializer(type, _property);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, _property);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, _property);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(type, _valueType);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(type, _valueType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _property);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _property);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _valueType, deser);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _valueType, deser);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser = ctxt.findContextualValueDeserializer(type, _valueType);",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, _defaultContextualValueDeserializer(type, deser = ctxt.findContextualValueDeserializer(type, _valueType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(tatu: As.",
                "patch_diff": "throw ctxt.findContextualValueDeserializer(type, deser = _typeParameters.findContextualValueDeserializer(tatu: As.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); }"
    },
    "JacksonXml-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:05:23.459587019 +0200\n+++ /tmp/tmpafdkcx9g.java\t2022-07-12 17:05:23.475586939 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-is",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:05:34.787530668 +0200\n+++ /tmp/tmphmea4xgv.java\t2022-07-12 17:05:34.787530668 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-is\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:05:44.927480212 +0200\n+++ /tmp/tmpnhqy2oil.java\t2022-07-12 17:05:44.931480193 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:05:54.963430268 +0200\n+++ /tmp/tmpq_xqzfbb.java\t2022-07-12 17:05:54.963430268 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_nextAfterNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:05:56.583422203 +0200\n+++ /tmp/tmpo3up5n_i.java\t2022-07-12 17:05:56.611422064 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-empty to do a nameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:06:06.819371249 +0200\n+++ /tmp/tmp_47zcqfj.java\t2022-07-12 17:06:06.819371249 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_nextAfterNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:06:17.059320269 +0200\n+++ /tmp/tmpruk9zgs7.java\t2022-07-12 17:06:17.059320269 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:06:18.755311821 +0200\n+++ /tmp/tmp126qm9iz.java\t2022-07-12 17:06:18.755311821 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-is",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:06:28.743262085 +0200\n+++ /tmp/tmpijgiqdjj.java\t2022-07-12 17:06:28.747262063 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup._rootNameLookup; // copy from '_next-is\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonXml-5/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java\t2022-07-12 17:06:30.439253638 +0200\n+++ /tmp/tmpc781ta3q.java\t2022-07-12 17:06:30.439253638 +0200\n@@ -54,11 +54,11 @@\n      */\n     protected XmlSerializerProvider(XmlSerializerProvider src) {\n         super(src);\n         // 21-May-2018, tatu: As per [dataformat-xml#282], should NOT really copy\n         //    root name lookup as that may link back to diff version, configuration\n-        _rootNameLookup = src._rootNameLookup;\n+_rootNameLookup = src._rootNameLookup; // copy from '_next-rootNameLookup = src._rootNameLookup;\n     }\n \n     /*\n     /**********************************************************************\n     /* Overridden methods\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "_rootNameLookup = src._rootNameLookup;",
        "fixed_line": "_rootNameLookup = new XmlRootNameLookup();"
    },
    "Lang-51": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ch == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (ch == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ch == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (ch == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.charAt(3) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(3) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.charAt(3) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(3) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.charAt(2) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str.charAt(2) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.charAt(2) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "patch_diff": "if (str.charAt(2) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s')) {",
                "patch_diff": "if (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s')) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "patch_diff": "if (str == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s');",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "return false;"
    },
    "JacksonDatabind-76": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ctxt.assignParameter(creatorProp, bean)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:42.699192571 +0200\n+++ /tmp/tmp1q4kmd4h.java\t2022-07-12 17:06:42.771192207 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean)) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:44.587183164 +0200\n+++ /tmp/tmpz7lzm2ko.java\t2022-07-12 17:06:44.591183146 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (type == TYPE_ARRAY) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ctxt.assignParameter(creatorProp, _beanType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:46.171175273 +0200\n+++ /tmp/tmp7csjhz7k.java\t2022-07-12 17:06:46.171175273 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, _beanType;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (ctxt.assignParameter(creatorProp, bean) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:47.927166525 +0200\n+++ /tmp/tmp5zb4d4ki.java\t2022-07-12 17:06:47.931166507 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (t == JsonToken.FIELD_NAME) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:49.459158894 +0200\n+++ /tmp/tmploo8124n.java\t2022-07-12 17:06:49.459158894 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (t == JsonToken.FIELD_NAME) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (ctxt.assignParameter(creatorProp, bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:51.111150664 +0200\n+++ /tmp/tmphw4mdq3u.java\t2022-07-12 17:06:51.111150664 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ctxt.assignParameter(creatorProp, bean bean;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:52.647143011 +0200\n+++ /tmp/tmpmurq_xa6.java\t2022-07-12 17:06:52.647143011 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean bean;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (type.assignParameter) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:54.251135019 +0200\n+++ /tmp/tmpc84qpqm9.java\t2022-07-12 17:06:54.251135019 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (type.assignParameter) {\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (ctxt.assignParameter(creatorProp, bean, propName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:55.847127065 +0200\n+++ /tmp/tmps99xr_pr.java\t2022-07-12 17:06:55.847127065 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean, propName);\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (ctxt.assignParameter(creatorProp, bean = _beanType;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-76/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\t2022-07-12 17:06:57.439119135 +0200\n+++ /tmp/tmp1fy3ylq5.java\t2022-07-12 17:06:57.439119135 +0200\n@@ -578,31 +578,11 @@\n             String propName = p.getCurrentName();\n             p.nextToken(); // to point to value\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n-                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n-                }\n+if (ctxt.assignParameter(creatorProp, bean = _beanType;\n                 continue;\n             }\n             // Object Id property?\n             if (buffer.readIdProperty(propName)) {\n                 continue;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); }",
        "fixed_line": "buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt));"
    },
    "Csv-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:06:59.239110166 +0200\n+++ /tmp/tmp8s71hz3o.java\t2022-07-12 17:06:59.263110043 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:01.231100237 +0200\n+++ /tmp/tmpid08kuto.java\t2022-07-12 17:07:01.231100237 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(valueType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:02.799092423 +0200\n+++ /tmp/tmpxeex8z73.java\t2022-07-12 17:07:02.799092423 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLines(valueType);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:04.475084072 +0200\n+++ /tmp/tmpo2_i71df.java\t2022-07-12 17:07:04.475084072 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_semEmptyEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:06.087076041 +0200\n+++ /tmp/tmp23bid8ye.java\t2022-07-12 17:07:06.091076018 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_semEmptyEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_ONEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:07.859067210 +0200\n+++ /tmp/tmpwhi556l1.java\t2022-07-12 17:07:07.863067187 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_ONEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(valueType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:09.551058776 +0200\n+++ /tmp/tmpb0bw4f9c.java\t2022-07-12 17:07:09.551058776 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(valueType);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_NAMEIgnoreEmptyLines.withIgnoreEmptyLines(false);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:11.195050584 +0200\n+++ /tmp/tmpmtls2dh_.java\t2022-07-12 17:07:11.195050584 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_NAMEIgnoreEmptyLines.withIgnoreEmptyLines(false);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLinesIgnored;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:12.827042448 +0200\n+++ /tmp/tmptk18ayyv.java\t2022-07-12 17:07:12.827042448 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_anyIgnoreEmptyLines.withIgnoreEmptyLinesIgnored;\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-12/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:14.579033716 +0200\n+++ /tmp/tmpts987xwe.java\t2022-07-12 17:07:14.579033716 +0200\n@@ -214,11 +214,11 @@\n      * </ul>\n      * <p>\n      * Note: this is currently like {@link #RFC4180} plus {@link #withAllowMissingColumnNames(boolean) withAllowMissingColumnNames(true)}.\n      * </p>\n      */\n-    public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);\n+public static final CSVFormat EXCEL = DEFAULT_IgnoreEmptyLines.withIgnoreEmptyLines(true);\n \n     /**\n      * Tab-delimited format.\n      *\n      * <p>\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false);",
        "fixed_line": "public static final CSVFormat EXCEL = DEFAULT.withIgnoreEmptyLines(false).withAllowMissingColumnNames(true);"
    },
    "JacksonDatabind-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (oldOne.getClass() == newOne; // to use it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:16.547023907 +0200\n+++ /tmp/tmpoke7xnaa.java\t2022-07-12 17:07:16.595023669 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to use it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (oldOne == newOne.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:18.559013878 +0200\n+++ /tmp/tmpwm23bg6t.java\t2022-07-12 17:07:18.559013878 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne.class) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (oldOne.getClass() == newOne;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:20.511004148 +0200\n+++ /tmp/tmp2bcx25hv.java\t2022-07-12 17:07:20.511004148 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne;\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (oldOne.getClass() == newOne; // to use a marker to indicate explicit disabling of",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:22.158995935 +0200\n+++ /tmp/tmpsr9vprvr.java\t2022-07-12 17:07:22.162995913 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to use a marker to indicate explicit disabling of\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (oldOne == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:23.658988455 +0200\n+++ /tmp/tmpgtu8o9dt.java\t2022-07-12 17:07:23.658988455 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne.class) { // as per [JACKSON-407] -- allow disabling wrapping for\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (oldOne.getClass() == newOne.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:25.422979662 +0200\n+++ /tmp/tmp6nkfx8sz.java\t2022-07-12 17:07:25.422979662 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.class) {\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (oldOne.getClass() == newOne.class;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:27.102971288 +0200\n+++ /tmp/tmp02nmvg3r.java\t2022-07-12 17:07:27.102971288 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne.class;\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (oldOne == newOne; // to use it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:28.762963012 +0200\n+++ /tmp/tmpttm49scd.java\t2022-07-12 17:07:28.766962994 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne == newOne; // to use it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (oldOne.getClass() == newOne; // to normalize it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:30.350955095 +0200\n+++ /tmp/tmpms7cbbxq.java\t2022-07-12 17:07:30.350955095 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to normalize it's do implicit re-parse\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (oldOne.getClass() == newOne; // to add",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-8/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\t2022-07-12 17:07:31.946947138 +0200\n+++ /tmp/tmpyd_p0kqa.java\t2022-07-12 17:07:31.946947138 +0200\n@@ -289,11 +289,11 @@\n                 // both explicit: verify\n                 // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n-            if (oldOne.getClass() == newOne.getClass()) {\n+if (oldOne.getClass() == newOne; // to add\n                 // [databind#667]: avoid one particular class of bogus problems\n \n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                 // otherwise, which one to choose?\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (oldOne.getClass() == newOne.getClass()) {",
        "fixed_line": "boolean verify; if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is // but skip, if new one not annotated if (!explicit) { return; } // both explicit: verify verify = true; } else { // otherwise only verify if neither explicitly annotated. verify = !explicit; } // one more thing: ok to override in sub-class if (verify && (oldOne.getClass() == newOne.getClass())) { // [databind#667]: avoid one particular class of bogus problems Class<?> oldType = oldOne.getRawParameterType(0); Class<?> newType = newOne.getRawParameterType(0); if (oldType == newType) { throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex] +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne); } // otherwise, which one to choose? if (newType.isAssignableFrom(oldType)) { // new type more generic, use old return; }"
    },
    "Csv-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x3D || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:33.758938104 +0200\n+++ /tmp/tmp9humlvgn.java\t2022-07-12 17:07:33.830937745 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x3D || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x2B || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:35.594928950 +0200\n+++ /tmp/tmpvllgryea.java\t2022-07-12 17:07:35.594928950 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x2B || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x07 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:37.126921311 +0200\n+++ /tmp/tmpvnqj9pxs.java\t2022-07-12 17:07:37.130921292 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x07 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x2B || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:38.594913995 +0200\n+++ /tmp/tmp9npi1rix.java\t2022-07-12 17:07:38.598913972 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x2B || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x2B && c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:40.170906134 +0200\n+++ /tmp/tmponk78ou5.java\t2022-07-12 17:07:40.170906134 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x2B && c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x23 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:41.718898416 +0200\n+++ /tmp/tmpixo7w3p9.java\t2022-07-12 17:07:41.718898416 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x23 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (c < 0x20 || c > 0x2 || c < 0x23 || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:43.294890557 +0200\n+++ /tmp/tmpf65h8cwn.java\t2022-07-12 17:07:43.294890557 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x2 || c < 0x23 || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (c < 0x20 || c > 0x1 && c < 0x2B || c > 0x2D || c < 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:44.874882678 +0200\n+++ /tmp/tmpsai0idra.java\t2022-07-12 17:07:44.874882678 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x1 && c < 0x2B || c > 0x2D || c < 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (c < 0x20 || c > 0x07 || c < 0x3D || c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:46.486874640 +0200\n+++ /tmp/tmp2phth2lz.java\t2022-07-12 17:07:46.490874622 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x07 || c < 0x3D || c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c < 0x20 || c > 0x23 || c < 0x2B && c > 0x7E)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-15/src/main/java/org/apache/commons/csv/CSVFormat.java\t2022-07-12 17:07:48.086866661 +0200\n+++ /tmp/tmprxs3n8i5.java\t2022-07-12 17:07:48.086866661 +0200\n@@ -1184,13 +1184,11 @@\n                     quote = true;\n                 }\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+if (c < 0x20 || c > 0x23 || c < 0x2B && c > 0x7E)) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too.\n                     quote = true;\n                 } else {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) {",
        "fixed_line": "if (c <= COMMENT) {"
    },
    "Closure-130": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:07:49.954857344 +0200\n+++ /tmp/tmpi3g5w23s.java\t2022-07-12 17:07:50.030856966 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-name.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:08:37.586619723 +0200\n+++ /tmp/tmpmhc1076i.java\t2022-07-12 17:08:37.590619704 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-name.\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:09:21.754399242 +0200\n+++ /tmp/tmpv2r3k2tg.java\t2022-07-12 17:09:21.754399242 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:10:06.346176522 +0200\n+++ /tmp/tmpxncsn9vt.java\t2022-07-12 17:10:06.346176522 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property name.aliasingGets > 0)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:10:50.993953403 +0200\n+++ /tmp/tmpysuthgeo.java\t2022-07-12 17:10:50.993953403 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:11:34.857734100 +0200\n+++ /tmp/tmp9shl37ab.java\t2022-07-12 17:11:34.857734100 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:12:19.261512001 +0200\n+++ /tmp/tmpu21twili.java\t2022-07-12 17:12:19.261512001 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns)\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:13:04.025288013 +0200\n+++ /tmp/tmp07d661w2.java\t2022-07-12 17:13:04.025288013 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // name.aliasingGets > 0) // empty String meaning \"use default name.aliasingGets\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:13:48.425065763 +0200\n+++ /tmp/tmp341_tusv.java\t2022-07-12 17:13:48.425065763 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // no property-inExterns) // no property-inExterns\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-130/src/com/google/javascript/jscomp/CollapseProperties.java\t2022-07-12 17:14:32.884843141 +0200\n+++ /tmp/tmpmb9_29zx.java\t2022-07-12 17:14:32.884843141 +0200\n@@ -167,11 +167,11 @@\n       // Don't attempt to inline a getter or setter property as a variable.\n       if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+if (name.globalSets == 1 && name.localSets == 0 && // sign/user default name.aliasingGets > 0) {\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.\n         List<Ref> refs = Lists.newArrayList(name.getRefs());\n         for (Ref ref : refs) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (name.globalSets == 1 && name.localSets == 0 &&",
        "fixed_line": "if (!name.inExterns && name.globalSets == 1 && name.localSets == 0 &&"
    },
    "JxPath-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:17.604619147 +0200\n+++ /tmp/tmp4pka0tmm.java\t2022-07-12 17:15:17.648618927 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' {\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:19.980607245 +0200\n+++ /tmp/tmpv9aze0ro.java\t2022-07-12 17:15:19.980607245 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:21.616599049 +0200\n+++ /tmp/tmpkn4_hb2o.java\t2022-07-12 17:15:21.616599049 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:26.372575223 +0200\n+++ /tmp/tmp2z_o81if.java\t2022-07-12 17:15:26.372575223 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'Vars '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:30.760553242 +0200\n+++ /tmp/tmpp45dn0qr.java\t2022-07-12 17:15:30.764553220 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:32.244545805 +0200\n+++ /tmp/tmpabfiatr5.java\t2022-07-12 17:15:32.268545685 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'\"+ and '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2.parent)\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:34.036536827 +0200\n+++ /tmp/tmp9lov5vev.java\t2022-07-12 17:15:34.036536827 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p2.parent)\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:35.668528651 +0200\n+++ /tmp/tmp3essj5wf.java\t2022-07-12 17:15:35.668528651 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"'base '\" + p2 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 - \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:40.500504441 +0200\n+++ /tmp/tmpu6apggnq.java\t2022-07-12 17:15:40.500504441 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 - \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-5/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\t2022-07-12 17:15:42.364495104 +0200\n+++ /tmp/tmpog2vwymr.java\t2022-07-12 17:15:42.364495104 +0200\n@@ -660,13 +660,11 @@\n         if (p1 != null && p1.equals(p2)) {\n             return 0;\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p2 + \"' and '\" + p1 + \"'\");\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n             return r;\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\");",
        "fixed_line": "return 0;"
    },
    "JacksonCore-7": {
        "fixes": [
            {
                "k": 1,
                "patch": "return STATUS_OK_AFTER_COLON;",
                "patch_diff": "return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON;",
                "patch_diff": "return STATUS_OK_AFTER_COLON; return STATUS_OK_AFTER_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return STATUS_OK_AFTER_COLON; ++_index) {",
                "patch_diff": "return STATUS_OK_AFTER_COLON; ++_index) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return STATUS_OK_AS_IS; ++_index) {",
                "patch_diff": "return STATUS_OK_AS_IS; ++_index) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return STATUS_OK_AS_IS;",
                "patch_diff": "return STATUS_OK_AS_IS;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_type == TYPE_OBJECT) {",
                "patch_diff": "if (_type == TYPE_OBJECT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return STATUS_OK_AS_IS; ++_index;",
                "patch_diff": "return STATUS_OK_AS_IS; ++_index;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return STATUS_OK_AFTER_COLON; ++_index;",
                "patch_diff": "return STATUS_OK_AFTER_COLON; ++_index;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return STATUS_OK_AFTER_COLON; ++_FOR_COLON;",
                "patch_diff": "return STATUS_OK_AFTER_COLON; ++_FOR_COLON;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return STATUS_OK_AS_COLON; ++_index) {",
                "patch_diff": "return STATUS_OK_AS_COLON; ++_index) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (!_gotName) { return STATUS_EXPECT_NAME; }"
    },
    "JxPath-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:15:48.948462116 +0200\n+++ /tmp/tmpzcgkrh4d.java\t2022-07-12 17:15:48.992461894 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:15:51.156451051 +0200\n+++ /tmp/tmp45j0t_6o.java\t2022-07-12 17:15:51.156451051 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:15:52.960442014 +0200\n+++ /tmp/tmp3gszacja.java\t2022-07-12 17:15:52.964441992 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (l instanceof InitialContext || r instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:15:58.300415255 +0200\n+++ /tmp/tmp_00g0fon.java\t2022-07-12 17:15:58.300415255 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || r instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:15:59.912407179 +0200\n+++ /tmp/tmp5awxewg6.java\t2022-07-12 17:15:59.912407179 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l : r instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:16:01.708398179 +0200\n+++ /tmp/tmp1kgxq_z9.java\t2022-07-12 17:16:01.708398179 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:16:05.840377475 +0200\n+++ /tmp/tmp80p7edib.java\t2022-07-12 17:16:05.840377475 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext || l).getSingleNodePointer) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:16:07.388369718 +0200\n+++ /tmp/tmpp7_tt7xv.java\t2022-07-12 17:16:07.392369696 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext || l).getSingleNodePointer) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r.getSingleNodePointer;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:16:08.876362262 +0200\n+++ /tmp/tmp923g9dq0.java\t2022-07-12 17:16:08.876362262 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r.getSingleNodePointer;\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JxPath-6/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationCompare.java\t2022-07-12 17:16:10.692353162 +0200\n+++ /tmp/tmp7avgdjgh.java\t2022-07-12 17:16:10.692353162 +0200\n@@ -52,15 +52,11 @@\n \n //        System.err.println(\"COMPARING: \" +\n //            (l == null ? \"null\" : l.getClass().getName()) + \" \" +\n //            (r == null ? \"null\" : r.getClass().getName()));\n \n-        if (l instanceof InitialContext || l instanceof SelfContext) {\n-            l = ((EvalContext) l).getSingleNodePointer();\n-        }\n-\n-        if (r instanceof InitialContext || r instanceof SelfContext) {\n+if (l instanceof InitialContext || l instanceof SelfContext? l : r instanceof SelfContext? l = ((EvalContext) {\n             r = ((EvalContext) r).getSingleNodePointer();\n         }\n \n         if (l instanceof Collection) {\n             l = ((Collection) l).iterator();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (l instanceof InitialContext || l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext || r instanceof SelfContext) {",
        "fixed_line": "if (l instanceof InitialContext) { ((EvalContext) l).reset(); } if (l instanceof SelfContext) { l = ((EvalContext) l).getSingleNodePointer(); } if (r instanceof InitialContext) { ((EvalContext) r).reset(); } if (r instanceof SelfContext) {"
    },
    "JacksonCore-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "_currInputRowStart = start - _inputPtr; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = start - _inputPtr; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_currInputRowStart = start; _inputPtr = end - start;",
                "patch_diff": "_currInputRowStart = start; _inputPtr = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_currInputRowStart = start - _inputEnd; _inputPtr = end - start;",
                "patch_diff": "_currInputRowStart = start - _inputEnd; _inputPtr = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end - start;",
                "patch_diff": "_currInputRowStart = _inputEnd - _inputPtr; _inputEnd = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_currInputRowStart = start - _inputPtr; _inputEnd = end - start;",
                "patch_diff": "_currInputRowStart = start - _inputPtr; _inputEnd = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_currInputRowStart = start; _inputEnd = end;",
                "patch_diff": "_currInputRowStart = start; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_currInputRowStart = start - _inputEnd; _inputPtr = end;",
                "patch_diff": "_currInputRowStart = start - _inputEnd; _inputPtr = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int intLen = _inputEnd - _inputPtr; _inputEnd = end;",
                "patch_diff": "int intLen = _inputEnd - _inputPtr; _inputEnd = end;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_currInputRowStart = start; _inputEnd = end - start;",
                "patch_diff": "_currInputRowStart = start; _inputEnd = end - start;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_currBufferStart = start;"
    },
    "Closure-40": {
        "fixes": [
            {
                "k": 1,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:16.968321711 +0200\n+++ /tmp/tmp158gnxdw.java\t2022-07-12 17:16:17.264320226 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:23.744287753 +0200\n+++ /tmp/tmp_h7u6om6.java\t2022-07-12 17:16:23.748287734 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:29.052261152 +0200\n+++ /tmp/tmpclx3wnr5.java\t2022-07-12 17:16:29.056261133 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JsName name = getNameNameNode(ns.name, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:34.336234670 +0200\n+++ /tmp/tmpb5fdldo8.java\t2022-07-12 17:16:34.336234670 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode(ns.name, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode( name, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:39.164210473 +0200\n+++ /tmp/tmp96775_ka.java\t2022-07-12 17:16:39.164210473 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode( name, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JsName name = getNameNameNode(ns.name, false).ns.isFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:44.144185513 +0200\n+++ /tmp/tmpkty1qen2.java\t2022-07-12 17:16:44.148185494 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode(ns.name, false).ns.isFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:49.416159089 +0200\n+++ /tmp/tmpldcl0za9.java\t2022-07-12 17:16:49.416159089 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode, false).ns.new ClassDefiningFunctionNode(parent, n, parent, parent);\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:16:54.920131501 +0200\n+++ /tmp/tmpakkyik7_.java\t2022-07-12 17:16:54.924131482 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameFunctionNode, false).ns.new ClassDefiningFunctionNode(ns, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JsName name = getNameFunctionNode(ns.name, n, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:17:00.664102711 +0200\n+++ /tmp/tmpvvolq6zh.java\t2022-07-12 17:17:00.720102427 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameFunctionNode(ns.name, n, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JsName name = getNameNameNode(ns.name, false) - new ClassDefiningFunctionNode, parent, parent.getParent()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-40/src/com/google/javascript/jscomp/NameAnalyzer.java\t2022-07-12 17:17:06.028075823 +0200\n+++ /tmp/tmpoe15jg92.java\t2022-07-12 17:17:06.156075181 +0200\n@@ -630,15 +630,11 @@\n         }\n       } else if (n.isCall()) {\n         Node nameNode = n.getFirstChild();\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+JsName name = getNameNameNode(ns.name, false) - new ClassDefiningFunctionNode, parent, parent.getParent()));\n         }\n       }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "JsName name = getName(ns.name, false); if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); }",
        "fixed_line": "JsName name = getName(ns.name, true);"
    },
    "Closure-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:17:12.204044865 +0200\n+++ /tmp/tmp7qjkhgs5.java\t2022-07-12 17:17:12.532043226 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (options.checkGlobalThisLevel.isOnRoot) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:17:21.323999149 +0200\n+++ /tmp/tmpr_w70tsc.java\t2022-07-12 17:17:21.351999007 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOnRoot) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.checkGlobalThisLevel.isOn()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:17:26.635972520 +0200\n+++ /tmp/tmpo3qo7p6t.java\t2022-07-12 17:17:26.663972378 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.checkGlobalThisLevel.isOnCallLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:12.963740247 +0200\n+++ /tmp/tmp4e7qzzln.java\t2022-07-12 17:18:12.967740225 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOnCallLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options.checkGlobalThisLevel.isOn {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:16.555722234 +0200\n+++ /tmp/tmp24ih2na0.java\t2022-07-12 17:18:16.555722234 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.checkGlobalThisLevel.isOn -1 {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:20.083704545 +0200\n+++ /tmp/tmpz6eskr85.java\t2022-07-12 17:18:20.083704545 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOn -1 {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:23.631686754 +0200\n+++ /tmp/tmpd37bozql.java\t2022-07-12 17:18:23.631686754 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThis ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnRoot) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:27.395667878 +0200\n+++ /tmp/tmpwkjh_po2.java\t2022-07-12 17:18:27.395667878 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOnRoot) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOn()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:31.031649647 +0200\n+++ /tmp/tmpqxv1r3rw.java\t2022-07-12 17:18:31.031649647 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThis ||options.checkGlobalThisLevel.isOn()) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.checkGlobalThisLevel.isOnRoot ||options.checkGlobalThisLevel) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-59/src/com/google/javascript/jscomp/Compiler.java\t2022-07-12 17:18:34.735631073 +0200\n+++ /tmp/tmpnht8r0mx.java\t2022-07-12 17:18:34.735631073 +0200\n@@ -250,11 +250,11 @@\n           DiagnosticGroup.forType(\n               RhinoErrorReporter.TYPE_PARSE_ERROR),\n           CheckLevel.OFF);\n     }\n \n-    if (options.checkGlobalThisLevel.isOn()) {\n+if (options.checkGlobalThisLevel.isOnRoot ||options.checkGlobalThisLevel) {\n       options.setWarningLevel(\n           DiagnosticGroups.GLOBAL_THIS,\n           options.checkGlobalThisLevel);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.checkGlobalThisLevel.isOn()) {",
        "fixed_line": "if (options.checkGlobalThisLevel.isOn() && !options.disables(DiagnosticGroups.GLOBAL_THIS)) {"
    },
    "Time-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (year.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (instant = iJulianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond;",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (year.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "if (year.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond; instant = iJulianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond; instant = iJulianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (year < iCutoverMillis, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year < iCutoverMillis, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond; instant = iGregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond; instant = iGregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, iGregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "patch_diff": "if (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, iGregorianChronology.getDateTimeMillis (year, secondOfMinute, millisOfSecond);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, dayOfMonth, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); } catch (IllegalFieldValueException ex) { if (monthOfYear != 2 || dayOfMonth != 29) { throw ex; } instant = iGregorianChronology.getDateTimeMillis (year, monthOfYear, 28, hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond); if (instant >= iCutoverMillis) { throw ex; } }"
    },
    "Closure-61": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (type == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (type == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP && parent.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "patch_diff": "if (condEXP_METHODS.contains(nameNode.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getLastChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "patch_diff": "if (type == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&!compiler.getFirstChild().getType() == Token.REGEXP &&",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (nameNode.getFirstChild().getType() == Token.NAME) { String namespaceName = nameNode.getFirstChild().getString(); if (namespaceName.equals(\"Math\")) { return false; } }"
    },
    "Mockito-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "mockInstance = classInstantiator.instantiate; mockAccess = classInstantiator.MockAccess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:18:42.887590189 +0200\n+++ /tmp/tmp_lmtqccu.java\t2022-07-12 17:18:42.987589688 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate; mockAccess = classInstantiator.MockAccess;\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:18:54.367532652 +0200\n+++ /tmp/tmp3yctysyk.java\t2022-07-12 17:18:54.367532652 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType);\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "mockInstance = classInstantiator.instantiateiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:02.199494025 +0200\n+++ /tmp/tmprjhrqtwp.java\t2022-07-12 17:19:02.199494025 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "mockInstance = classInstantiator.instantiate(mockedProxyType).getMockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:09.915455960 +0200\n+++ /tmp/tmpj27q9jdq.java\t2022-07-12 17:19:09.915455960 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedProxyType).getMockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "mockInstance = classInstantiator.instantiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:17.651417788 +0200\n+++ /tmp/tmpcxx63zqm.java\t2022-07-12 17:19:17.651417788 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(mockedInstance : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:25.371379684 +0200\n+++ /tmp/tmpwlyrur2n.java\t2022-07-12 17:19:25.371379684 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "mockInstance = classInstantiator.instantiateiate; mockAccess = classInstantiator.MockAccess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:33.023341908 +0200\n+++ /tmp/tmp7qelg3i6.java\t2022-07-12 17:19:33.023341908 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate; mockAccess = classInstantiator.MockAccess;\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "mockInstance = classInstantiator.instantiateiate(mockedProxyType);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:40.839303313 +0200\n+++ /tmp/tmp7pf3vrv8.java\t2022-07-12 17:19:40.855303233 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(mockedProxyType);\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:48.519265379 +0200\n+++ /tmp/tmpqf1rpjf6.java\t2022-07-12 17:19:48.519265379 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiateiate(class : classInstantiator.MockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-20/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\t2022-07-12 17:19:56.323226847 +0200\n+++ /tmp/tmp5s_ooab3.java\t2022-07-12 17:19:56.323226847 +0200\n@@ -29,22 +29,11 @@\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+mockInstance = classInstantiator.instantiate(class : classInstantiator.MockAccess; mockAccess = classInstantiator.getClass().getSimpleName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n             ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "mockInstance = classInstantiator.instantiate(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + classInstantiator.getClass().getSimpleName(),",
        "fixed_line": "Instantiator instantiator = new InstantiatorProvider().getInstantiator(settings); T mockInstance = null; try { mockInstance = instantiator.newInstance(mockedProxyType); MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance; mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings)); return ensureMockIsAssignableToMockedType(settings, mockInstance); } catch (ClassCastException cce) { throw new MockitoException(join( \"ClassCastException occurred while creating the mockito mock :\", \" class to mock : \" + describeClass(mockedProxyType), \" created class : \" + describeClass(settings.getTypeToMock()), \" proxy instance class : \" + describeClass(mockInstance), \" instance creation by : \" + instantiator.getClass().getSimpleName(),"
    },
    "JacksonDatabind-47": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == TYPE_ARRAY) {",
                "patch_diff": "if (type == TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s;",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s.getName(),",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s.getName(),",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (type %s == JsonToken.VALUE_NUMBER_FLOAT) {",
                "patch_diff": "} else if (type %s == JsonToken.VALUE_NUMBER_FLOAT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s == type) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s == type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s == type) {",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s == type) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s == type.getName(),",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s == type.getName(),",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s\",",
                "patch_diff": "throw new JsonMappingException(\"Failed to widen type %s with annotation (type %s\",",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "} else if (type %s == JsonToken.VALUE_NUMBER_INT) {",
                "patch_diff": "} else if (type %s == JsonToken.VALUE_NUMBER_INT) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (type!= TYPE_ARRAY) {",
                "patch_diff": "if (type!= TYPE_ARRAY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "Class<?> currRaw = type.getRawClass(); try { // 11-Oct-2015, tatu: For deser, we call `TypeFactory.constructSpecializedType()`, // may be needed here too in future? if (serClass.isAssignableFrom(currRaw)) { // common case type = tf.constructGeneralizedType(type, serClass); } else if (currRaw.isAssignableFrom(serClass)) { // specialization, ok as well type = tf.constructSpecializedType(type, serClass); } else { throw new JsonMappingException(null, String.format(\"Can not refine serialization type %s into %s; types not related\", type, serClass.getName())); }"
    },
    "Math-32": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (state.getAttributeFor tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:05.879180219 +0200\n+++ /tmp/tmpe5kwf1mg.java\t2022-07-12 17:20:05.899180123 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (state.getAttributeFor tree) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:08.603166923 +0200\n+++ /tmp/tmpdmmtzdkl.java\t2022-07-12 17:20:08.603166923 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (state.getAttributeFor tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:10.627157042 +0200\n+++ /tmp/tmpisf5jxr6.java\t2022-07-12 17:20:10.627157042 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if ( cannot.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:12.663147103 +0200\n+++ /tmp/tmpa66v1fsc.java\t2022-07-12 17:20:12.663147103 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if ( cannot.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:15.007135658 +0200\n+++ /tmp/tmpyvi6wz7k.java\t2022-07-12 17:20:15.007135658 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (wanted.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:17.051125676 +0200\n+++ /tmp/tmp1z23tx8w.java\t2022-07-12 17:20:17.051125676 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (wanted.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (state.getAttributeFor tree.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:19.127115538 +0200\n+++ /tmp/tmppguc_dcm.java\t2022-07-12 17:20:19.127115538 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttribute()) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:21.123105788 +0200\n+++ /tmp/tmpm01mgind.java\t2022-07-12 17:20:21.127105768 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (state.getAttributeFor tree.getAttributeFor tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:23.175095764 +0200\n+++ /tmp/tmpv6b7ok0t.java\t2022-07-12 17:20:23.175095764 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (state.getAttributeFor tree.getAttributeFor tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (wanted.getAttribute || tree.getAttribute) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-32/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\t2022-07-12 17:20:25.135086190 +0200\n+++ /tmp/tmpco83u46a.java\t2022-07-12 17:20:25.135086190 +0200\n@@ -131,11 +131,11 @@\n \n         final Vector2D[][] v = getVertices();\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+if (wanted.getAttribute || tree.getAttribute) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);\n             } else {\n                 setSize(0);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if ((Boolean) tree.getAttribute()) {",
        "fixed_line": "if (tree.getCut() == null && (Boolean) tree.getAttribute()) {"
    },
    "JacksonDatabind-83": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (options, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:27.459074832 +0200\n+++ /tmp/tmpt0fo2gpb.java\t2022-07-12 17:20:27.483074716 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (options, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (cause, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:29.303065824 +0200\n+++ /tmp/tmpekknkw1u.java\t2022-07-12 17:20:29.303065824 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (cause, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:30.943057809 +0200\n+++ /tmp/tmp4i_yq9zj.java\t2022-07-12 17:20:30.943057809 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (jp, ctxt)!= null) { return _deserialize(text, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:32.523050087 +0200\n+++ /tmp/tmp7ep04i1b.java\t2022-07-12 17:20:32.527050068 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (jp, ctxt)!= null) { return _deserialize(text, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (options, ctxt)!= null) { return _deserialize(jp, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:34.187041954 +0200\n+++ /tmp/tmpz3mbgkfv.java\t2022-07-12 17:20:34.187041954 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (options, ctxt)!= null) { return _deserialize(jp, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:35.735034388 +0200\n+++ /tmp/tmp9e4zy4ri.java\t2022-07-12 17:20:35.735034388 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:37.475025882 +0200\n+++ /tmp/tmpi7j54liw.java\t2022-07-12 17:20:37.479025863 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (options, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (cause, ctxt)!= null) { return _deserialize(text, ctxt); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:39.135017767 +0200\n+++ /tmp/tmpg7ors1ib.java\t2022-07-12 17:20:39.135017767 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (cause, ctxt)!= null) { return _deserialize(text, ctxt); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (module!= null) { return _deserialize(jp, ctxt, cause); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:40.799009631 +0200\n+++ /tmp/tmpa5xbc3o6.java\t2022-07-12 17:20:40.799009631 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (module!= null) { return _deserialize(jp, ctxt, cause); }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (_deserialize(jp, ctxt)!= null) { return _deserialize(jp, ctxt; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-83/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\t2022-07-12 17:20:42.543001103 +0200\n+++ /tmp/tmpe6zuvzik.java\t2022-07-12 17:20:42.547001084 +0200\n@@ -114,13 +114,11 @@\n             Exception cause = null;\n             try {\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n+if (_deserialize(jp, ctxt)!= null) { return _deserialize(jp, ctxt; }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n                 cause = me;\n             }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (_deserialize(text, ctxt) != null) { return _deserialize(text, ctxt); }",
        "fixed_line": ""
    },
    "Cli-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:44.326992379 +0200\n+++ /tmp/tmphcldhczw.java\t2022-07-12 17:20:44.386992083 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:46.110983655 +0200\n+++ /tmp/tmpe8vdu1fw.java\t2022-07-12 17:20:46.110983655 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return options.hasShortOption; // skip",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:47.770975536 +0200\n+++ /tmp/tmpj3okchdh.java\t2022-07-12 17:20:47.774975517 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption; // skip\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return optName.hasShortOption;optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:49.394967592 +0200\n+++ /tmp/tmp0crq7rrc.java\t2022-07-12 17:20:49.394967592 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return optName.hasShortOption;optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return options.hasShortOption(optName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:51.006959708 +0200\n+++ /tmp/tmplr593up6.java\t2022-07-12 17:20:51.006959708 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:52.578952017 +0200\n+++ /tmp/tmp4p1mcncf.java\t2022-07-12 17:20:52.578952017 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return optName.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:54.110944521 +0200\n+++ /tmp/tmpm7gd92el.java\t2022-07-12 17:20:54.110944521 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return optName.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:55.822936145 +0200\n+++ /tmp/tmpn9wlcld0.java\t2022-07-12 17:20:55.826936126 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption;optName!= JsonToken. return options.hasShortOption(optName);\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:57.314928845 +0200\n+++ /tmp/tmpi266nr60.java\t2022-07-12 17:20:57.314928845 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName!= JsonToken. return options.hasShortOption;\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return options.hasShortOption(optName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-38/src/main/java/org/apache/commons/cli/DefaultParser.java\t2022-07-12 17:20:58.850921327 +0200\n+++ /tmp/tmp9fh6ltox.java\t2022-07-12 17:20:58.850921327 +0200\n@@ -305,11 +305,11 @@\n         }\n \n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n+return options.hasShortOption(optName);\n         // check for several concatenated short options\n     }\n \n     /**\n      * Tells if the token looks like a long option.\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "return options.hasShortOption(optName);",
        "fixed_line": "if (options.hasShortOption(optName)) { return true; } // check for several concatenated short options return optName.length() > 0 && options.hasShortOption(String.valueOf(optName.charAt(0)));"
    },
    "Closure-161": {
        "fixes": [
            {
                "k": 1,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (right.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (right.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (type == Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (type == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold to use of",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold to use of",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold we can't fold if (left.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold we can't fold if (left.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (left.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (left.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType() == Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType() == Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (right.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (right.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (n.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (left.getType()!= Token.NUMBER) { if (n.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (right.getType()!= Token.NUMBER) { if (left.getType()!= Token.NUMBER) {",
                "patch_diff": "// // [JACKSON-407] -- allow disabling wrapping for a temporary we can't fold if (right.getType()!= Token.NUMBER) { if (left.getType()!= Token.NUMBER) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isAssignmentTarget(n)) { return n; }"
    },
    "Closure-125": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (docType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:21:03.510898520 +0200\n+++ /tmp/tmpa1cq8y9v.java\t2022-07-12 17:21:03.534898404 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (docType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:21:09.578868814 +0200\n+++ /tmp/tmpis2o_48h.java\t2022-07-12 17:21:09.578868814 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (unmodifiableType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:22:00.238620486 +0200\n+++ /tmp/tmpkeuynlpx.java\t2022-07-12 17:22:00.242620463 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (unmodifiableType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (docType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:22:04.034601856 +0200\n+++ /tmp/tmpt19b2xxo.java\t2022-07-12 17:22:04.034601856 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (docType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (unmodifiableType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:22:07.782583457 +0200\n+++ /tmp/tmpn0u8xwwe.java\t2022-07-12 17:22:07.786583439 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (unmodifiableType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if ( fnType!= null && fnType!=fnType) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:22:11.662564407 +0200\n+++ /tmp/tmp7qnvhgie.java\t2022-07-12 17:22:11.666564388 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null && fnType!=fnType) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (inType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:23:00.494324419 +0200\n+++ /tmp/tmpv9dyn0k1.java\t2022-07-12 17:23:00.498324400 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (inType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if ( fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:23:04.538304526 +0200\n+++ /tmp/tmptrg0tp7h.java\t2022-07-12 17:23:04.538304526 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if ( fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (fnType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:23:54.118060372 +0200\n+++ /tmp/tmp4sf6kv9v.java\t2022-07-12 17:23:54.118060372 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (fnType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (functionType!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-125/src/com/google/javascript/jscomp/TypeCheck.java\t2022-07-12 17:24:43.205818239 +0200\n+++ /tmp/tmp5bl6efu8.java\t2022-07-12 17:24:43.205818239 +0200\n@@ -1656,11 +1656,11 @@\n   private void visitNew(NodeTraversal t, Node n) {\n     Node constructor = n.getFirstChild();\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+if (functionType!= null) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {\n         ensureTyped(t, n);\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (fnType != null) {",
        "fixed_line": "if (fnType != null && fnType.hasInstanceType()) {"
    },
    "Closure-23": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (int i = 0, null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:24:47.361797720 +0200\n+++ /tmp/tmph9opud0h.java\t2022-07-12 17:24:47.389797583 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int i = 0, null && current!= intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:24:52.453772579 +0200\n+++ /tmp/tmp7opfr0ju.java\t2022-07-12 17:24:52.453772579 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && current!= intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (int i = 0; current!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:24:56.093754605 +0200\n+++ /tmp/tmpsfj0ig67.java\t2022-07-12 17:24:56.093754605 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; current!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (int i = 0; n!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:25:38.465545224 +0200\n+++ /tmp/tmp3laqx7pi.java\t2022-07-12 17:25:38.465545224 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; n!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (int i = 0; elem!= null && currentIndex < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:26:18.313348092 +0200\n+++ /tmp/tmp_r9n6e3c.java\t2022-07-12 17:26:18.317348073 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem!= null && currentIndex < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (int i = 0; it!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:26:22.081329440 +0200\n+++ /tmp/tmppyax0fm7.java\t2022-07-12 17:26:22.085329420 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; it!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int i = 0; elem!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:26:25.773311163 +0200\n+++ /tmp/tmp3v28qr9y.java\t2022-07-12 17:26:25.773311163 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0; elem!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (int i = first; current!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:27:05.965112091 +0200\n+++ /tmp/tmpt8o_hl82.java\t2022-07-12 17:27:05.965112091 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = first; current!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (int i = elem!= null && i < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:27:09.769093239 +0200\n+++ /tmp/tmpijc8dqjr.java\t2022-07-12 17:27:09.769093239 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = elem!= null && i < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (int i = 0, null && currentIndex < intIndex; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-23/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:27:13.585074327 +0200\n+++ /tmp/tmpke4150el.java\t2022-07-12 17:27:13.585074327 +0200\n@@ -1446,11 +1446,11 @@\n       return n;\n     }\n \n     Node current = left.getFirstChild();\n     Node elem = null;\n-    for (int i = 0; current != null && i < intIndex; i++) {\n+for (int i = 0, null && currentIndex < intIndex; i++) {\n         elem = current;\n \n       current = current.getNext();\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "for (int i = 0; current != null && i < intIndex; i++) {",
        "fixed_line": "for (int i = 0; current != null; i++) { if (i != intIndex) { if (mayHaveSideEffects(current)) { return n; } } else { elem = current; }"
    },
    "Jsoup-39": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (doc.length() == 0) {",
                "patch_diff": "if (doc.length() == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == null) {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (doc.length() == 0 && docData.charAt(0) ==",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) ==",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == '\\'') {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == '\\'') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == ']') {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == ']') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == '[') {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == '[') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (doc.length() > 0) {",
                "patch_diff": "if (doc.length() > 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == '/') {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == '/') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (doc.length() == 0 && docData.charAt(0) == Plot",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) == Plot",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (doc.length() == 0 && docData.charAt(0) ==Link') {",
                "patch_diff": "if (doc.length() == 0 && docData.charAt(0) ==Link') {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "doc = null;"
    },
    "Cli-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:19.093047024 +0200\n+++ /tmp/tmpv4q54wr9.java\t2022-07-12 17:27:19.137046809 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:22.173031758 +0200\n+++ /tmp/tmpxnz2ubdn.java\t2022-07-12 17:27:22.173031758 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:23.625024560 +0200\n+++ /tmp/tmpjix8a1nk.java\t2022-07-12 17:27:23.625024560 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (selected == null || selected.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:25.181016847 +0200\n+++ /tmp/tmpzwkkgkc8.java\t2022-07-12 17:27:25.185016828 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOptOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:27.509005305 +0200\n+++ /tmp/tmp3m7ic02w.java\t2022-07-12 17:27:27.509005305 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOptOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:29.316996341 +0200\n+++ /tmp/tmp6dx3xn7a.java\t2022-07-12 17:27:29.316996341 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null ||selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOptOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:31.824983906 +0200\n+++ /tmp/tmpcl0f8x94.java\t2022-07-12 17:27:31.824983906 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOptOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:33.476975715 +0200\n+++ /tmp/tmpy8lcksi4.java\t2022-07-12 17:27:33.476975715 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (selected == null || other.equals(option.getOpt())) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:36.012963141 +0200\n+++ /tmp/tmpbc8zevec.java\t2022-07-12 17:27:36.012963141 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || other.equals(option.getOpt())) {\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-27/src/java/org/apache/commons/cli/OptionGroup.java\t2022-07-12 17:27:37.748954531 +0200\n+++ /tmp/tmpzqwk7n_y.java\t2022-07-12 17:27:37.752954511 +0200\n@@ -93,13 +93,11 @@\n         }\n         \n         // if no option has already been selected or the \n         // same option is being reselected then set the\n         // selected member variable\n-        if (selected == null || selected.equals(option.getOpt()))\n-        {\n-            selected = option.getOpt();\n+if (selected == null || other.equals(option.getOpt())) { selected = option.getOpt\n         }\n         else\n         {\n             throw new AlreadySelectedException(this, option);\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (selected == null || selected.equals(option.getOpt())) { selected = option.getOpt();",
        "fixed_line": "if (selected == null || selected.equals(option.getKey())) { selected = option.getKey();"
    },
    "Math-94": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (u * v == 0) { // if even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:27:39.532945683 +0200\n+++ /tmp/tmp09pozb3d.java\t2022-07-12 17:27:39.564945524 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // if even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (u * v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:27:47.948903945 +0200\n+++ /tmp/tmpnt_cn5x0.java\t2022-07-12 17:27:47.948903945 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (u / v == 0.0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:27:54.924869342 +0200\n+++ /tmp/tmpmdqe0sx6.java\t2022-07-12 17:27:54.924869342 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u / v == 0.0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (u * v == 0) { // gcd is even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:01.976834355 +0200\n+++ /tmp/tmp2ih45_e1.java\t2022-07-12 17:28:01.976834355 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // gcd is even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (u * v == 0) { // not do zero",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:09.024799383 +0200\n+++ /tmp/tmp7kkcw6h1.java\t2022-07-12 17:28:09.024799383 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // not do zero\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (u * v == 0) { // even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:16.108764228 +0200\n+++ /tmp/tmpyz_sjknz.java\t2022-07-12 17:28:16.112764209 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) { // even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (u * v == 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:22.988730081 +0200\n+++ /tmp/tmpy77sld8v.java\t2022-07-12 17:28:22.988730081 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (u / v == 0.0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:30.024695155 +0200\n+++ /tmp/tmp3fy2k_er.java\t2022-07-12 17:28:30.024695155 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u / v == 0.0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (u * v == 0.0) { // if even...",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:37.240659330 +0200\n+++ /tmp/tmp3z3fbt2l.java\t2022-07-12 17:28:37.240659330 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0.0) { // if even...\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (u * v == 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-94/src/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:44.236624592 +0200\n+++ /tmp/tmpb40nbqev.java\t2022-07-12 17:28:44.236624592 +0200\n@@ -407,11 +407,11 @@\n      * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u * v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (u * v == 0) {",
        "fixed_line": "if ((u == 0) || (v == 0)) {"
    },
    "Math-79": {
        "fixes": [
            {
                "k": 1,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:51.944586316 +0200\n+++ /tmp/tmp2lop63n0.java\t2022-07-12 17:28:52.012585976 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:28:54.620573023 +0200\n+++ /tmp/tmp4fb673d9.java\t2022-07-12 17:28:54.620573023 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:03.240530208 +0200\n+++ /tmp/tmprm5rmzrb.java\t2022-07-12 17:29:03.240530208 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:09.972496764 +0200\n+++ /tmp/tmp6f_bple9.java\t2022-07-12 17:29:09.972496764 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) { return 0;i < p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "int sum = 0;_int i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:12.156485914 +0200\n+++ /tmp/tmpo8h8744z.java\t2022-07-12 17:29:12.156485914 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0;_int i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "int sum = 0; for (int i < p1.length; i++) { return 0;i < p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:14.312475203 +0200\n+++ /tmp/tmpw_w3sgj4.java\t2022-07-12 17:29:14.316475184 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i < p1.length; i++) { return 0;i < p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "int sum = 0; if (p1.length - p2.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:16.364465006 +0200\n+++ /tmp/tmp9301eqzt.java\t2022-07-12 17:29:16.368464987 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; if (p1.length - p2.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int sum = 0; for (int i = 0; i < p1.length; i++) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:18.524454274 +0200\n+++ /tmp/tmpd5img0nq.java\t2022-07-12 17:29:18.524454274 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i = 0; i < p1.length; i++) {\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "int sum = 0;_int i < p1.length; i++) { final int dp = p2[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:20.712443403 +0200\n+++ /tmp/tmprye3jn03.java\t2022-07-12 17:29:20.716443384 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0;_int i < p1.length; i++) { final int dp = p2[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int sum = 0; for (int i < p1.length; i++) { final int dp = p1[i];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-79/src/main/java/org/apache/commons/math/util/MathUtils.java\t2022-07-12 17:29:22.660433724 +0200\n+++ /tmp/tmpnwx0o678.java\t2022-07-12 17:29:22.664433702 +0200\n@@ -1619,13 +1619,11 @@\n      * @param p1 the first point\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n     public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n+int sum = 0; for (int i < p1.length; i++) { final int dp = p1[i];\n           sum += dp * dp;\n       }\n       return Math.sqrt(sum);\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i];",
        "fixed_line": "double sum = 0; for (int i = 0; i < p1.length; i++) { final double dp = p1[i] - p2[i];"
    },
    "JacksonDatabind-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "found = ctor_TYPE.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:24.952422335 +0200\n+++ /tmp/tmp4wnak7l0.java\t2022-07-12 17:29:25.012422032 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_TYPE.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "found = t.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:27.292410705 +0200\n+++ /tmp/tmp1d52cb7u.java\t2022-07-12 17:29:27.292410705 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = t.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "found = reference.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:29.132401560 +0200\n+++ /tmp/tmplhwzpbpm.java\t2022-07-12 17:29:29.132401560 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = reference.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "found = slot.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:30.972392416 +0200\n+++ /tmp/tmp_2c1k5v5.java\t2022-07-12 17:29:30.972392416 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = slot.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "found =ClassType.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:32.916382756 +0200\n+++ /tmp/tmpuqow9gc7.java\t2022-07-12 17:29:32.916382756 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found =ClassType.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "found = _props.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:34.868373052 +0200\n+++ /tmp/tmpc_p4bcnc.java\t2022-07-12 17:29:34.872373033 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = _props.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "found = NULL.equals(prop.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:36.796363470 +0200\n+++ /tmp/tmpnu6hzz3x.java\t2022-07-12 17:29:36.800363451 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = NULL.equals(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "found = t.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:38.656354224 +0200\n+++ /tmp/tmpq6ojnxb5.java\t2022-07-12 17:29:38.660354205 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = t.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "found = ctor_NOT_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:40.528344919 +0200\n+++ /tmp/tmpspzsu986.java\t2022-07-12 17:29:40.528344919 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_NOT_EMPTY;\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "found = ctor_TYPE.equals(key.getName());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-70/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\t2022-07-12 17:29:42.376335733 +0200\n+++ /tmp/tmpg3rnuyra.java\t2022-07-12 17:29:42.376335733 +0200\n@@ -435,11 +435,11 @@\n                 continue;\n             }\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+found = ctor_TYPE.equals(key.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;\n                     continue;\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "found = key.equals(prop.getName());",
        "fixed_line": "found = key.equals(_hashArea[i-1]);"
    },
    "JacksonDatabind-34": {
        "fixes": [
            {
                "k": 1,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:29:44.504325155 +0200\n+++ /tmp/tmpw4ibj6ql.java\t2022-07-12 17:29:44.600324679 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:29:46.492315273 +0200\n+++ /tmp/tmp65gf7_bb.java\t2022-07-12 17:29:46.492315273 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:25.052123522 +0200\n+++ /tmp/tmps94_hrva.java\t2022-07-12 17:30:25.052123522 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER)\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:26.832114669 +0200\n+++ /tmp/tmp3z6wrr44.java\t2022-07-12 17:30:26.832114669 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:28.412106806 +0200\n+++ /tmp/tmpjqqw7mxt.java\t2022-07-12 17:30:28.416106787 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "visitFloatFormat(typeHint, _typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:30.100098411 +0200\n+++ /tmp/tmpo7wz485d.java\t2022-07-12 17:30:30.100098411 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, _typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:31.848089713 +0200\n+++ /tmp/tmpti1i7aqh.java\t2022-07-12 17:30:31.848089713 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(typeHint, h, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:33.636080818 +0200\n+++ /tmp/tmp36leuhag.java\t2022-07-12 17:30:33.640080799 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat = _typeHint, h, JsonParser.NumberType.BIG_INTEGER);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:35.336072360 +0200\n+++ /tmp/tmphvpcxcgb.java\t2022-07-12 17:30:35.336072360 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER =\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "visitFloatFormat (visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-34/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\t2022-07-12 17:30:37.152063327 +0200\n+++ /tmp/tmp96pqv_xc.java\t2022-07-12 17:30:37.152063327 +0200\n@@ -76,11 +76,11 @@\n         if (_isInt) {\n             visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat (visitor, typeHint, JsonParser.NumberType.BIG_INTEGER;\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
        "fixed_line": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);"
    },
    "Jsoup-25": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:39.108053596 +0200\n+++ /tmp/tmp41keaqug.java\t2022-07-12 17:30:39.220053039 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"Era\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:41.540041494 +0200\n+++ /tmp/tmp0wbm8sjc.java\t2022-07-12 17:30:41.540041494 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"Era\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:43.432032080 +0200\n+++ /tmp/tmp5nv3_xtr.java\t2022-07-12 17:30:43.432032080 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:44.856024994 +0200\n+++ /tmp/tmp98z4k6i6.java\t2022-07-12 17:30:44.856024994 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:46.396017331 +0200\n+++ /tmp/tmp5d0lvl5z.java\t2022-07-12 17:30:46.396017331 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"title\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"U\"};\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:48.008009312 +0200\n+++ /tmp/tmp2rw8xo3q.java\t2022-07-12 17:30:48.008009312 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"link\"};\", \"U\"};\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\", \"Era\");",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:49.504001866 +0200\n+++ /tmp/tmponitwx5_.java\t2022-07-12 17:30:49.504001866 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"title\"};\", \"U\"};\", \"Era\");\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"ESCAPE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:51.023994304 +0200\n+++ /tmp/tmp7jp23df5.java\t2022-07-12 17:30:51.023994304 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"U\"};\", \"ESCAPE\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84};",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:52.703985943 +0200\n+++ /tmp/tmpa22ctoxc.java\t2022-07-12 17:30:52.703985943 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84};\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-25/src/main/java/org/jsoup/parser/Tag.java\t2022-07-12 17:30:54.271978140 +0200\n+++ /tmp/tmp_4786mtu.java\t2022-07-12 17:30:54.275978118 +0200\n@@ -213,11 +213,11 @@\n             \"device\"\n     };\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\", \"X84;\n \n     static {\n         // creates\n         for (String tagName : blockTags) {\n             Tag tag = new Tag(tagName);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};",
        "fixed_line": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};"
    },
    "Chart-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "PathIterator iterator2 = p2.getPathIterator(null);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:30:56.131968884 +0200\n+++ /tmp/tmp_jel9yqy.java\t2022-07-12 17:30:56.167968702 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 2,
                "patch": "PathIterator iterator2 = p2.getPathIterator(args2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:06.375917897 +0200\n+++ /tmp/tmp177xbjd8.java\t2022-07-12 17:31:06.395917799 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(args2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "PathIterator iterator2 = p1.getPathIterator(q2.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:08.243908599 +0200\n+++ /tmp/tmpg_5z4tlh.java\t2022-07-12 17:31:08.243908599 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(q2.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "PathIterator iterator2 = p1.getPathIterator(q2.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:10.011899798 +0200\n+++ /tmp/tmppwcf69gt.java\t2022-07-12 17:31:10.011899798 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(q2.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "PathIterator iterator2 = p2.getPathIterator(p1.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:11.687891456 +0200\n+++ /tmp/tmppzgrrj44.java\t2022-07-12 17:31:11.687891456 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(p1.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:13.523882316 +0200\n+++ /tmp/tmphyu9t1r8.java\t2022-07-12 17:31:13.523882316 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(p2.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "PathIterator iterator2 = p2.getPathIterator(p1.getPathIterators2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:15.459872679 +0200\n+++ /tmp/tmp6rsk1i__.java\t2022-07-12 17:31:15.459872679 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(p1.getPathIterators2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "PathIterator iterator2 = p2.getPathIterator(q2);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:17.287863579 +0200\n+++ /tmp/tmpqkkmlknv.java\t2022-07-12 17:31:17.287863579 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(q2);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:19.195854082 +0200\n+++ /tmp/tmpd30iku8v.java\t2022-07-12 17:31:19.195854082 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p1.getPathIterator(p2.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "PathIterator iterator2 = p2.getPathIterator(q1.getPathIterator;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-11/source/org/jfree/chart/util/ShapeUtilities.java\t2022-07-12 17:31:20.999845099 +0200\n+++ /tmp/tmpl9nuxi15.java\t2022-07-12 17:31:20.999845099 +0200\n@@ -270,11 +270,11 @@\n         }\n         if (p1.getWindingRule() != p2.getWindingRule()) {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+PathIterator iterator2 = p2.getPathIterator(q1.getPathIterator;\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();\n         while (!done) {\n             if (iterator1.isDone() != iterator2.isDone()) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "PathIterator iterator2 = p1.getPathIterator(null);",
        "fixed_line": "PathIterator iterator2 = p2.getPathIterator(null);"
    },
    "Math-58": {
        "fixes": [
            {
                "k": 1,
                "patch": "return guess.Parametric(), guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:31:22.867835797 +0200\n+++ /tmp/tmp2djmb1mb.java\t2022-07-12 17:31:22.887835701 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric(), guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return guess.Parametric(), guess);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:31:25.395823215 +0200\n+++ /tmp/tmpym2eq4jf.java\t2022-07-12 17:31:25.395823215 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric(), guess);\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return fit;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:31:27.531812579 +0200\n+++ /tmp/tmp8pso6m1l.java\t2022-07-12 17:31:27.535812560 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return fit;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:31:29.875800908 +0200\n+++ /tmp/tmp2vvoeg8f.java\t2022-07-12 17:31:29.875800908 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return guess.Parametric % guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:15.715572599 +0200\n+++ /tmp/tmp1_2_enlu.java\t2022-07-12 17:32:15.715572599 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric % guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return guess.Parametric!= guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:17.787562275 +0200\n+++ /tmp/tmpyaoakmzd.java\t2022-07-12 17:32:17.787562275 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric!= guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return guess.Parametric - guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:20.071550896 +0200\n+++ /tmp/tmpu0zz0d21.java\t2022-07-12 17:32:20.071550896 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric - guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return guess.Parametric point (0 + guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:22.343539574 +0200\n+++ /tmp/tmpcissaf9t.java\t2022-07-12 17:32:22.343539574 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric point (0 + guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return guess.Parametric += guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:24.411529272 +0200\n+++ /tmp/tmpak7iw2g7.java\t2022-07-12 17:32:24.411529272 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return guess.Parametric += guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return fit.Parametric(), guess;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-58/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\t2022-07-12 17:32:26.519518768 +0200\n+++ /tmp/tmpgv0kbyob.java\t2022-07-12 17:32:26.519518768 +0200\n@@ -116,11 +116,11 @@\n      * @return the parameters of the Gaussian function that best fits the\n      * observed points (in the same order as above).\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+return fit.Parametric(), guess;\n     }\n \n     /**\n      * Guesses the parameters {@code norm}, {@code mean}, and {@code sigma}\n      * of a {@link org.apache.commons.math.analysis.function.Gaussian.Parametric}\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return fit(new Gaussian.Parametric(), guess);",
        "fixed_line": "return fit(guess);"
    },
    "Closure-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; c = n.getFirstChild();",
                "patch_diff": "return false; c = n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return false; c = n.getFirstChild()!= null; c = c.getNext()) {",
                "patch_diff": "return false; c = n.getFirstChild()!= null; c = c.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return false; c = n.getFirstChild()) {",
                "patch_diff": "return false; c = n.getFirstChild()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return false; c = c.getFirstChild();",
                "patch_diff": "return false; c = c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return false; c!= null; c = c.getFirstChild()) {",
                "patch_diff": "return false; c!= null; c = c.getFirstChild()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return false; c!= null; c = c.getNext()) {",
                "patch_diff": "return false; c!= null; c = c.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (NodeUtil.constructorCallHasSideEffects(c)) {",
                "patch_diff": "if (NodeUtil.constructorCallHasSideEffects(c)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return false; c!= null; c = c.getFirstChild();",
                "patch_diff": "return false; c!= null; c = c.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "patch_diff": "if (NodeUtil.constructorCallHasSideEffects(c) && n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return true; c = n.getFirstChild();",
                "patch_diff": "return true; c = n.getFirstChild();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.isDelProp()) { return true; }"
    },
    "Codec-15": {
        "fixes": [
            {
                "k": 1,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:30.771497577 +0200\n+++ /tmp/tmp35n5q59y.java\t2022-07-12 17:32:30.871497081 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:32.819487376 +0200\n+++ /tmp/tmpm6noln7q.java\t2022-07-12 17:32:32.823487354 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:34.495479024 +0200\n+++ /tmp/tmpvst5dazd.java\t2022-07-12 17:32:34.495479024 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:35.983471609 +0200\n+++ /tmp/tmpcsqzkm1l.java\t2022-07-12 17:32:35.983471609 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final char hwChar = str.charAt(index - 1) == namesChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:37.563463733 +0200\n+++ /tmp/tmp6zw42oak.java\t2022-07-12 17:32:37.563463733 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == namesChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:39.107456039 +0200\n+++ /tmp/tmp66xpwdft.java\t2022-07-12 17:32:39.107456039 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) ===0Char || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:40.619448504 +0200\n+++ /tmp/tmpvkogqkhx.java\t2022-07-12 17:32:40.619448504 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == ':'WChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:42.263440312 +0200\n+++ /tmp/tmpin_j_6bw.java\t2022-07-12 17:32:42.267440290 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == hwChar || 'W' == preHWChar || 'W' == preHWChar;\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final char hwChar = str.charAt(index - 1) == initChar || 'W' == preHWChar || 'W' == preHWChar) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:43.763432835 +0200\n+++ /tmp/tmpp0ql2zvo.java\t2022-07-12 17:32:43.767432815 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == initChar || 'W' == preHWChar || 'W' == preHWChar) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-15/src/main/java/org/apache/commons/codec/language/Soundex.java\t2022-07-12 17:32:45.375424803 +0200\n+++ /tmp/tmpzge9g5c7.java\t2022-07-12 17:32:45.375424803 +0200\n@@ -183,15 +183,11 @@\n     private char getMappingCode(final String str, final int index) {\n         // map() throws IllegalArgumentException\n         final char mappedChar = this.map(str.charAt(index));\n         // HW rule check\n         if (index > 1 && mappedChar != '0') {\n-            final char hwChar = str.charAt(index - 1);\n-            if ('H' == hwChar || 'W' == hwChar) {\n-                final char preHWChar = str.charAt(index - 2);\n-                final char firstCode = this.map(preHWChar);\n-                if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {\n+final char hwChar = str.charAt(index - 1) == mappedChar || 'W' == preHWChar || 'W' == preHWChar)) {\n                     return 0;\n                 }\n             }\n         }\n         return mappedChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final char hwChar = str.charAt(index - 1); if ('H' == hwChar || 'W' == hwChar) { final char preHWChar = str.charAt(index - 2); final char firstCode = this.map(preHWChar); if (firstCode == mappedChar || 'H' == preHWChar || 'W' == preHWChar) {",
        "fixed_line": "for (int i=index-1 ; i>=0 ; i--) { final char prevChar = str.charAt(i); if (this.map(prevChar)==mappedChar) { return 0; } if ('H'!=prevChar && 'W'!=prevChar) { break; }"
    },
    "Closure-48": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:32:47.419414614 +0200\n+++ /tmp/tmpt221efpw.java\t2022-07-12 17:32:47.467414373 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (valueType == null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:32:52.555389017 +0200\n+++ /tmp/tmpkp2k97af.java\t2022-07-12 17:32:52.555389017 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (valueType == null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:32:56.379369955 +0200\n+++ /tmp/tmpl7s0y18n.java\t2022-07-12 17:32:56.379369955 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (valueType!= null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:00.379350016 +0200\n+++ /tmp/tmpdn1kq17p.java\t2022-07-12 17:33:00.379350016 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (valueType!= null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:03.819332868 +0200\n+++ /tmp/tmp0a6sr2qc.java\t2022-07-12 17:33:03.819332868 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:07.375315141 +0200\n+++ /tmp/tmpd4_7cuc3.java\t2022-07-12 17:33:07.379315122 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false ||!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:10.987297134 +0200\n+++ /tmp/tmpwi5u4r2l.java\t2022-07-12 17:33:10.987297134 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (valueType == null || rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:14.495279645 +0200\n+++ /tmp/tmp1i4yv504.java\t2022-07-12 17:33:14.499279626 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType == null || rhsValue!= null &&!scope.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (valueType && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:18.035261996 +0200\n+++ /tmp/tmp29j0qp4w.java\t2022-07-12 17:33:18.035261996 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType && rhsValue!= null && rhsValue.isFunction() &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) &&!scope.isDeclared(qName, false) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-48/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:33:21.495244747 +0200\n+++ /tmp/tmpxal76vhu.java\t2022-07-12 17:33:21.495244747 +0200\n@@ -1516,15 +1516,11 @@\n             || (info.isConstant() && valueType != null\n                 && !valueType.isUnknownType())\n             || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n       }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n+if (valueType!= null && rhsValue!= null && (info.isFunction() &&!scope.isDeclared(qName, false) &&!scope.isDeclared(qName, false) {\n       }\n \n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (inferred) { // Determining declaration for #2 inferred = !(rhsValue != null && rhsValue.isFunction() && (info != null || !scope.isDeclared(qName, false)));",
        "fixed_line": "if (inferred && rhsValue != null && rhsValue.isFunction()) { // Determining declaration for #2 if (info != null) { inferred = false; } else if (!scope.isDeclared(qName, false) && n.isUnscopedQualifiedName()) { inferred = false; }"
    },
    "Closure-126": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:25.315225700 +0200\n+++ /tmp/tmpnv3n38tt.java\t2022-07-12 17:33:25.371225418 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:30.027202203 +0200\n+++ /tmp/tmpju_2w6i2.java\t2022-07-12 17:33:30.027202203 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:33.715183813 +0200\n+++ /tmp/tmpyt4t961t.java\t2022-07-12 17:33:33.715183813 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:37.175166559 +0200\n+++ /tmp/tmpzcog2amv.java\t2022-07-12 17:33:37.175166559 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName);\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (n.hasFinallyBlock = n, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:40.779148588 +0200\n+++ /tmp/tmpkcod4ziu.java\t2022-07-12 17:33:40.779148588 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (n.hasFinallyBlock = n, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:44.351130772 +0200\n+++ /tmp/tmpbqwc9f_k.java\t2022-07-12 17:33:44.355130752 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (n.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:47.875113197 +0200\n+++ /tmp/tmpviad5_wl.java\t2022-07-12 17:33:47.879113179 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (n.hasFinallyBlock = n; tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (NodeUtil.hasFinallyBlock = n, exitType, labelName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:51.467095281 +0200\n+++ /tmp/tmpodxd7fj5.java\t2022-07-12 17:33:51.467095281 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n, exitType, labelName);\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:54.931078005 +0200\n+++ /tmp/tmpcc0jd_1s.java\t2022-07-12 17:33:54.931078005 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (NodeUtil.hasFinallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (n.hasFinallyBlock = n, exitType, labelName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-126/src/com/google/javascript/jscomp/MinimizeExitPoints.java\t2022-07-12 17:33:58.347060969 +0200\n+++ /tmp/tmpcpk5fytx.java\t2022-07-12 17:33:58.347060969 +0200\n@@ -136,14 +136,11 @@\n       }\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+if (n.hasFinallyBlock = n, exitType, labelName;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); }",
        "fixed_line": ""
    },
    "Csv-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (current == '\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:02.067042409 +0200\n+++ /tmp/tmpq6d3j1fh.java\t2022-07-12 17:34:02.087042311 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (current == '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:05.227026648 +0200\n+++ /tmp/tmp7r7zx5tv.java\t2022-07-12 17:34:05.227026648 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (current == '\\n') { // firstChar; need the lastChar",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:07.787013880 +0200\n+++ /tmp/tmp44o_9rfw.java\t2022-07-12 17:34:07.787013880 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar; need the lastChar\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (current == '\\n') { // firstChar = current; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:10.427000708 +0200\n+++ /tmp/tmp18jbnaag.java\t2022-07-12 17:34:10.427000708 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar = current; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (current == '\\n') { // firstChar == lastChar; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:12.798988875 +0200\n+++ /tmp/tmpe02pv1_e.java\t2022-07-12 17:34:12.798988875 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == '\\n') { // firstChar == lastChar; }\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (current ==('\\n') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:15.238976703 +0200\n+++ /tmp/tmps8163reh.java\t2022-07-12 17:34:15.238976703 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current ==('\\n') {\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (current == == '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:16.674969542 +0200\n+++ /tmp/tmp1sukfjt6.java\t2022-07-12 17:34:16.678969519 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == == '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (current == == '\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:18.286961496 +0200\n+++ /tmp/tmp2i385upn.java\t2022-07-12 17:34:18.286961496 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current == == '\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (current!= '\\n') { // firstChar; need to do lineCounter",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:19.730954293 +0200\n+++ /tmp/tmpxypqmfa3.java\t2022-07-12 17:34:19.730954293 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current!= '\\n') { // firstChar; need to do lineCounter\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (current ==('\\n') { // firstChar; need to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Csv-1/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java\t2022-07-12 17:34:22.226941842 +0200\n+++ /tmp/tmpvtmohxbk.java\t2022-07-12 17:34:22.226941842 +0200\n@@ -53,11 +53,11 @@\n     }\n \n     @Override\n     public int read() throws IOException {\n         int current = super.read();\n-        if (current == '\\n') {\n+if (current ==('\\n') { // firstChar; need to check\n             lineCounter++;\n         }\n         lastChar = current;\n         return lastChar;\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (current == '\\n') {",
        "fixed_line": "if (current == '\\r' || (current == '\\n' && lastChar != '\\r')) {"
    },
    "Closure-124": {
        "fixes": [
            {
                "k": 1,
                "patch": "return false; }",
                "patch_diff": "return false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (node.isName;",
                "patch_diff": "if (node.isName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (node.isName) && isNameAssignedTo(node.getString(), replacement)) {",
                "patch_diff": "if (node.isName) && isNameAssignedTo(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (node.isName && isName == node) {",
                "patch_diff": "if (node.isName && isName == node) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (node.isName) && isNameAssignedTo(node.getString(), replacement)) {",
                "patch_diff": "} else if (node.isName) && isNameAssignedTo(node.getString(), replacement)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (node.isName) && isName;",
                "patch_diff": "if (node.isName) && isName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (node.isName && isName) {",
                "patch_diff": "if (node.isName && isName) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (node.isName) && isNameAssignedTo(node.getString(), replacement;",
                "patch_diff": "if (node.isName) && isNameAssignedTo(node.getString(), replacement;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (node.isName) && isName == node;",
                "patch_diff": "if (node.isName) && isName == node;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (node.isName && isExtern) {",
                "patch_diff": "if (node.isName && isExtern) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "while (node.isGetProp()) { node = node.getFirstChild(); }"
    },
    "Csv-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final String recordSeparator = format.getRecordSeparator;",
                "patch_diff": "private static final String recordSeparator = format.getRecordSeparator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final String recordSeparator = format.getRecordSeparator();",
                "patch_diff": "private static final String recordSeparator = format.getRecordSeparator();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// recordSeparator = format.getRecordSeparator;",
                "patch_diff": "// recordSeparator = format.getRecordSeparator;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// recordSeparator = format.getRecordSeparator();",
                "patch_diff": "// recordSeparator = format.getRecordSeparator();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public void println = false;",
                "patch_diff": "public void println = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// for (int c = 0; i < recordSeparator; ++i) {",
                "patch_diff": "// for (int c = 0; i < recordSeparator; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// for (int c = 0; c < recordSeparator; ++i) {",
                "patch_diff": "// for (int c = 0; c < recordSeparator; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final String recordSeparator = format.getRecordSeparator(); newRecord = true;",
                "patch_diff": "private static final String recordSeparator = format.getRecordSeparator(); newRecord = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "patch_diff": "private static final String recordSeparator = format.getRecordSeparator(); newRecord = true; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final String recordSeparator = format.getRecordSeparator; }",
                "patch_diff": "private static final String recordSeparator = format.getRecordSeparator; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (recordSeparator != null) { out.append(recordSeparator); }"
    },
    "Closure-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG.",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) :",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) :",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG\");",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : allType, type);",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : allType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG;",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG't currently modeled in the CFG.",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : \"this\" references aren't currently modeled in the CFG't currently modeled in the CFG.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type;",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : origType, type;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "patch_diff": "if (origType == null? getNativeType(UNKNOWN_TYPE) : origType, type);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : new IllegalArgumentException(\"this\" references aren't currently modeled in the CFG.",
                "patch_diff": "return origType = origType == null? getNativeType(UNKNOWN_TYPE) : new IllegalArgumentException(\"this\" references aren't currently modeled in the CFG.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "case Token.THIS: // \"this\" references aren't currently modeled in the CFG. break;"
    },
    "Gson-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (toResolve instanceof TypeVariable<?>) {",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (toResolve instanceof TypeVariable<?>) { if (toResolve == typeVariable<?>) {",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { if (toResolve == typeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> type",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> type",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (toResolve instanceof TypeVariable<?>) {",
                "patch_diff": "} else if (toResolve instanceof TypeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?>)",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?>)",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (toResolve instanceof TypeVariable<?>) { if (toResolve instanceof TypeVariable<?>) {",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { if (toResolve instanceof TypeVariable<?>) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>) typeVariable",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>) typeVariable",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>) typeVariable<?>) to",
                "patch_diff": "if (toResolve instanceof TypeVariable<?>) { throw new RuntimeException(\"TypeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable<?> typeVariable = (TypeVariable<?>) typeVariable<?>) to",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (visitedTypeVariables.contains(typeVariable)) { // cannot reduce due to infinite recursion return toResolve; } else { visitedTypeVariables.add(typeVariable); }"
    },
    "Cli-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:32.006893049 +0200\n+++ /tmp/tmpddkqjs3n.java\t2022-07-12 17:34:32.030892926 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:33.770884243 +0200\n+++ /tmp/tmpkruaods7.java\t2022-07-12 17:34:33.774884223 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:35.226876978 +0200\n+++ /tmp/tmpc8iql61s.java\t2022-07-12 17:34:35.226876978 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) {\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:36.790869176 +0200\n+++ /tmp/tmpm9nlr_k_.java\t2022-07-12 17:34:36.790869176 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:38.270861791 +0200\n+++ /tmp/tmpfdgghhf4.java\t2022-07-12 17:34:38.270861791 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { token.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:39.702854643 +0200\n+++ /tmp/tmpr3j640jd.java\t2022-07-12 17:34:39.702854643 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.STRING) token.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:41.446845941 +0200\n+++ /tmp/tmp3gtbbqug.java\t2022-07-12 17:34:41.466845843 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= -1) { tokens.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:43.010838138 +0200\n+++ /tmp/tmpvkxr65bw.java\t2022-07-12 17:34:43.010838138 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, tokens.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:44.842828994 +0200\n+++ /tmp/tmpf_msi57_.java\t2022-07-12 17:34:44.866828874 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(0, token.length - 1) { tokens.indexOf('=') + 1, tokens.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (token.indexOf('=')!= token.substring(token.indexOf('=') + 1, token.length()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-20/src/java/org/apache/commons/cli/PosixParser.java\t2022-07-12 17:34:46.486820791 +0200\n+++ /tmp/tmp62u4idnq.java\t2022-07-12 17:34:46.514820653 +0200\n@@ -109,18 +109,11 @@\n             String token = (String) iter.next();\n \n             // handle long option --foo or --foo=bar\n             if (token.startsWith(\"--\"))\n             {\n-                if (token.indexOf('=') != -1)\n-                {\n-                    tokens.add(token.substring(0, token.indexOf('=')));\n-                    tokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n-                }\n-                else\n-                {\n-                    tokens.add(token);\n+if (token.indexOf('=')!= token.substring(token.indexOf('=') + 1, token.length()));\n                 }\n             }\n \n             // single hyphen\n             else if (\"-\".equals(token))\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (token.indexOf('=') != -1) { tokens.add(token.substring(0, token.indexOf('='))); tokens.add(token.substring(token.indexOf('=') + 1, token.length())); } else { tokens.add(token);",
        "fixed_line": "int pos = token.indexOf('='); String opt = pos == -1 ? token : token.substring(0, pos); // --foo if (!options.hasOption(opt) && stopAtNonOption) { process(token); } else { tokens.add(opt); if (pos != -1) { tokens.add(token.substring(pos + 1)); }"
    },
    "Math-91": {
        "fixes": [
            {
                "k": 1,
                "patch": "double dOn = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:34:48.318811648 +0200\n+++ /tmp/tmpktusmgow.java\t2022-07-12 17:34:48.414811172 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double dOn = object.doubleValue() < dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:34:51.074797895 +0200\n+++ /tmp/tmppvq65i8q.java\t2022-07-12 17:34:51.074797895 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() < dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double dOn = object.doubleValue() * dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:34:53.362786477 +0200\n+++ /tmp/tmp9gqiiy2w.java\t2022-07-12 17:34:53.362786477 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() * dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double dOn = object.doubleValue() / dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:34:55.662774998 +0200\n+++ /tmp/tmpjpnkxxqp.java\t2022-07-12 17:34:55.662774998 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() / dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double dOn = object.doubleValue() - dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:34:57.866763998 +0200\n+++ /tmp/tmps0w9g028.java\t2022-07-12 17:34:57.866763998 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() - dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double dOn = value; double dOn = object.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:35:00.010753297 +0200\n+++ /tmp/tmpbpor8f1h.java\t2022-07-12 17:35:00.010753297 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double dOn = value; double dOn = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:35:02.338741681 +0200\n+++ /tmp/tmpu15jvros.java\t2022-07-12 17:35:02.342741658 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double dOnData = object.doubleValue() * dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:35:04.674730019 +0200\n+++ /tmp/tmpkiazk0on.java\t2022-07-12 17:35:04.674730019 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOnData = object.doubleValue() * dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double dOn = object.doubleValue() / dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:35:06.990718460 +0200\n+++ /tmp/tmpzj0_e1d9.java\t2022-07-12 17:35:06.994718441 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = object.doubleValue() / dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double dOn = value; double dOn = object.doubleValue() < dOnData.doubleValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-91/src/java/org/apache/commons/math/fraction/Fraction.java\t2022-07-12 17:35:09.330706781 +0200\n+++ /tmp/tmp1p45dqke.java\t2022-07-12 17:35:09.330706781 +0200\n@@ -254,12 +254,11 @@\n      * @param object the object to compare to\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+double dOn = value; double dOn = object.doubleValue() < dOnData.doubleValue();\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     \n     /**\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "double nOd = doubleValue(); double dOn = object.doubleValue();",
        "fixed_line": "long nOd = ((long) numerator) * object.denominator; long dOn = ((long) denominator) * object.numerator;"
    },
    "Chart-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:11.946693723 +0200\n+++ /tmp/tmp9mpj_yfc.java\t2022-07-12 17:35:12.034693284 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE)\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:14.878679091 +0200\n+++ /tmp/tmpyit2eav9.java\t2022-07-12 17:35:14.878679091 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2], null)\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE );",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:16.698670003 +0200\n+++ /tmp/tmptuclhzbt.java\t2022-07-12 17:35:16.698670003 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE );\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:18.414661440 +0200\n+++ /tmp/tmpq7f03z5x.java\t2022-07-12 17:35:18.414661440 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE) {\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:20.126652892 +0200\n+++ /tmp/tmpokvsnf3j.java\t2022-07-12 17:35:20.126652892 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h[2],\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:22.170642688 +0200\n+++ /tmp/tmpvdyu96ch.java\t2022-07-12 17:35:22.170642688 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4),",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:24.102633044 +0200\n+++ /tmp/tmp81x3i2go.java\t2022-07-12 17:35:24.106633025 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:25.926623939 +0200\n+++ /tmp/tmp8i_e7rfk.java\t2022-07-12 17:35:25.930623919 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE;\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:27.706615052 +0200\n+++ /tmp/tmpbfsupded.java\t2022-07-12 17:35:27.706615052 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4);\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Chart-13/source/org/jfree/chart/block/BorderArrangement.java\t2022-07-12 17:35:29.378606706 +0200\n+++ /tmp/tmp1_05lnxa.java\t2022-07-12 17:35:29.378606706 +0200\n@@ -450,11 +450,11 @@\n             w[2] = size.width;\n         }\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+new Range(0.0, constraint.getWidth() - w[2]), LengthConstraintType.RANGE, h4));\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);\n             w[3] = size.width;\n         }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "new Range(0.0, constraint.getWidth() - w[2]),",
        "fixed_line": "new Range(0.0, Math.max(constraint.getWidth() - w[2], 0.0)),"
    },
    "Closure-95": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (scope.isDeclareIn.isDeclared(variableName, false) {",
                "patch_diff": "if (scope.isDeclareIn.isDeclared(variableName, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (scopeToDeclareIn.isDeclared(variableName, false) {",
                "patch_diff": "if (scopeToDeclareIn.isDeclared(variableName, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (scope.isDeclareIn = scope;",
                "patch_diff": "if (scope.isDeclareIn = scope;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (scope.isDeclareIn) {",
                "patch_diff": "if (scope.isDeclareIn) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (scope.isDeclareIn = false;",
                "patch_diff": "if (scope.isDeclareIn = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (scope.isDeclareIncompleteType) {",
                "patch_diff": "if (scope.isDeclareIncompleteType) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (scope.isDeclareIn = true;",
                "patch_diff": "if (scope.isDeclareIn = true;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (scope.isDeclareIn(scope, false) {",
                "patch_diff": "if (scope.isDeclareIn(scope, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (scope.isDeclareIn.isDeclared(name, false) {",
                "patch_diff": "if (scope.isDeclareIn.isDeclared(name, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (scope.isDeclareIn.isName(scope, false) {",
                "patch_diff": "if (scope.isDeclareIn.isName(scope, false) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (n.getType() == Token.GETPROP && !scope.isGlobal() && isQnameRootedInGlobalScope(n)) { Scope globalScope = scope.getGlobalScope(); // don't try to declare in the global scope if there's // already a symbol there with this name. if (!globalScope.isDeclared(variableName, false)) { scopeToDeclareIn = scope.getGlobalScope(); } }"
    },
    "Codec-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x == 0) {",
                "patch_diff": "if (x == 0) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x = 2 : x; switch (x) {",
                "patch_diff": "if (x = 2 : x; switch (x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x.length == 2) {",
                "patch_diff": "if (x.length == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x == 0 && x == 6; switch (x) {",
                "patch_diff": "if (x == 0 && x == 6; switch (x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "} else if (x = x << 6; switch (x) {",
                "patch_diff": "} else if (x = x << 6; switch (x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x == 0 && x == 6;",
                "patch_diff": "if (x == 0 && x == 6;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x == 2) {",
                "patch_diff": "if (x == 2) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x.length == 0 && x == 6;",
                "patch_diff": "if (x.length == 0 && x == 6;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x.length == 1 && x == 6;",
                "patch_diff": "if (x.length == 1 && x == 6;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x == 0 && y == '='_INFINITY) {",
                "patch_diff": "if (x == 0 && y == '='_INFINITY) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (buffer == null || buffer.length - pos < decodeSize) { resizeBuffer(); }"
    },
    "Closure-28": {
        "fixes": [
            {
                "k": 1,
                "patch": "weded when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "weded when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "weded when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "we we when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "we we when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "we we when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "we we when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "we we when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "patch_diff": "we we when we're done when we're done when we're done when we're done when we're done when we're done when we're done.",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override void addConstant(String newcode) { add(\"0\"); }"
    },
    "Math-60": {
        "fixes": [
            {
                "k": 1,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - ex)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:37.018568566 +0200\n+++ /tmp/tmp5dnaoklu.java\t2022-07-12 17:35:37.074568285 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - ex)); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:40.046553447 +0200\n+++ /tmp/tmp5r7452c_.java\t2022-07-12 17:35:40.046553447 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum)) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:42.250542443 +0200\n+++ /tmp/tmppl0dxo8p.java\t2022-07-12 17:35:42.254542424 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * flagDeviation) / ex; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:44.366531878 +0200\n+++ /tmp/tmp54za2xnk.java\t2022-07-12 17:35:44.382531799 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * accum); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:46.398521733 +0200\n+++ /tmp/tmp0ielubdm.java\t2022-07-12 17:35:46.398521733 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x)) {\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - 20; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:48.514511168 +0200\n+++ /tmp/tmpgid89vrp.java\t2022-07-12 17:35:48.514511168 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * sum - 20; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:50.698500263 +0200\n+++ /tmp/tmp6z7egngv.java\t2022-07-12 17:35:50.698500263 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / n; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / ex; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:52.870489418 +0200\n+++ /tmp/tmp69nhe8da.java\t2022-07-12 17:35:52.870489418 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * x) / ex; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * ex)); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:55.062478475 +0200\n+++ /tmp/tmpdbpn0olc.java\t2022-07-12 17:35:55.078478393 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf((x - mean) / (standardDeviation * ex)); }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "try { return 0.5 * (x0 + Erf.erf) / (standardDeviation * accum; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-60/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\t2022-07-12 17:35:57.110468246 +0200\n+++ /tmp/tmpy026slot.java\t2022-07-12 17:35:57.110468246 +0200\n@@ -121,22 +121,11 @@\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n-        try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+try { return 0.5 * (x0 + Erf.erf) / (standardDeviation * accum; }\n     }\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "try { return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0)))); } catch (MaxIterationsExceededException ex) { if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38 return 0; } else if (x > (mean + 20 * standardDeviation)) { return 1; } else { throw ex; } }",
        "fixed_line": "if (FastMath.abs(dev) > 40 * standardDeviation) { return dev < 0 ? 0.0d : 1.0d; }"
    },
    "Codec-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:35:59.466456484 +0200\n+++ /tmp/tmpekem9tds.java\t2022-07-12 17:35:59.562456003 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:01.442446615 +0200\n+++ /tmp/tmp1qkks775.java\t2022-07-12 17:36:01.442446615 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:03.230437687 +0200\n+++ /tmp/tmpt8raznlk.java\t2022-07-12 17:36:03.230437687 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:04.910429299 +0200\n+++ /tmp/tmp6pnzqd5z.java\t2022-07-12 17:36:04.910429299 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:06.526421227 +0200\n+++ /tmp/tmp88hm9veu.java\t2022-07-12 17:36:06.526421227 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 27, 28, -1, -1, 0, 3, \"S as 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:08.330412221 +0200\n+++ /tmp/tmp6hg9990g.java\t2022-07-12 17:36:08.334412199 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:10.058403589 +0200\n+++ /tmp/tmpogu4dxx8.java\t2022-07-12 17:36:10.058403589 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:12.090393444 +0200\n+++ /tmp/tmphdwwn4ot.java\t2022-07-12 17:36:12.090393444 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:14.746380178 +0200\n+++ /tmp/tmp9mescm_n.java\t2022-07-12 17:36:14.746380178 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, }\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-16/src/main/java/org/apache/commons/codec/binary/Base32.java\t2022-07-12 17:36:17.278367533 +0200\n+++ /tmp/tmpul6wgung.java\t2022-07-12 17:36:17.278367533 +0200\n@@ -94,11 +94,11 @@\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 00-0f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 10-1f\n             -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, // 20-2f\n              0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1, // 30-3f 2-7\n             -1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, // 40-4f A-O\n-            25, 26, 27, 28, 29, 30, 31, 32,\n+25, 25, 5 -1, -1, -1, 0, 3, \"Base token of the 0, -1, -1, -1, -1);\n     };\n \n     /**\n      * This array is a lookup table that translates 5-bit positive integer index values into their\n      * \"Base32 Hex Alphabet\" equivalents as specified in Table 4 of RFC 4648.\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "25, 26, 27, 28, 29, 30, 31, 32,",
        "fixed_line": "25, 26, 27, 28, 29, 30, 31, // 50-57 P-V"
    },
    "JacksonDatabind-24": {
        "fixes": [
            {
                "k": 1,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:20.502351431 +0200\n+++ /tmp/tmpr711mz07.java\t2022-07-12 17:36:21.106348415 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:24.598330975 +0200\n+++ /tmp/tmpav76ovvc.java\t2022-07-12 17:36:24.598330975 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:27.694315512 +0200\n+++ /tmp/tmpnwaubaad.java\t2022-07-12 17:36:27.710315434 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:30.270302646 +0200\n+++ /tmp/tmpw3wd_tez.java\t2022-07-12 17:36:30.270302646 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:33.126288380 +0200\n+++ /tmp/tmpgyqbh8m8.java\t2022-07-12 17:36:33.130288361 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "TimeZone tz = (df == null)? _typeFactory : _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:36.138273336 +0200\n+++ /tmp/tmphuh3wu_3.java\t2022-07-12 17:36:36.138273336 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:38.082263628 +0200\n+++ /tmp/tmp9d9gb9vf.java\t2022-07-12 17:36:38.082263628 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (_annotationIntrospector == null)? _visibilityChecker : _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:40.746250319 +0200\n+++ /tmp/tmpbtlfvgoj.java\t2022-07-12 17:36:40.746250319 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _timeZone : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, _timeZone, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:42.826239930 +0200\n+++ /tmp/tmpmnwsc1ys.java\t2022-07-12 17:36:42.826239930 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-24/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\t2022-07-12 17:36:45.542226363 +0200\n+++ /tmp/tmph1x4kyyh.java\t2022-07-12 17:36:45.542226363 +0200\n@@ -229,14 +229,11 @@\n     \n     public BaseSettings withDateFormat(DateFormat df) {\n         if (_dateFormat == df) {\n             return this;\n         }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+TimeZone tz = (df == null)? _typeFactory : df.getTimeZone, _defaultBase64, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);\n     }\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {\n             return this;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "TimeZone tz = (df == null) ? _timeZone : df.getTimeZone(); return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory, _typeResolverBuilder, df, _handlerInstantiator, _locale, tz, _defaultBase64);",
        "fixed_line": "_timeZone, _defaultBase64);"
    },
    "JacksonCore-13": {
        "fixes": [
            {
                "k": 1,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.class, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.class, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_cfgUnqNames = newFeatureFeatureFlags, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeatureFlags, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.class_FIELD_NAMES, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.class_FIELD_NAMES, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_cfgUnqNames = newFeatureFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "patch_diff": "_cfgUnqNames = newFeatureFeatureFeature(newFeature.QUOTE_FIELD_NAMES, changedFeatures);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_cfgUnqNames = newFeatureFeature.class;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature.class;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES);",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.QUOTE_FIELD_NAMES);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_cfgUnqNames = newFeatureFeature(newFeature.class, changedFeatures;",
                "patch_diff": "_cfgUnqNames = newFeatureFeature(newFeature.class, changedFeatures;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "@Override public JsonGenerator disable(Feature f) { super.disable(f); if (f == Feature.QUOTE_FIELD_NAMES) { _cfgUnqNames = true; } return this; }"
    },
    "JacksonDatabind-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "||Specified.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:36:50.302202581 +0200\n+++ /tmp/tmp3xrz58_1.java\t2022-07-12 17:36:50.758200308 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Specified.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "|| getL.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:36:55.174178247 +0200\n+++ /tmp/tmpgh5zyhge.java\t2022-07-12 17:36:55.178178227 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| getL.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "||Is.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:36:57.950164380 +0200\n+++ /tmp/tmp4gbmm9s6.java\t2022-07-12 17:36:57.954164362 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Is.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "|| m.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:00.302152629 +0200\n+++ /tmp/tmp8ovalpp9.java\t2022-07-12 17:37:00.306152612 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| m.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:03.330137502 +0200\n+++ /tmp/tmpripf1ung.java\t2022-07-12 17:37:03.514136582 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| TreeNode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "|| serial.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:49.417907216 +0200\n+++ /tmp/tmplec07_lm.java\t2022-07-12 17:37:49.421907195 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| serial.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "||Conflict.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:51.377897420 +0200\n+++ /tmp/tmpxdc4rhrv.java\t2022-07-12 17:37:51.381897401 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+||Conflict.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "|| mocked.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:53.365887486 +0200\n+++ /tmp/tmph86yhs5i.java\t2022-07-12 17:37:53.369887466 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| mocked.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "|| getMode.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:55.285877891 +0200\n+++ /tmp/tmpatva05vi.java\t2022-07-12 17:37:55.285877891 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| getMode.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "|| function.class.isAssignableFrom(t.getRawClass()));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-17/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java\t2022-07-12 17:37:57.261868015 +0200\n+++ /tmp/tmp6uujk7mv.java\t2022-07-12 17:37:57.265867994 +0200\n@@ -175,11 +175,11 @@\n             case OBJECT_AND_NON_CONCRETE:\n //                return t.isJavaLangObject() || \n                 return (t.getRawClass() == Object.class)\n                         || (!t.isConcrete()\n                                 // [databind#88] Should not apply to JSON tree models:\n-                        || TreeNode.class.isAssignableFrom(t.getRawClass()));\n+|| function.class.isAssignableFrom(t.getRawClass()));\n \n             case NON_FINAL:\n                 while (t.isArrayType()) {\n                     t = t.getContentType();\n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "|| TreeNode.class.isAssignableFrom(t.getRawClass()));",
        "fixed_line": "&& !TreeNode.class.isAssignableFrom(t.getRawClass()));"
    },
    "JacksonCore-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216;",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-407] -- allow disabling wrapping for now",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-407] -- allow disabling wrapping for now",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216;",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "patch_diff": "_names = Arrays.copyOf(_names, tatu: As per [JACKSON-407] -- allow disabling wrapping for",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "_names = Arrays.copyOf(_hashShared, as need to ensure",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, as need to ensure",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "_hashShared = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216;",
                "patch_diff": "_hashShared = Arrays.copyOf(_names, tatu: As per [JACKSON-core#216;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216, _hashShared);",
                "patch_diff": "_names = Arrays.copyOf(_hashShared, tatu: As per [JACKSON-core#216, _hashShared);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "_verifyNeedForRehash();"
    },
    "Time-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cLenient.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:01.341847626 +0200\n+++ /tmp/tmp9mgry2y9.java\t2022-07-12 17:38:01.393847363 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cLenient.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:04.797830351 +0200\n+++ /tmp/tmpy16u2kys.java\t2022-07-12 17:38:04.797830351 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:07.841815137 +0200\n+++ /tmp/tmp41f7cai9.java\t2022-07-12 17:38:07.841815137 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(0, 0); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:19.357757577 +0200\n+++ /tmp/tmp8t7qef17.java\t2022-07-12 17:38:19.373757498 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(0, 0); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:22.229743223 +0200\n+++ /tmp/tmpk37y01_8.java\t2022-07-12 17:38:22.229743223 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.setTimeBoolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:24.861730066 +0200\n+++ /tmp/tmpsiw202bc.java\t2022-07-12 17:38:24.865730047 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.setTimeBoolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set):Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:27.421717270 +0200\n+++ /tmp/tmpvef393t6.java\t2022-07-12 17:38:27.421717270 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set):Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:29.945704653 +0200\n+++ /tmp/tmp55jxh560.java\t2022-07-12 17:38:29.945704653 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(cVerbose.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set; }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:32.781690476 +0200\n+++ /tmp/tmp7e15o01o.java\t2022-07-12 17:38:32.781690476 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set; }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set;Boolean.FALSE); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Time-11/src/main/java/org/joda/time/tz/ZoneInfoCompiler.java\t2022-07-12 17:38:35.269678041 +0200\n+++ /tmp/tmpr5q__qwe.java\t2022-07-12 17:38:35.269678041 +0200\n@@ -63,14 +63,11 @@\n public class ZoneInfoCompiler {\n     static DateTimeOfYear cStartOfYear;\n \n     static Chronology cLenientISO;\n \n-    static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>();\n-    static {\n-        cVerbose.set(Boolean.FALSE);\n-    }\n+static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set;Boolean.FALSE); }\n \n     /**\n      * Gets a flag indicating that verbose logging is required.\n      * @return true to log verbosely\n      */\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>(); static { cVerbose.set(Boolean.FALSE); }",
        "fixed_line": "static ThreadLocal<Boolean> cVerbose = new ThreadLocal<Boolean>() { protected Boolean initialValue() { return Boolean.FALSE; } };"
    },
    "JacksonDatabind-89": {
        "fixes": [
            {
                "k": 1,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JDK.add(\"com/#1737];",
                "patch_diff": "JDK.add(\"com/#1737];",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FILE_NAMES; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FILE_NAMES; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int k = 0; i < MAX_DESERIALIZERS; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int k = 0; i < MAX_DESERIALIZERS; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < n; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < n; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES.length; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_FIELD_NAMES.length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; ++i) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < nGroups; i++) {",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < nGroups; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS;",
                "patch_diff": "// [JACKSON-407] -- allow disabling wrapping for (int i = 0; i < MAX_DESERIALIZERS;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "s.add(\"java.util.logging.FileHandler\"); s.add(\"java.rmi.server.UnicastRemoteObject\"); // [databind#1737]; 3rd party s.add(\"org.springframework.aop.support.AbstractBeanFactoryPointcutAdvisor\"); s.add(\"org.springframework.beans.factory.config.PropertyPathFactoryBean\"); s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\"); s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");"
    },
    "Lang-16": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:38:39.689655946 +0200\n+++ /tmp/tmp4vr81ygc.java\t2022-07-12 17:38:39.721655785 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"getx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:38:50.681600994 +0200\n+++ /tmp/tmpoqpah5f5.java\t2022-07-12 17:38:50.681600994 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:00.469552058 +0200\n+++ /tmp/tmpwm0l8n58.java\t2022-07-12 17:39:00.469552058 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:10.261503101 +0200\n+++ /tmp/tmpt8g3xyqm.java\t2022-07-12 17:39:10.261503101 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-5x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:19.997454421 +0200\n+++ /tmp/tmp3x86dx57.java\t2022-07-12 17:39:19.997454421 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\">x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:29.741405698 +0200\n+++ /tmp/tmpvswn2t9m.java\t2022-07-12 17:39:29.741405698 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1]x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:39.697355913 +0200\n+++ /tmp/tmpamv29rpd.java\t2022-07-12 17:39:39.697355913 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"-1; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:41.229348251 +0200\n+++ /tmp/tmp9eob8ukd.java\t2022-07-12 17:39:41.229348251 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"-1; {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:42.773340531 +0200\n+++ /tmp/tmpnp85ojd_.java\t2022-07-12 17:39:42.773340531 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") || str.startsWith(\"Lexx\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-16/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\t2022-07-12 17:39:52.633291221 +0200\n+++ /tmp/tmpfrow1hu2.java\t2022-07-12 17:39:52.633291221 +0200\n@@ -453,11 +453,11 @@\n             // it accepts this as a legal value, but it does not appear \n             // to be in specification of class. OS X Java parses it to \n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+if (str.startsWith(\"0x\") && str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);\n         String mant;\n         String dec;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
        "fixed_line": "if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {"
    },
    "Closure-67": {
        "fixes": [
            {
                "k": 1,
                "patch": ") {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:40:02.649241132 +0200\n+++ /tmp/tmps6ahnjav.java\t2022-07-12 17:40:02.673241010 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": ") { // a assign assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:40:38.069063970 +0200\n+++ /tmp/tmphmvnyg0v.java\t2022-07-12 17:40:38.069063970 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (n = assign; n!= assign) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:41:11.116898648 +0200\n+++ /tmp/tmpg9sdhwro.java\t2022-07-12 17:41:11.116898648 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+for (n = assign; n!= assign) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "for (n = assign; n.hasPrototype) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:41:13.548886480 +0200\n+++ /tmp/tmpwn2l4f8q.java\t2022-07-12 17:41:13.548886480 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+for (n = assign; n.hasPrototype) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": ") { // a assign assign; can't really modify it was non-literal characters that might be null or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:41:16.104873692 +0200\n+++ /tmp/tmp52dl6jj1.java\t2022-07-12 17:41:16.120873612 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-literal characters that might be null or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": ") { // a assign assign; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:41:49.368707260 +0200\n+++ /tmp/tmpg1034ssm.java\t2022-07-12 17:41:49.368707260 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": ") { // a assign assign; can't really modify it was non-empty's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:42:22.608540928 +0200\n+++ /tmp/tmp2deh_zcn.java\t2022-07-12 17:42:22.608540928 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it was non-empty's do implicit re-parse\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (; n!= assign) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:42:56.088373372 +0200\n+++ /tmp/tmp9w12riql.java\t2022-07-12 17:42:56.088373372 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+for (; n!= assign) {\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": ") { // a assign assign; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:42:58.728360158 +0200\n+++ /tmp/tmp3mew7qu0.java\t2022-07-12 17:42:58.744360079 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's do implicit re-initialized or EMPTY\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": ") { // a assign assign; can't really modify it's a assign assign; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-67/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\t2022-07-12 17:43:32.416191540 +0200\n+++ /tmp/tmpd6euf5kq.java\t2022-07-12 17:43:32.416191540 +0200\n@@ -313,11 +313,11 @@\n \n     private boolean isPrototypePropertyAssign(Node assign) {\n       Node n = assign.getFirstChild();\n       if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n           && n.getType() == Token.GETPROP\n-          ) {\n+) { // a assign assign; can't really modify it's a assign assign; can't find\n         // We want to exclude the assignment itself from the usage list\n         boolean isChainedProperty =\n             n.getFirstChild().getType() == Token.GETPROP;\n \n         if (isChainedProperty) {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": ") {",
        "fixed_line": "&& assign.getParent().getType() == Token.EXPR_RESULT) {"
    },
    "Jsoup-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "return clean;",
                "patch_diff": "return clean;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return clean.notNull(dirtyDocument;",
                "patch_diff": "return clean.notNull(dirtyDocument;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return clean.notNull(dirtyDocument);",
                "patch_diff": "return clean.notNull(dirtyDocument);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return clean = Document.notNull(dirtyDocument;",
                "patch_diff": "return clean = Document.notNull(dirtyDocument;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return clean.notNull;",
                "patch_diff": "return clean.notNull;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return clean.notNull(dirtyDocument.body(), clean;",
                "patch_diff": "return clean.notNull(dirtyDocument.body(), clean;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return clean = Document.notNull;",
                "patch_diff": "return clean = Document.notNull;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return clean = Document.length;",
                "patch_diff": "return clean = Document.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return clean.notNull(dirtyDocument.baseUri());",
                "patch_diff": "return clean.notNull(dirtyDocument.baseUri());",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return clean.notNull(dirtyDocument.length;",
                "patch_diff": "return clean.notNull(dirtyDocument.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (dirtyDocument.body() != null) // frameset documents won't have a body. the clean doc will have empty body."
    },
    "Compress-1": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (this.closed) {",
                "patch_diff": "if (this.closed) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (this.closed!= null) {",
                "patch_diff": "if (this.closed!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (this.closed = false; }",
                "patch_diff": "if (this.closed = false; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (this.closed!= t.close) {",
                "patch_diff": "if (this.closed!= t.close) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (this.closed!= this.start) {",
                "patch_diff": "if (this.closed!= this.start) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (this.closed!= flag) {",
                "patch_diff": "if (this.closed!= flag) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (this.closed!= this.close) {",
                "patch_diff": "if (this.closed!= this.close) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (this.closed = false;",
                "patch_diff": "if (this.closed = false;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (this.closed || this.close) {",
                "patch_diff": "if (this.closed || this.close) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (this.closed!= this.closed) {",
                "patch_diff": "if (this.closed!= this.closed) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "this.finish();"
    },
    "Jsoup-5": {
        "fixes": [
            {
                "k": 1,
                "patch": "tq.consume; // value is to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:09.380006502 +0200\n+++ /tmp/tmpgvw_w4jt.java\t2022-07-12 17:44:09.404006382 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to check\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "tq.consume; // value is tick",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:11.151997631 +0200\n+++ /tmp/tmp_twr4swk.java\t2022-07-12 17:44:11.183997471 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is tick\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "tq.consume; // value is to do value",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:12.707989840 +0200\n+++ /tmp/tmp_nuhx5gy.java\t2022-07-12 17:44:12.711989822 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to do value\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "tq.consume; // value is lower case",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:14.279981970 +0200\n+++ /tmp/tmp_ryi626p.java\t2022-07-12 17:44:14.279981970 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is lower case\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "tq.consume; // value is tick last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:15.819974260 +0200\n+++ /tmp/tmpfjh16n38.java\t2022-07-12 17:44:15.819974260 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is tick last\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "tq.consume; // value is to do this",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:17.291966891 +0200\n+++ /tmp/tmp3mwxnuiw.java\t2022-07-12 17:44:17.295966873 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is to do this\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "tq.consume; // value is last",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:18.839959141 +0200\n+++ /tmp/tmp_4lp13ec.java\t2022-07-12 17:44:18.839959141 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // value is last\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "tq.consume(); // value is to check",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:20.383951411 +0200\n+++ /tmp/tmplqgyyvfy.java\t2022-07-12 17:44:20.383951411 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume(); // value is to check\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "tq.consume; // root is this class value",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:23.263936993 +0200\n+++ /tmp/tmpbq1d3trx.java\t2022-07-12 17:44:23.263936993 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume; // root is this class value\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "tq.consume;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-5/src/main/java/org/jsoup/parser/Parser.java\t2022-07-12 17:44:24.799929303 +0200\n+++ /tmp/tmpsjy_rf6f.java\t2022-07-12 17:44:24.799929303 +0200\n@@ -201,11 +201,11 @@\n             tq.consumeWhitespace();\n         }\n         if (key.length() != 0)\n             return Attribute.createFromEncoded(key, value);\n         else {\n-            tq.consume();\n+tq.consume;\n                 \n             return null;\n         }\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "tq.consume();",
        "fixed_line": "if (value.length() == 0) // no key, no val; unknown char, keep popping so not get stuck tq.advance();"
    },
    "Closure-128": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index >= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:26.471920932 +0200\n+++ /tmp/tmp391x9aei.java\t2022-07-12 17:44:26.503920772 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return index > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:31.951893497 +0200\n+++ /tmp/tmpmhn98hvk.java\t2022-07-12 17:44:31.951893497 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index >= 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:35.591875274 +0200\n+++ /tmp/tmpg_x4s3jm.java\t2022-07-12 17:44:35.591875274 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index >= 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return index > 0 && s.charAt(0)!= '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:39.219857109 +0200\n+++ /tmp/tmp_s2xipoi.java\t2022-07-12 17:44:39.219857109 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index > 0 && s.charAt(0)!= '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return s >= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:42.883838764 +0200\n+++ /tmp/tmpazlq2e3v.java\t2022-07-12 17:44:42.883838764 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s >= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return s!= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:46.719819560 +0200\n+++ /tmp/tmpdoeirymy.java\t2022-07-12 17:44:46.719819560 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s!= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return s > 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:50.687799691 +0200\n+++ /tmp/tmpv01n17fj.java\t2022-07-12 17:44:50.687799691 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return s > 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return < 0 || s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:54.611780045 +0200\n+++ /tmp/tmpyql_orpn.java\t2022-07-12 17:44:54.615780026 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return < 0 || s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index!= 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:44:58.171762220 +0200\n+++ /tmp/tmptat6qa22.java\t2022-07-12 17:44:58.171762220 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index!= 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return index < 0 && s.charAt(0) == '0';",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-128/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:45:01.979743154 +0200\n+++ /tmp/tmpviy_4hub.java\t2022-07-12 17:45:01.983743134 +0200\n@@ -786,11 +786,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+return index < 0 && s.charAt(0) == '0';\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0 && s.charAt(0) != '0';",
        "fixed_line": "if (len == 0) { return false; } for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } return len == 1 || s.charAt(0) != '0';"
    },
    "Math-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return dim * FastMath.PI, -dim / 2 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:05.815723944 +0200\n+++ /tmp/tmp0jngcnuz.java\t2022-07-12 17:45:05.887723586 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return dim * FastMath.PI, - mean / 2) * sign;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:09.343706282 +0200\n+++ /tmp/tmp3ottzp_a.java\t2022-07-12 17:45:09.343706282 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * sign;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return dim * FastMath.PI, - mean / 2) * 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:11.507695447 +0200\n+++ /tmp/tmpexeda5c0.java\t2022-07-12 17:45:11.507695447 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * 0;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return dim * FastMath.PI, -1, -1 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:13.567685134 +0200\n+++ /tmp/tmp_69gxeij.java\t2022-07-12 17:45:13.567685134 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -1, -1 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return dim * FastMath.PI, -dim / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:15.703674437 +0200\n+++ /tmp/tmpuib_b1ye.java\t2022-07-12 17:45:15.703674437 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return dim * FastMath.PI, - mean / 2) * 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:17.727664303 +0200\n+++ /tmp/tmpz6f9no_n.java\t2022-07-12 17:45:17.727664303 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) * 1;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return dim * FastMath.PI, -dim / 2) * sign;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:19.831653767 +0200\n+++ /tmp/tmp7ztmux6o.java\t2022-07-12 17:45:19.831653767 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) * sign;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return dim * FastMath.PI, - mean / 2) *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:22.007642871 +0200\n+++ /tmp/tmpgy5c1d1d.java\t2022-07-12 17:45:22.007642871 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2) *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return dim * FastMath.PI, - mean / 2, 11 *",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:24.027632756 +0200\n+++ /tmp/tmppbs4m16k.java\t2022-07-12 17:45:24.031632737 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, - mean / 2, 11 *\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return dim * FastMath.PI, -dim / 2) * 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-11/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\t2022-07-12 17:45:26.163622063 +0200\n+++ /tmp/tmpw_k5fa4a.java\t2022-07-12 17:45:26.163622063 +0200\n@@ -178,11 +178,11 @@\n         final int dim = getDimension();\n         if (vals.length != dim) {\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+return dim * FastMath.PI, -dim / 2) * 0;\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
        "fixed_line": "return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *"
    },
    "Codec-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "return new String(bytes, Charsets.ISO_ Point_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:28.607609820 +0200\n+++ /tmp/tmpnijcl8sp.java\t2022-07-12 17:45:28.667609523 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ Point_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return new String(bytes, Charsets.ISO_8859_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:30.967598008 +0200\n+++ /tmp/tmp_800ihog.java\t2022-07-12 17:45:30.967598008 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new String(bytes, Charsets.ISO_TO_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:32.531590175 +0200\n+++ /tmp/tmp071494ok.java\t2022-07-12 17:45:32.531590175 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_TO_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new String(bytes, Charsets.ISO_\u2ca3_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:34.203581802 +0200\n+++ /tmp/tmpazep5jh3.java\t2022-07-12 17:45:34.203581802 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_\u2ca3_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new String(bytes, Charsets.ISO_8859_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:35.851573550 +0200\n+++ /tmp/tmp61l_bhyu.java\t2022-07-12 17:45:35.851573550 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new String(bytes, Charsets.ISO_ when_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:42.111542205 +0200\n+++ /tmp/tmpbq48ruh4.java\t2022-07-12 17:45:42.115542183 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ when_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return new String(bytes, Charsets.ISO_ es_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:43.795533772 +0200\n+++ /tmp/tmp767iaez6.java\t2022-07-12 17:45:43.795533772 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_ es_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return new String(bytes, Charsets.ISO_URLs_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:45.323526119 +0200\n+++ /tmp/tmph_e4yv5g.java\t2022-07-12 17:45:45.323526119 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_URLs_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new String(bytes, Charsets.ISO_\u2ca3_1);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:46.847518487 +0200\n+++ /tmp/tmpg3cke_yw.java\t2022-07-12 17:45:46.847518487 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String(bytes, Charsets.ISO_\u2ca3_1);\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new String[] {0, Charsets.ISO_8859_1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-17/src/main/java/org/apache/commons/codec/binary/StringUtils.java\t2022-07-12 17:45:48.655509434 +0200\n+++ /tmp/tmpfuu003um.java\t2022-07-12 17:45:48.655509434 +0200\n@@ -334,11 +334,11 @@\n      *             Thrown if {@link Charsets#ISO_8859_1} is not initialized, which should never happen since it is\n      *             required by the Java platform specification.\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+return new String[] {0, Charsets.ISO_8859_1;\n     }\n \n     /**\n      * Constructs a new <code>String</code> by decoding the specified array of bytes using the US-ASCII charset.\n      *\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return new String(bytes, Charsets.ISO_8859_1);",
        "fixed_line": "return newString(bytes, Charsets.ISO_8859_1);"
    },
    "Lang-59": {
        "fixes": [
            {
                "k": 1,
                "patch": "str.getChars(0, strLen, buffer, size;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:45:50.451500442 +0200\n+++ /tmp/tmpg4bv5l0r.java\t2022-07-12 17:45:50.535500022 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "str.getChars(0, strLen, buffer, size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:45:52.483490264 +0200\n+++ /tmp/tmpl2tm3e4c.java\t2022-07-12 17:45:52.487490245 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "str.getChars(0, strLen, buffer, size = padLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:02.619439508 +0200\n+++ /tmp/tmpn2uwn1kx.java\t2022-07-12 17:46:02.619439508 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size = padLen;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "str.getChars(0, strLen, buffer, size + width);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:04.207431554 +0200\n+++ /tmp/tmprbwd0c1t.java\t2022-07-12 17:46:04.211431534 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size + width);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "str.getChars(0, strLen, buffer, size) - width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:13.519384923 +0200\n+++ /tmp/tmpduyka64o.java\t2022-07-12 17:46:13.519384923 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size) - width;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "str.getChars(0, strLen, buffer, size - width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:15.071377149 +0200\n+++ /tmp/tmp64d7je51.java\t2022-07-12 17:46:15.071377149 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size - width;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "str.getChars(0, strLen, buffer, size size);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:16.635369319 +0200\n+++ /tmp/tmphnq44oj3.java\t2022-07-12 17:46:16.635369319 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "str.getChars(0, strLen, buffer, size size;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:18.131361825 +0200\n+++ /tmp/tmpvu4ii6zw.java\t2022-07-12 17:46:18.131361825 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size size;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "str.getChars(0, strLen, buffer, size) + width;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:19.659354172 +0200\n+++ /tmp/tmpj6il_x4f.java\t2022-07-12 17:46:19.663354152 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size) + width;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "str.getChars(0, strLen, buffer, size) + padLen;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-59/src/java/org/apache/commons/lang/text/StrBuilder.java\t2022-07-12 17:46:21.263346140 +0200\n+++ /tmp/tmp0p5h30o9.java\t2022-07-12 17:46:21.263346140 +0200\n@@ -879,11 +879,11 @@\n         if (width > 0) {\n             ensureCapacity(size + width);\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+str.getChars(0, strLen, buffer, size) + padLen;\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);\n                 for (int i = 0; i < padLen; i++) {\n                     buffer[size + strLen + i] = padChar;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "str.getChars(0, strLen, buffer, size);",
        "fixed_line": "str.getChars(0, width, buffer, size);"
    },
    "Closure-52": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index % 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:22.875338067 +0200\n+++ /tmp/tmpm5fszerl.java\t2022-07-12 17:46:22.899337948 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index % 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return index < 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:28.311310842 +0200\n+++ /tmp/tmpjq7dmjlb.java\t2022-07-12 17:46:28.311310842 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index < 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return index > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:32.123291752 +0200\n+++ /tmp/tmpie_gs0qg.java\t2022-07-12 17:46:32.123291752 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return index!= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:35.927272703 +0200\n+++ /tmp/tmpfq1qijvp.java\t2022-07-12 17:46:35.927272703 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index!= 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return index >= 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:39.511254752 +0200\n+++ /tmp/tmph641yetf.java\t2022-07-12 17:46:39.511254752 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index >= 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return len > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:46:43.195236301 +0200\n+++ /tmp/tmp445sl15h.java\t2022-07-12 17:46:43.195236301 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return len > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:47:22.711038387 +0200\n+++ /tmp/tmp5zawwv2d.java\t2022-07-12 17:47:22.711038387 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return index + 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:47:26.443019696 +0200\n+++ /tmp/tmpss1vzdpm.java\t2022-07-12 17:47:26.443019696 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index + 1;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index + 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:47:30.311000320 +0200\n+++ /tmp/tmpb7bqyflm.java\t2022-07-12 17:47:30.311000320 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return index + 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return c > 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-52/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 17:47:34.086981409 +0200\n+++ /tmp/tmp7t5e4_gj.java\t2022-07-12 17:47:34.086981409 +0200\n@@ -740,11 +740,11 @@\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0;\n+return c > 0;\n   }\n \n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return len > 0;",
        "fixed_line": "return len > 0 && s.charAt(0) != '0';"
    },
    "Csv-3": {
        "fixes": [
            {
                "k": 1,
                "patch": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar;",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (int c = 0; i < length; i++) {",
                "patch_diff": "for (int c = 0; i < length; i++) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar() * length;",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar() * length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar() {",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar() {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "default: throw new IOException(\"EOF whilst processing escape sequence\");",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape sequence\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar()",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar()",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (int c = 0; i < length; ++i) {",
                "patch_diff": "for (int c = 0; i < length; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "int length = 0; // let's do implicit re-characters char - available from in.getLastChar;",
                "patch_diff": "int length = 0; // let's do implicit re-characters char - available from in.getLastChar;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar()\");",
                "patch_diff": "default: throw new IOException(\"EOF whilst processing escape in.getLastChar() - available from in.getLastChar()\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "int length = 0;",
                "patch_diff": "int length = 0;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (isDelimiter(c) || isEscape(c) || isQuoteChar(c) || isCommentStart(c)) { return c; } // indicate unexpected char - available from in.getLastChar() return END_OF_STREAM;"
    },
    "Closure-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "result = lvalInt >>>MediancestorBlock;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:47:39.790952837 +0200\n+++ /tmp/tmpvxpd_qew.java\t2022-07-12 17:47:39.854952515 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorBlock;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "result = lvalInt >>> rvalInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:47:42.170940917 +0200\n+++ /tmp/tmp8awd6zl5.java\t2022-07-12 17:47:42.174940895 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "result = lvalInt >>> 16;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:05.238825367 +0200\n+++ /tmp/tmpfb41kimn.java\t2022-07-12 17:48:05.238825367 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 16;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "result = valInt >>> rvalInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:26.574718492 +0200\n+++ /tmp/tmpdfndxftz.java\t2022-07-12 17:48:26.574718492 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = valInt >>> rvalInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "result = this.tokenToName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:28.526708714 +0200\n+++ /tmp/tmpn8882a9s.java\t2022-07-12 17:48:28.530708691 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = this.tokenToName;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "result = lvalInt >>> 15;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:30.346699595 +0200\n+++ /tmp/tmp_oi9owk2.java\t2022-07-12 17:48:30.346699595 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 15;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "result = lvalInt >>>Mediancestor;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:51.830591972 +0200\n+++ /tmp/tmpjfhchy4h.java\t2022-07-12 17:48:51.830591972 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>Mediancestor;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "result = lvalInt >>> 12;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:48:53.850581855 +0200\n+++ /tmp/tmpe0jgih8n.java\t2022-07-12 17:48:53.854581832 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>> 12;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "result = lvalInt >>>MediancestorBlock.tokenToName;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:49:15.374474024 +0200\n+++ /tmp/tmprrudv3sa.java\t2022-07-12 17:49:15.374474024 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorBlock.tokenToName;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "result = lvalInt >>>MediancestorInt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-97/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\t2022-07-12 17:49:17.318464285 +0200\n+++ /tmp/tmpfpxo6n6m.java\t2022-07-12 17:49:17.318464285 +0200\n@@ -693,11 +693,11 @@\n           break;\n         case Token.URSH:\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+result = lvalInt >>>MediancestorInt;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n       }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "result = lvalInt >>> rvalInt;",
        "fixed_line": "long lvalLong = lvalInt & 0xffffffffL; result = lvalLong >>> rvalInt;"
    },
    "Closure-133": {
        "fixes": [
            {
                "k": 1,
                "patch": "return result; }",
                "patch_diff": "return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "String result = stream.getRemainingJSDocLine; }",
                "patch_diff": "String result = stream.getRemainingJSDocLine; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "// String result = stream.getRemainingJSDocLine; }",
                "patch_diff": "// String result = stream.getRemainingJSDocLine; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// String result = stream.getRemainingJSDocLine(); }",
                "patch_diff": "// String result = stream.getRemainingJSDocLine(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// String String result = stream.getRemainingJSDocLine; }",
                "patch_diff": "// String String result = stream.getRemainingJSDocLine; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return result = stream.getRemainingJSDocLine; }",
                "patch_diff": "return result = stream.getRemainingJSDocLine; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "String result = stream.getRemainingJSDocLine(); }",
                "patch_diff": "String result = stream.getRemainingJSDocLine(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "// String String result = stream.getRemainingJSDocLine(); }",
                "patch_diff": "// String String result = stream.getRemainingJSDocLine(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "// String result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "// String result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "String result = stream.getRemainingJSDocLine(); return result; }",
                "patch_diff": "String result = stream.getRemainingJSDocLine(); return result; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "unreadToken = NO_UNREAD_TOKEN;"
    },
    "Cli-12": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (arg.hasOption_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:21.042445628 +0200\n+++ /tmp/tmpqoxe96ur.java\t2022-07-12 17:49:21.074445470 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption_OBJECT_ARRAY;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (arg.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:22.826436691 +0200\n+++ /tmp/tmpxymzbv2z.java\t2022-07-12 17:49:22.830436671 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (options.hasOption(arg.substring(0, 2))) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:24.250429560 +0200\n+++ /tmp/tmpgel3z3j3.java\t2022-07-12 17:49:24.250429560 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption(arg.substring(0, 2))) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (options.hasOption_OBJECT_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:25.774421922 +0200\n+++ /tmp/tmpc7nkboah.java\t2022-07-12 17:49:25.778421904 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption_OBJECT_ARRAY;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (arg.hasOption_OVERRIDE) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:27.246414548 +0200\n+++ /tmp/tmplkk9n1zg.java\t2022-07-12 17:49:27.250414530 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption_OVERRIDE) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (options.hasOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:28.682407353 +0200\n+++ /tmp/tmp2p7jnk6d.java\t2022-07-12 17:49:28.682407353 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (options.hasOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:30.138400059 +0200\n+++ /tmp/tmpwy8_i_8_.java\t2022-07-12 17:49:30.138400059 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (options.hasOption) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (arg.hasOption;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:31.626392607 +0200\n+++ /tmp/tmpqvzk0xz8.java\t2022-07-12 17:49:31.626392607 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption;\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (arg.hasOption(arg.substring(0, 2];",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:33.042385509 +0200\n+++ /tmp/tmpj9imzmu1.java\t2022-07-12 17:49:33.042385509 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption(arg.substring(0, 2];\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (arg.hasOption) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Cli-12/src/java/org/apache/commons/cli/GnuParser.java\t2022-07-12 17:49:34.618377617 +0200\n+++ /tmp/tmpetowno38.java\t2022-07-12 17:49:34.618377617 +0200\n@@ -76,11 +76,11 @@\n                 {\n                     tokens.add(arg);\n                 }\n                 else\n                 {\n-                    if (options.hasOption(arg.substring(0, 2)))\n+if (arg.hasOption) {\n                     {\n                         // the format is --foo=value or -foo=value\n                         // the format is a special properties option (-Dproperty=value)\n                         tokens.add(arg.substring(0, 2)); // -D\n                         tokens.add(arg.substring(2)); // property=value\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (options.hasOption(arg.substring(0, 2)))",
        "fixed_line": "if (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('=')))) { // the format is --foo=value or -foo=value tokens.add(arg.substring(0, arg.indexOf('='))); // --foo tokens.add(arg.substring(arg.indexOf('=') + 1)); // value } else if (options.hasOption(arg.substring(0, 2))) {"
    },
    "Mockito-11": {
        "fixes": [
            {
                "k": 1,
                "patch": "return Token.ASSIGN_PROTOTYPE_NON_OBJECT;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:49:36.354368917 +0200\n+++ /tmp/tmpf6h3f1nf.java\t2022-07-12 17:49:36.398368698 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_NON_OBJECT;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:49:51.846291302 +0200\n+++ /tmp/tmpvjygcli3.java\t2022-07-12 17:49:51.846291302 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DELEGATE;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:01.610242383 +0200\n+++ /tmp/tmpya2e2338.java\t2022-07-12 17:50:01.610242383 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DELEGATE;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBERS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:11.170194486 +0200\n+++ /tmp/tmpdqxoi6ct.java\t2022-07-12 17:50:11.174194468 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBERS;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return Token.ASSIGN_PROTOTYPE_ANNOTATION;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:20.994145265 +0200\n+++ /tmp/tmprpdpqye_.java\t2022-07-12 17:50:20.994145265 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_ANNOTATION;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return Token.ASSIGN_PROTOTYPE_WITH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:30.794096164 +0200\n+++ /tmp/tmpqk3j383v.java\t2022-07-12 17:50:30.794096164 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_WITH;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DEPRECATED;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:40.690046583 +0200\n+++ /tmp/tmphr7r1tzw.java\t2022-07-12 17:50:40.690046583 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DEPRECATED;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return Token.ASSIGN_PROTOTYPE_INTERFACES;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:50:50.581997017 +0200\n+++ /tmp/tmp_if42p1_.java\t2022-07-12 17:50:50.581997017 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_INTERFACES;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return Token.ASSIGN_PROTOTYPE_EMPTY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:51:00.481947413 +0200\n+++ /tmp/tmpi6hzekjc.java\t2022-07-12 17:51:00.481947413 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_EMPTY;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return Token.ASSIGN_PROTOTYPE_MEMBER_DELTA;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-11/src/org/mockito/internal/creation/DelegatingMethod.java\t2022-07-12 17:51:10.377897828 +0200\n+++ /tmp/tmpmb_yvdny.java\t2022-07-12 17:51:10.381897808 +0200\n@@ -55,8 +55,8 @@\n             return method.equals(o);\n     }\n \n     @Override\n     public int hashCode() {\n-        return 1;\n+return Token.ASSIGN_PROTOTYPE_MEMBER_DELTA;\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return 1;",
        "fixed_line": "if (this == o) { return true; } if (o instanceof DelegatingMethod) { DelegatingMethod that = (DelegatingMethod) o; return method.equals(that.method); } else { return method.equals(o); } } @Override public int hashCode() { return method.hashCode();"
    },
    "Jsoup-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (tq.chompTo(\"</\" + tagName.chompTo(\">\");",
                "patch_diff": "if (tq.chompTo(\"</\" + tagName.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (tq.chompTo(\"</\" + tagName;",
                "patch_diff": "if (tq.chompTo(\"</\" + tagName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (chompTo(\"</\" + tagName;",
                "patch_diff": "if (chompTo(\"</\" + tagName;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (chompTo(\"</\" + tagName.chompTo(\">\");",
                "patch_diff": "if (chompTo(\"</\" + tagName.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (chompTo(\"</\" + tagName) && tag.equals(textareaTag)) {",
                "patch_diff": "if (chompTo(\"</\" + tagName) && tag.equals(textareaTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (tag.isAssignableFrom(data, baseUri) && tag.chompTo(\">\");",
                "patch_diff": "if (tag.isAssignableFrom(data, baseUri) && tag.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (tq.chompTo(\"</\" + tagName);",
                "patch_diff": "if (tq.chompTo(\"</\" + tagName);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (gramps.isAssignableFrom(data, baseUri) && tag.chompTo(\">\");",
                "patch_diff": "if (gramps.isAssignableFrom(data, baseUri) && tag.chompTo(\">\");",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (tag.isAssignableFrom(data, baseUri) && tag.equals(textareaTag)) {",
                "patch_diff": "if (tag.isAssignableFrom(data, baseUri) && tag.equals(textareaTag)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (tq.chompTo(\"</\" + tagName)) {",
                "patch_diff": "if (tq.chompTo(\"</\" + tagName)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "popStackToClose(tag);"
    },
    "Mockito-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:22.325837959 +0200\n+++ /tmp/tmpoarl2vxe.java\t2022-07-12 17:51:22.409837541 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:25.277823169 +0200\n+++ /tmp/tmp7158_sel.java\t2022-07-12 17:51:25.281823149 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:27.285813108 +0200\n+++ /tmp/tmpf6vt7zm5.java\t2022-07-12 17:51:27.285813108 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:29.133803847 +0200\n+++ /tmp/tmpbwqoj8wa.java\t2022-07-12 17:51:29.133803847 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:30.977794607 +0200\n+++ /tmp/tmpudbibun2.java\t2022-07-12 17:51:30.977794607 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:32.937784786 +0200\n+++ /tmp/tmp3osnh1fv.java\t2022-07-12 17:51:32.941784767 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:34.941774745 +0200\n+++ /tmp/tmp8cr9gbbr.java\t2022-07-12 17:51:34.941774745 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:36.765765605 +0200\n+++ /tmp/tmpvrhmorcl.java\t2022-07-12 17:51:36.765765605 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS;\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:38.641756204 +0200\n+++ /tmp/tmpilisomng.java\t2022-07-12 17:51:38.641756204 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-27/src/org/mockito/internal/util/MockUtil.java\t2022-07-12 17:51:40.609746344 +0200\n+++ /tmp/tmpp3e0wyb0.java\t2022-07-12 17:51:40.609746344 +0200\n@@ -59,12 +59,11 @@\n         return mock;\n     }\n \n     public <T> void resetMock(T mock) {\n         MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+MockHandler<T> newMockHandler = new MockHandler<T>(mockingInterceptorFilter.mockito.Mockito; newMockHandler.mockito.Mockito.Mockito.MockitoURNS_DEFAULTS));\n         ((Factory) mock).setCallback(0, newFilter);\n     }\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
        "fixed_line": "MethodInterceptorFilter newFilter = newMethodInterceptorFilter(oldMockHandler.getMockSettings());"
    },
    "Closure-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (x < 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:51:42.693735898 +0200\n+++ /tmp/tmpphucx2c5.java\t2022-07-12 17:51:42.793735397 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (x < 0 || current == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:52:26.585515958 +0200\n+++ /tmp/tmpxl622l4t.java\t2022-07-12 17:52:26.585515958 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || current == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (x < 0 || prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:52:30.197497859 +0200\n+++ /tmp/tmpb2dlv9vh.java\t2022-07-12 17:52:30.197497859 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (x < 0 || val == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:53:08.445306187 +0200\n+++ /tmp/tmp2iw0baz1.java\t2022-07-12 17:53:08.445306187 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || val == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (x < 0 || child == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:53:12.161287565 +0200\n+++ /tmp/tmptpg3lqys.java\t2022-07-12 17:53:12.165287546 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || child == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (x < 0 || x == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:53:15.705269804 +0200\n+++ /tmp/tmpc9ch2w2f.java\t2022-07-12 17:53:15.705269804 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || x == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (x < 0 && val == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:53:53.869078545 +0200\n+++ /tmp/tmpsmzm06qx.java\t2022-07-12 17:53:53.869078545 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && val == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (x < 0 && val > '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:53:57.305061327 +0200\n+++ /tmp/tmppoc22es5.java\t2022-07-12 17:53:57.305061327 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 && val > '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (x < 0 || value == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:54:00.809043764 +0200\n+++ /tmp/tmpwha1a__a.java\t2022-07-12 17:54:00.809043764 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x < 0 || value == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (x >= 0 && prev == '-') {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-38/src/com/google/javascript/jscomp/CodeConsumer.java\t2022-07-12 17:54:04.453025901 +0200\n+++ /tmp/tmpclr08ym1.java\t2022-07-12 17:54:04.453025901 +0200\n@@ -240,11 +240,11 @@\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n-    if (x < 0 && prev == '-') {\n+if (x >= 0 && prev == '-') {\n       add(\" \");\n     }\n \n     if ((long) x == x && !negativeZero) {\n       long value = (long) x;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (x < 0 && prev == '-') {",
        "fixed_line": "if ((x < 0 || negativeZero) && prev == '-') {"
    },
    "Math-17": {
        "fixes": [
            {
                "k": 1,
                "patch": "this.fpFast(x, y) {",
                "patch_diff": "this.fpFast(x, y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.fpFast(x) {",
                "patch_diff": "this.fpFast(x) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "this.fpEnabled(x, y) {",
                "patch_diff": "this.fpEnabled(x, y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "this.fp5)(x, y) {",
                "patch_diff": "this.fp5)(x, y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.fpFast(x, y).5) {",
                "patch_diff": "this.fpFast(x, y).5) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "this.fpFast(x) { return x; }",
                "patch_diff": "this.fpFast(x) { return x; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.fpFast(x, y) { return x; }",
                "patch_diff": "this.fpFast(x, y) { return x; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.fpFast(x, y) { return b; }",
                "patch_diff": "this.fpFast(x, y) { return b; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.fpFast(x, y;",
                "patch_diff": "this.fpFast(x, y;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.fpFast(x), y) {",
                "patch_diff": "this.fpFast(x), y) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (x >= 0 && x < RADIX) { return multiplyFast(x); } else { return multiply(newInstance(x)); }"
    },
    "Mockito-37": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (answer instanceof DoesNothing) {",
                "patch_diff": "if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] answer = this.onlyVoidMethods;",
                "patch_diff": "private static final /*day*/int[] answer = this.onlyVoidMethods;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static static final /*day*/int[] answer = this.onlyVoidMethods;",
                "patch_diff": "private static static final /*day*/int[] answer = this.onlyVoidMethods;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] EASTER = this.onlyVoidMethods;",
                "patch_diff": "private static final /*day*/int[] EASTER = this.onlyVoidMethods;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[][] items = this.onlyVoidMethods;",
                "patch_diff": "private static final /*day*/int[][] items = this.onlyVoidMethods;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static final /*day*/int[] answer,Nothing) answer,",
                "patch_diff": "private static final /*day*/int[] answer,Nothing) answer,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] answer = this.onlyVoidMethods.isVoidMethods;",
                "patch_diff": "private static final /*day*/int[] answer = this.onlyVoidMethods.isVoidMethods;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] answer = this.onlyVoidMethods.isVoidMethods(answer,",
                "patch_diff": "private static final /*day*/int[] answer = this.onlyVoidMethods.isVoidMethods(answer,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static,Nothing) {",
                "patch_diff": "private static,Nothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /* declared if (answer instanceof DoesNothing) {",
                "patch_diff": "private static final /* declared if (answer instanceof DoesNothing) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (answer instanceof CallsRealMethods) { validateMockingConcreteClass((CallsRealMethods) answer, invocation); } } private void validateMockingConcreteClass(CallsRealMethods answer, Invocation invocation) { if (invocation.getMethod().getDeclaringClass().isInterface()) { reporter.cannotCallRealMethodOnInterface(); } }"
    },
    "Closure-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:54:46.980843077 +0200\n+++ /tmp/tmp4o2ero4p.java\t2022-07-12 17:54:47.044842802 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:54:52.976817124 +0200\n+++ /tmp/tmpcwp5zo6o.java\t2022-07-12 17:54:52.976817124 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:54:56.884800185 +0200\n+++ /tmp/tmptpmv6509.java\t2022-07-12 17:54:56.888800167 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:00.664783785 +0200\n+++ /tmp/tmpma813ve7.java\t2022-07-12 17:55:00.664783785 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNodeUtil.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:42.676600423 +0200\n+++ /tmp/tmp7cb4m5qe.java\t2022-07-12 17:55:42.676600423 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNodeUtil.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:46.340584341 +0200\n+++ /tmp/tmpc_5mdnpz.java\t2022-07-12 17:55:46.340584341 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:49.844568947 +0200\n+++ /tmp/tmpem9cfzay.java\t2022-07-12 17:55:49.844568947 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode = finallyNode.UNCOND;\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:53.252553962 +0200\n+++ /tmp/tmpecw0oaw1.java\t2022-07-12 17:55:53.256553944 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:55:56.700538790 +0200\n+++ /tmp/tmp50rw1lws.java\t2022-07-12 17:55:56.704538773 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode.UNCOND, finallyNode = finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode.UNCOND, finallyNode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-14/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\t2022-07-12 17:56:00.264523093 +0200\n+++ /tmp/tmp7tn1ts_b.java\t2022-07-12 17:56:00.264523093 +0200\n@@ -762,11 +762,11 @@\n           }\n         // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, finallyNode, finallyNode.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);",
        "fixed_line": "cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);"
    },
    "Lang-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "pos += Character.charCount(pt, pt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:04.084506254 +0200\n+++ /tmp/tmp2ytr17va.java\t2022-07-12 17:56:04.108506148 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "pos += Character.charCount(pt, ptIndex + 1) : 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:05.748498914 +0200\n+++ /tmp/tmplb137r_z.java\t2022-07-12 17:56:05.748498914 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptIndex + 1) : 0;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "pos += Character.charCount(pt, ptIndex);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:07.280492154 +0200\n+++ /tmp/tmprikwp2wa.java\t2022-07-12 17:56:07.280492154 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptIndex);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "pos += Character.charCount(pt, pt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:08.880485093 +0200\n+++ /tmp/tmpvc7_scf6.java\t2022-07-12 17:56:08.880485093 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "pos += Character.charCount(pt, pt + 1));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:10.528477815 +0200\n+++ /tmp/tmpoi3fda4l.java\t2022-07-12 17:56:10.528477815 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt + 1));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "pos += Character.charCount(pt, ptName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:12.092470908 +0200\n+++ /tmp/tmpq0x8o_ja.java\t2022-07-12 17:56:12.096470890 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, ptName);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "pos += Character.charCount(pt, pt));",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:13.716463732 +0200\n+++ /tmp/tmpcdjeezd_.java\t2022-07-12 17:56:13.716463732 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt));\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "pos += Character.charCount(pt, pos);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:15.332456588 +0200\n+++ /tmp/tmp2jm028e1.java\t2022-07-12 17:56:15.332456588 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pos);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "pos += Character.charCount(pt, pt + 1) : 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:16.936449495 +0200\n+++ /tmp/tmplrbjvm4j.java\t2022-07-12 17:56:16.936449495 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt + 1) : 0;\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "pos += Character.charCount(pt, pt pt);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Lang-6/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\t2022-07-12 17:56:18.428442896 +0200\n+++ /tmp/tmpbmt5s5u4.java\t2022-07-12 17:56:18.428442896 +0200\n@@ -90,11 +90,11 @@\n                 continue;\n             }\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+pos += Character.charCount(pt, pt pt);\n             }\n         }\n     }\n \n     /**\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "pos += Character.charCount(Character.codePointAt(input, pos));",
        "fixed_line": "pos += Character.charCount(Character.codePointAt(input, pt));"
    },
    "Lang-64": {
        "fixes": [
            {
                "k": 1,
                "patch": "return iValue - other) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "return iValue - other) * DateTimeConstants.MILLIS_PER_HOUR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_HOUR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return iValue - other.length;",
                "patch_diff": "return iValue - other.length;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return iValue - other) * DateTimeConstants.MILLIS_PER_DAY;",
                "patch_diff": "return iValue - other) * DateTimeConstants.MILLIS_PER_DAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_DAY;",
                "patch_diff": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_DAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return iValue - other.iValue;",
                "patch_diff": "return iValue - other.iValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_WEEK;",
                "patch_diff": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_WEEK;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return iValue - other) * DateTimeConstants.MILLIS_PER_WEEK;",
                "patch_diff": "return iValue - other) * DateTimeConstants.MILLIS_PER_WEEK;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_MINUTE;",
                "patch_diff": "return iValue - (iValue - other) * DateTimeConstants.MILLIS_PER_MINUTE;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return iValue - other.get(iValue - 1);",
                "patch_diff": "return iValue - other.get(iValue - 1);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (other == this) { return 0; } if (other.getClass() != this.getClass()) { if (other.getClass().getName().equals(this.getClass().getName())) { return iValue - getValueInOtherClassLoader(other); } throw new ClassCastException( \"Different enum class '\" + ClassUtils.getShortClassName(other.getClass()) + \"'\"); } return iValue - ((ValuedEnum) other).iValue; } /** * <p>Use reflection to return an objects value.</p> * * @param other the object to determine the value for * @return the value */ private int getValueInOtherClassLoader(Object other) { try { Method mth = other.getClass().getMethod(\"getValue\", null); Integer value = (Integer) mth.invoke(other, null); return value.intValue(); } catch (NoSuchMethodException e) { // ignore - should never happen } catch (IllegalAccessException e) { // ignore - should never happen } catch (InvocationTargetException e) { // ignore - should never happen } throw new IllegalStateException(\"This should not happen\"); }"
    },
    "Closure-107": {
        "fixes": [
            {
                "k": 1,
                "patch": "return options.messageBundle;",
                "patch_diff": "return options.messageBundle;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return options.messageBundle = new Empty EmptyD mode;",
                "patch_diff": "return options.messageBundle = new Empty EmptyD mode;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (options.messageBundle) {",
                "patch_diff": "} else if (options.messageBundle) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return options.messageBundle = new Empty Empty;",
                "patch_diff": "return options.messageBundle = new Empty Empty;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return options.messageBundle = new Empty EmptyD mode,",
                "patch_diff": "return options.messageBundle = new Empty EmptyD mode,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return options.messageBundle = new Runtime;",
                "patch_diff": "return options.messageBundle = new Runtime;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return options.messageBundle = new EmptyContext;",
                "patch_diff": "return options.messageBundle = new EmptyContext;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return options.messageBundle = new Empty;",
                "patch_diff": "return options.messageBundle = new Empty;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return options.messageBundle = new Empty*s;",
                "patch_diff": "return options.messageBundle = new Empty*s;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (options.messageBundle) {",
                "patch_diff": "if (options.messageBundle) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "options.setWarningLevel(JsMessageVisitor.MSG_CONVENTIONS, CheckLevel.OFF);"
    },
    "Lang-49": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (gcd == gcd) { return this; }",
                "patch_diff": "if (gcd == gcd) { return this; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "this.gcd = gcd;",
                "patch_diff": "this.gcd = gcd;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (gcd == gcd) {",
                "patch_diff": "if (gcd == gcd) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (gcd == 1) {",
                "patch_diff": "if (gcd == 1) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "this.gcd = gcd; }",
                "patch_diff": "this.gcd = gcd; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (gcd == gcd) { return this.numerator / gcd; }",
                "patch_diff": "if (gcd == gcd) { return this.numerator / gcd; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "this.gcd = gcd.abs(numerator / gcd) * DateTimeConstants.MILLIS_PER_HOUR;",
                "patch_diff": "this.gcd = gcd.abs(numerator / gcd) * DateTimeConstants.MILLIS_PER_HOUR;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "this.gcd = gcd.abs(numerator / gcd) * DateTimeConstants.MILLIS_PER_DAY;",
                "patch_diff": "this.gcd = gcd.abs(numerator / gcd) * DateTimeConstants.MILLIS_PER_DAY;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "this.gcd = gcd - (numerator * gcd) / gcd;",
                "patch_diff": "this.gcd = gcd - (numerator * gcd) / gcd;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "this.gcd = gcd - denominator / gcd;",
                "patch_diff": "this.gcd = gcd - denominator / gcd;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (numerator == 0) { return equals(ZERO) ? this : ZERO; }"
    },
    "Chart-4": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (a instanceof XYAnnotationBounds) {",
                "patch_diff": "if (a instanceof XYAnnotationBounds) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (c == DatasetUtilities.class) {",
                "patch_diff": "if (c == DatasetUtilities.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "} else if (a instanceof XYAnnotationBounds) {",
                "patch_diff": "} else if (a instanceof XYAnnotationBounds) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "} else if (c == DatasetUtilities.class) {",
                "patch_diff": "} else if (c == DatasetUtilities.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "// if (a instanceof XYAnnotationBounds) {",
                "patch_diff": "// if (a instanceof XYAnnotationBounds) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (a instanceof XYAnnotationBoundsInfo) {",
                "patch_diff": "if (a instanceof XYAnnotationBoundsInfo) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i.hasNext()) {",
                "patch_diff": "if (i.hasNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "}",
                "patch_diff": "}",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (a instanceof XYAnnotationBounds(c)) {",
                "patch_diff": "if (a instanceof XYAnnotationBounds(c)) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (c == DatasetUtilities.hasNext()) {",
                "patch_diff": "if (c == DatasetUtilities.hasNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (r != null) { Collection c = r.getAnnotations(); Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } }"
    },
    "Closure-118": {
        "fixes": [
            {
                "k": 1,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) {",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "for (Node child = n; child!= null; child = child.getNext()) {",
                "patch_diff": "for (Node child = n; child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "for (Node child = n.getString(); child!= null; child = child.getNext()) {",
                "patch_diff": "for (Node child = n.getString(); child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "// // for (; child!= null; child = child.getNext()) {",
                "patch_diff": "// // for (; child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "for (Node child = n.getType; child!= null; child = child.getNext()) {",
                "patch_diff": "for (Node child = n.getType; child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "for (; child!= null; child = child.getNext()) {",
                "patch_diff": "for (; child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "for (; child!= null; child = child.getFirstChild(); child!= null; child = child.getNext()) {",
                "patch_diff": "for (; child!= null; child = child.getFirstChild(); child!= null; child = child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getParent()) {",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getParent()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { //",
                "patch_diff": "for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { //",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "for (; child!= null; child = child.getFirstChild(); child.getNext()) {",
                "patch_diff": "for (; child!= null; child = child.getFirstChild(); child.getNext()) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (child.isQuotedString()) { continue; }"
    },
    "Closure-70": {
        "fixes": [
            {
                "k": 1,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:28.588397897 +0200\n+++ /tmp/tmpatmmujab.java\t2022-07-12 17:56:28.656397586 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:32.032382618 +0200\n+++ /tmp/tmp9thp7hw5.java\t2022-07-12 17:56:32.032382618 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:34.600371218 +0200\n+++ /tmp/tmpbdf439b7.java\t2022-07-12 17:56:34.600371218 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:37.104360097 +0200\n+++ /tmp/tmpgnyi5n_g.java\t2022-07-12 17:56:37.104360097 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter, jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:39.552349220 +0200\n+++ /tmp/tmpp_3txz3h.java\t2022-07-12 17:56:39.552349220 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter: jsDocParameter, jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "jsDocParameter.getJSType(), true);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:56:42.064338051 +0200\n+++ /tmp/tmp7t7h4lz_.java\t2022-07-12 17:56:42.068338033 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:57:17.948177874 +0200\n+++ /tmp/tmptawmynux.java\t2022-07-12 17:57:17.948177874 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter, jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:57:20.524166331 +0200\n+++ /tmp/tmpj4rqul70.java\t2022-07-12 17:57:20.528166313 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter: jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "jsDocParameter.getJSType(), false; // jsDocParameter.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:57:23.084154853 +0200\n+++ /tmp/tmpppfidupj.java\t2022-07-12 17:57:23.084154853 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), false; // jsDocParameter.\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "jsDocParameter.getJSType(), true; // jsDocParameter)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-70/src/com/google/javascript/jscomp/TypedScopeCreator.java\t2022-07-12 17:57:25.716143048 +0200\n+++ /tmp/tmpwwxj07wn.java\t2022-07-12 17:57:25.716143048 +0200\n@@ -1740,11 +1740,11 @@\n         if (jsDocParameters != null) {\n           Node jsDocParameter = jsDocParameters.getFirstChild();\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+jsDocParameter.getJSType(), true; // jsDocParameter)\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);\n             }\n           }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "jsDocParameter.getJSType(), true);",
        "fixed_line": "jsDocParameter.getJSType(), false);"
    },
    "Codec-10": {
        "fixes": [
            {
                "k": 1,
                "patch": "txt = txt.replaceAll(\"millis\", txt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:28.444130800 +0200\n+++ /tmp/tmpozt803q9.java\t2022-07-12 17:57:28.480130642 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt;\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:30.416121950 +0200\n+++ /tmp/tmpsskctbja.java\t2022-07-12 17:57:30.420121933 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 of",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:31.928115159 +0200\n+++ /tmp/tmpajja8qeo.java\t2022-07-12 17:57:31.932115141 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 of\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 1s",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:33.440108366 +0200\n+++ /tmp/tmpzgvdg0w0.java\t2022-07-12 17:57:33.444108349 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6 1s\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "txt = txt.replaceAll(\"millis\", txt()[0]);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:34.996101372 +0200\n+++ /tmp/tmpt7_3lj_o.java\t2022-07-12 17:57:34.996101372 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt()[0]);\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:36.676093821 +0200\n+++ /tmp/tmprb6phqmd.java\t2022-07-12 17:57:36.676093821 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis;\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 of",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:38.224086858 +0200\n+++ /tmp/tmpphay2rnu.java\t2022-07-12 17:57:38.224086858 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6 of\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6-millis",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:39.784079842 +0200\n+++ /tmp/tmpv2joysgx.java\t2022-07-12 17:57:39.784079842 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // 1.0 only has 6-millis\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "txt = txt.replaceAll(\"millis\", txt; // to indicate to 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:41.372072696 +0200\n+++ /tmp/tmp5vfmuchg.java\t2022-07-12 17:57:41.372072696 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt; // to indicate to 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Codec-10/src/java/org/apache/commons/codec/language/Caverphone.java\t2022-07-12 17:57:42.944065621 +0200\n+++ /tmp/tmpr6wj545z.java\t2022-07-12 17:57:42.944065621 +0200\n@@ -71,11 +71,11 @@\n         txt = txt.replaceAll(\"^enough\", \"enou2f\");  // 2.0 only\n         txt = txt.replaceAll(\"^trough\", \"trou2f\");  // 2.0 only - note the spec says ^enough here again, c+p error I assume\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+txt = txt.replaceAll(\"millis\", txt +millis; // 1.0 only has 6\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");\n         txt = txt.replaceAll(\"ci\", \"si\");\n         txt = txt.replaceAll(\"ce\", \"se\");\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "txt = txt.replaceAll(\"^mb\", \"m2\");",
        "fixed_line": "txt = txt.replaceAll(\"mb$\", \"m2\");"
    },
    "Jsoup-46": {
        "fixes": [
            {
                "k": 1,
                "patch": "accum.append(AND);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:44.552058382 +0200\n+++ /tmp/tmpcwluvqvi.java\t2022-07-12 17:57:44.568058310 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "accum.append(escapeMode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:46.512049554 +0200\n+++ /tmp/tmp6s8c3dwk.java\t2022-07-12 17:57:46.512049554 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(escapeMode;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "accum.append(AND;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:48.016042780 +0200\n+++ /tmp/tmpf5ctowlp.java\t2022-07-12 17:57:48.028042725 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "accum.append(versionMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:49.604035623 +0200\n+++ /tmp/tmpc5napsos.java\t2022-07-12 17:57:49.604035623 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(versionMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "accum.append(AND_CHAR;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:51.284028049 +0200\n+++ /tmp/tmpw5u0leyx.java\t2022-07-12 17:57:51.284028049 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(AND_CHAR;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "accum.append(escapeMode);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:52.800021213 +0200\n+++ /tmp/tmpp18v8k7n.java\t2022-07-12 17:57:52.800021213 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(escapeMode);\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "accum.append(path;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:56.740003439 +0200\n+++ /tmp/tmpcxgr7j6v.java\t2022-07-12 17:57:56.740003439 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(path;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "accum.append(tt;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:58.327996271 +0200\n+++ /tmp/tmpqcxs1nkt.java\t2022-07-12 17:57:58.327996271 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(tt;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "accum.append(versionMode;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:57:59.859989355 +0200\n+++ /tmp/tmp9j2i96an.java\t2022-07-12 17:57:59.859989355 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(versionMode;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "accum.append(enclosing;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-46/src/main/java/org/jsoup/nodes/Entities.java\t2022-07-12 17:58:01.467982093 +0200\n+++ /tmp/tmpxq1zzh_v.java\t2022-07-12 17:58:01.467982093 +0200\n@@ -113,11 +113,11 @@\n                         break;\n                     case 0xA0:\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+accum.append(enclosing;\n                         break;\n                     case '<':\n                         if (!inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "accum.append(c);",
        "fixed_line": "accum.append(\"&#xa0;\");"
    },
    "Mockito-38": {
        "fixes": [
            {
                "k": 1,
                "patch": "return StringDescription.toString(m + arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:03.195974287 +0200\n+++ /tmp/tmp5jz7s3w2.java\t2022-07-12 17:58:03.251974032 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m + arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return StringDescription.toString(m).equals(arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:06.291960294 +0200\n+++ /tmp/tmpdwf153__.java\t2022-07-12 17:58:06.291960294 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return StringDescription.toString(m).equals(arg == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:21.551891217 +0200\n+++ /tmp/tmp57sk90v1.java\t2022-07-12 17:58:21.551891217 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return StringDescription.toString(m).equals(argName);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:36.319824191 +0200\n+++ /tmp/tmpe6ctuoin.java\t2022-07-12 17:58:36.319824191 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(argName);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return StringDescription.toString(m).equals < arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:38.683813448 +0200\n+++ /tmp/tmpxdxanm7l.java\t2022-07-12 17:58:38.683813448 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals < arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return StringDescription.toString(m).equals(arg;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:40.443805444 +0200\n+++ /tmp/tmpfupqkdtv.java\t2022-07-12 17:58:40.443805444 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg;\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return StringDescription.toString(m).equals(arg);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:42.087797967 +0200\n+++ /tmp/tmpb1dh0qbq.java\t2022-07-12 17:58:42.087797967 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(arg);\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return StringDescription.toString(m).equals(argarg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:56.667731571 +0200\n+++ /tmp/tmpg93h2sx3.java\t2022-07-12 17:58:56.671731554 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals(argarg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return StringDescription.toString(m).equals());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:58:58.939721213 +0200\n+++ /tmp/tmpx2z7a3i5.java\t2022-07-12 17:58:58.939721213 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return StringDescription.toString(m).equals == arg.toString());",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-38/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\t2022-07-12 17:59:00.635713476 +0200\n+++ /tmp/tmpg24wbr03.java\t2022-07-12 17:59:00.635713476 +0200\n@@ -43,8 +43,8 @@\n             return false;\n         }\n     }\n \n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+return StringDescription.toString(m).equals == arg.toString());\n     }\n }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return StringDescription.toString(m).equals(arg.toString());",
        "fixed_line": "return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());"
    },
    "Math-82": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (MathUtils.compareTo(S, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:02.587704569 +0200\n+++ /tmp/tmpdunxo6rp.java\t2022-07-12 17:59:02.611704460 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(S, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (MathUtils.compareTo(current, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:04.963693723 +0200\n+++ /tmp/tmphlqzg_9m.java\t2022-07-12 17:59:04.963693723 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(current, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (MathUtils.compareTo(element, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:07.107683935 +0200\n+++ /tmp/tmppxpqra6i.java\t2022-07-12 17:59:07.107683935 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(element, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (MathUtils.compareTo(value, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:09.191674415 +0200\n+++ /tmp/tmp5t7stwme.java\t2022-07-12 17:59:09.191674415 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(value, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (MathUtils.compareTo(y, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:11.367664475 +0200\n+++ /tmp/tmpe_d1sru6.java\t2022-07-12 17:59:11.367664475 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(y, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (MathUtils.compareTo(y, 0, epsilon) <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:13.451654950 +0200\n+++ /tmp/tmpea60gw50.java\t2022-07-12 17:59:13.451654950 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(y, 0, epsilon) <= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (MathUtils.compareTo(loopIndex, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:15.523645476 +0200\n+++ /tmp/tmpypiz_412.java\t2022-07-12 17:59:15.523645476 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(loopIndex, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (MathUtils.compareTo(files, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:17.599635980 +0200\n+++ /tmp/tmp9kptxgme.java\t2022-07-12 17:59:17.599635980 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(files, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:19.647626610 +0200\n+++ /tmp/tmpoiv9hoyr.java\t2022-07-12 17:59:19.647626610 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": true
            },
            {
                "k": 10,
                "patch": "if (MathUtils.compareTo(S, 0, epsilon) <= 0) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-82/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\t2022-07-12 17:59:27.099592493 +0200\n+++ /tmp/tmpo0ihw28u.java\t2022-07-12 17:59:27.099592493 +0200\n@@ -77,11 +77,11 @@\n         double minRatio = Double.MAX_VALUE;\n         Integer minRatioPos = null;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(S, 0, epsilon) <= 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n                     minRatioPos = i; \n                 }\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
        "fixed_line": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) {"
    },
    "Math-97": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:30.003579190 +0200\n+++ /tmp/tmpi5162o7c.java\t2022-07-12 17:59:30.039579025 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (yMin >= min) && value <= max + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:32.519567656 +0200\n+++ /tmp/tmp7hdkapir.java\t2022-07-12 17:59:32.523567639 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (yMin >= min) && value <= max + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (min >= max) && value <= max + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:34.447558815 +0200\n+++ /tmp/tmpqg6j7t69.java\t2022-07-12 17:59:34.447558815 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && value <= max + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (min >= max) && value <= max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:36.399549865 +0200\n+++ /tmp/tmpfojqbqfg.java\t2022-07-12 17:59:36.403549844 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && value <= max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:38.399540689 +0200\n+++ /tmp/tmpyq_vaub1.java\t2022-07-12 17:59:38.399540689 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:40.399531509 +0200\n+++ /tmp/tmpayx2fxzd.java\t2022-07-12 17:59:40.399531509 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:42.407522293 +0200\n+++ /tmp/tmpr8ljaxe2.java\t2022-07-12 17:59:42.407522293 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:44.443512945 +0200\n+++ /tmp/tmpzd_d6sj7.java\t2022-07-12 17:59:44.443512945 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:46.471503628 +0200\n+++ /tmp/tmpd0fe3tcs.java\t2022-07-12 17:59:46.471503628 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-97/src/java/org/apache/commons/math/analysis/BrentSolver.java\t2022-07-12 17:59:48.471494440 +0200\n+++ /tmp/tmp5n2eu0wu.java\t2022-07-12 17:59:48.475494420 +0200\n@@ -133,18 +133,11 @@\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+if (min >= max) && is close to a zero + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); } else if (yMax + \"]\"); } else if (yMin + \"]\"); }\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (sign >= 0) { // check if either value is close to a zero // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } else {",
        "fixed_line": "if (sign > 0) { // check if either value is close to a zero if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); ret = min; } else if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); ret = max; } else { // neither value is close to zero and min and max do not bracket root. throw new IllegalArgumentException (\"Function values at endpoints do not have different signs.\" + \" Endpoints: [\" + min + \",\" + max + \"]\" + \" Values: [\" + yMin + \",\" + yMax + \"]\"); } } else if (sign < 0){ // solve using only the first endpoint as initial guess ret = solve(min, yMin, max, yMax, min, yMin); } else { // either min or max is a root if (yMin == 0.0) { ret = min; } else { ret = max; }"
    },
    "Math-67": {
        "fixes": [
            {
                "k": 1,
                "patch": "return value.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 17:59:50.567484807 +0200\n+++ /tmp/tmprkbiqp4o.java\t2022-07-12 17:59:50.595484678 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return value.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return optimizer.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 17:59:53.167472853 +0200\n+++ /tmp/tmpu7jqtgv9.java\t2022-07-12 17:59:53.171472836 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return optimizer.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return all.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 17:59:55.211463455 +0200\n+++ /tmp/tmphwaq03zf.java\t2022-07-12 17:59:55.211463455 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return all.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return MILLISECONDS.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 17:59:57.195454328 +0200\n+++ /tmp/tmp2lde_5rf.java\t2022-07-12 17:59:57.199454308 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return MILLISECONDS.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return data.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 17:59:59.255444849 +0200\n+++ /tmp/tmpjuuj_jx1.java\t2022-07-12 17:59:59.255444849 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return data.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "returnapply.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 18:00:01.283435514 +0200\n+++ /tmp/tmpmgmjq3rp.java\t2022-07-12 18:00:01.283435514 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+returnapply.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return root.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 18:00:03.343426030 +0200\n+++ /tmp/tmp09av81ow.java\t2022-07-12 18:00:03.343426030 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return root.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return namespaces.getFunctionValue(); }",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 18:00:05.355416764 +0200\n+++ /tmp/tmpyuzg8vkb.java\t2022-07-12 18:00:05.355416764 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return namespaces.getFunctionValue(); }\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return functionScope.getFunctionValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 18:00:07.343407606 +0200\n+++ /tmp/tmps650yvj_.java\t2022-07-12 18:00:07.343407606 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return functionScope.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return all.getFunctionValue();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-67/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\t2022-07-12 18:00:09.691396785 +0200\n+++ /tmp/tmpnunp6lvi.java\t2022-07-12 18:00:09.695396765 +0200\n@@ -87,16 +87,11 @@\n         setMaxEvaluations(Integer.MAX_VALUE);\n     }\n \n     /** {@inheritDoc} */\n     public double getFunctionValue() {\n-        return optimizer.getFunctionValue();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getResult() {\n-        return optimizer.getResult();\n+return all.getFunctionValue();\n     }\n \n     /** {@inheritDoc} */\n     public double getAbsoluteAccuracy() {\n         return optimizer.getAbsoluteAccuracy();\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return optimizer.getFunctionValue(); } /** {@inheritDoc} */ public double getResult() { return optimizer.getResult();",
        "fixed_line": "return optimaValues[0]; } /** {@inheritDoc} */ public double getResult() { return optima[0];"
    },
    "Closure-109": {
        "fixes": [
            {
                "k": 1,
                "patch": "return throwsTypeName; token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:12.027386016 +0200\n+++ /tmp/tmp1pi97oi4.java\t2022-07-12 18:00:12.087385739 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return throwsTypeName; token!= JsDocToken.LP;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:17.063362790 +0200\n+++ /tmp/tmp_ssdde3y.java\t2022-07-12 18:00:17.063362790 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) token;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:20.927344959 +0200\n+++ /tmp/tmpxuw1ortj.java\t2022-07-12 18:00:20.927344959 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) token;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return throwsTypeName; token!= JsDocToken.NULL;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:24.423328821 +0200\n+++ /tmp/tmphj2xn6bv.java\t2022-07-12 18:00:24.427328800 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.NULL;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:27.815313153 +0200\n+++ /tmp/tmpl02w8vwr.java\t2022-07-12 18:00:27.815313153 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return throwsTypeName; token!= JsDocToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:31.215297439 +0200\n+++ /tmp/tmp0fkgy2m4.java\t2022-07-12 18:00:31.215297439 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.END_ARRAY;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:34.819280779 +0200\n+++ /tmp/tmps4akz42c.java\t2022-07-12 18:00:34.819280779 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP) return throwsTypeName; token!= JsDocToken.LP;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:38.179265239 +0200\n+++ /tmp/tmpo8j7a9wy.java\t2022-07-12 18:00:38.183265218 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP && token!= JsDocToken.LP)\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return throwsTypeName; token!= JsDocToken.LP_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:41.815248413 +0200\n+++ /tmp/tmpsu4omi81.java\t2022-07-12 18:00:41.819248393 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.LP_ARRAY;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return throwsTypeName; token!= JsDocToken.STRING;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-109/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\t2022-07-12 18:00:45.395231838 +0200\n+++ /tmp/tmpfylmgeun.java\t2022-07-12 18:00:45.399231821 +0200\n@@ -1903,11 +1903,11 @@\n   /**\n    * ContextTypeExpression := BasicTypeExpression | '?'\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+return throwsTypeName; token!= JsDocToken.STRING;\n   }\n \n   /**\n    * BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName\n    *     | FunctionType | UnionType | RecordType | ArrayType\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return parseTypeName(token);",
        "fixed_line": "if (token == JsDocToken.QMARK) { return newNode(Token.QMARK); } else { return parseBasicTypeExpression(token); }"
    },
    "Math-30": {
        "fixes": [
            {
                "k": 1,
                "patch": "final int n1 = n2prod = n2 - n1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:00:49.083214757 +0200\n+++ /tmp/tmpwl3bc_kj.java\t2022-07-12 18:00:49.131214538 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 - n1;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "final int n1 = n2prod = n2 * U;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:00:52.259200042 +0200\n+++ /tmp/tmp8cn3qeez.java\t2022-07-12 18:00:52.259200042 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * U;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "final int n1 = n2prod = n2 - n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:00:54.351190343 +0200\n+++ /tmp/tmpbscqzsqa.java\t2022-07-12 18:00:54.351190343 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 - n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "final int n1 = n2prod = n2 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:00:56.411180794 +0200\n+++ /tmp/tmps9ovzo5i.java\t2022-07-12 18:00:56.411180794 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "final int n1 = n2prod = n2dy / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:00:58.411171517 +0200\n+++ /tmp/tmpwav63yff.java\t2022-07-12 18:00:58.411171517 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2dy / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "final int n1 = n2prod = n2 * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:01:00.487161889 +0200\n+++ /tmp/tmp35j863rm.java\t2022-07-12 18:01:00.487161889 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "final int n1 = n2prod = n1 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:01:02.623151978 +0200\n+++ /tmp/tmpp6o4h8rl.java\t2022-07-12 18:01:02.623151978 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n1 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "final int n1 = UminX * n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:01:04.723142229 +0200\n+++ /tmp/tmpq9gvblxt.java\t2022-07-12 18:01:04.723142229 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = UminX * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "final int n1 = n2prod = n2 * UminX;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:01:06.803132576 +0200\n+++ /tmp/tmpexy_vgxd.java\t2022-07-12 18:01:06.803132576 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n1 = n2prod = n2 * UminX;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "final int n2prod = n1 / n2;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-30/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\t2022-07-12 18:01:08.851123064 +0200\n+++ /tmp/tmpjqaoj_1n.java\t2022-07-12 18:01:08.851123064 +0200\n@@ -168,11 +168,11 @@\n     private double calculateAsymptoticPValue(final double Umin,\n                                              final int n1,\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+final int n2prod = n1 / n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;\n         final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "final int n1n2prod = n1 * n2;",
        "fixed_line": "final double n1n2prod = n1 * n2;"
    },
    "Gson-6": {
        "fixes": [
            {
                "k": 1,
                "patch": "throw new IllegalArgumentException(\"Parameter typeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Parameter typeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "throw new IllegalArgumentException( \"Parameter typeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException( \"Parameter typeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "throw new IllegalArgumentException(TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "TypeAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "patch_diff": "TypeAdapter value must be TypeAdapter or TypeAdapterFactory reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "throw new IllegalArgumentException(typeAdapter.class; }",
                "patch_diff": "throw new IllegalArgumentException(typeAdapter.class; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "throw new IllegalArgumentException(TypeAdapter.class; }",
                "patch_diff": "throw new IllegalArgumentException(TypeAdapter.class; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or Type Collections reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or Type Collections reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "throw new IllegalArgumentException(typeAdapter.class); }",
                "patch_diff": "throw new IllegalArgumentException(typeAdapter.class); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or Typecover reference.\"); }",
                "patch_diff": "throw new IllegalArgumentException(\"Parameter value must be TypeAdapter or Typecover reference.\"); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (typeAdapter != null) { typeAdapter = typeAdapter.nullSafe(); }"
    },
    "Csv-2": {
        "fixes": [
            {
                "k": 1,
                "patch": "return index!= null? values[index] : null; }",
                "patch_diff": "return index!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return record.get(index == null? values[index] : null; }",
                "patch_diff": "return record.get(index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return record.get(index == null? values[index.intValue()] : null;",
                "patch_diff": "return record.get(index == null? values[index.intValue()] : null;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return index!= null? values[index.intValue()] : null; }",
                "patch_diff": "return index!= null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return record.get(index == null? values[index.intValue()] : null; }",
                "patch_diff": "return record.get(index == null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return record.get(name!= null? values[index] : null; }",
                "patch_diff": "return record.get(name!= null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return record.value(index == null? values[index] : null; }",
                "patch_diff": "return record.value(index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return index == null? values[index.intValue()] : null; }",
                "patch_diff": "return index == null? values[index.intValue()] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return index == record.class? values[index] : null; }",
                "patch_diff": "return index == record.class? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return index == null? values[index] : null; }",
                "patch_diff": "return index == null? values[index] : null; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "try { return index != null ? values[index.intValue()] : null; } catch (ArrayIndexOutOfBoundsException e) { throw new IllegalArgumentException( String.format( \"Index for header '%s' is %d but CSVRecord only has %d values!\", name, index.intValue(), values.length)); }"
    },
    "Gson-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "return contextRawType, supertype;",
                "patch_diff": "return contextRawType, supertype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return contextRawType; supertype = contextRawType,",
                "patch_diff": "return contextRawType; supertype = contextRawType,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return new Type getSupertype(context, contextRawType, supertype;",
                "patch_diff": "return new Type getSupertype(context, contextRawType, supertype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return contextRawType.isAssignableFrom(context, type, contextRawType);",
                "patch_diff": "return contextRawType.isAssignableFrom(context, type, contextRawType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return contextRawType.isAssignableFrom(context, typeRawType, supertype;",
                "patch_diff": "return contextRawType.isAssignableFrom(context, typeRawType, supertype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return contextRawType.isAssignableFrom(context, contextRawType,",
                "patch_diff": "return contextRawType.isAssignableFrom(context, contextRawType,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return contextRawType.isAssignableFrom(context, typeRawType, contextRawType);",
                "patch_diff": "return contextRawType.isAssignableFrom(context, typeRawType, contextRawType);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static Type getSupertype(context, contextRawType, supertype;",
                "patch_diff": "private static Type getSupertype(context, contextRawType, supertype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new Type getSupertype(context, contextRawType, supertype);",
                "patch_diff": "return new Type getSupertype(context, contextRawType, supertype);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Type getSupertype(context, contextRawType, supertype;",
                "patch_diff": "Type getSupertype(context, contextRawType, supertype;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (context instanceof WildcardType) { // wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead context = ((WildcardType)context).getUpperBounds()[0]; }"
    },
    "JxPath-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "double v = context.doubleValue(v;",
                "patch_diff": "double v = context.doubleValue(v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "double v = context.doubleValue(v) {",
                "patch_diff": "double v = context.doubleValue(v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "double v = context.doubleValue();",
                "patch_diff": "double v = context.doubleValue();",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "double v = InfoSetUtil.doubleValue(v;",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "double v = context;",
                "patch_diff": "double v = context;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "double v = context.getArg1().computeValue(",
                "patch_diff": "double v = context.getArg1().computeValue(",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "double v = context.getArg1().computeValue(v;",
                "patch_diff": "double v = context.getArg1().computeValue(v;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "double v = this.roundValue;",
                "patch_diff": "double v = this.roundValue;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "double v = InfoSetUtil.doubleValue(v) {",
                "patch_diff": "double v = InfoSetUtil.doubleValue(v) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "double v = context.doubleValue(v);",
                "patch_diff": "double v = context.doubleValue(v);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.floor(v)); } protected Object functionCeiling(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); } return new Double(Math.ceil(v)); } protected Object functionRound(EvalContext context) { assertArgCount(1); double v = InfoSetUtil.doubleValue(getArg1().computeValue(context)); if (Double.isNaN(v) || Double.isInfinite(v)) { return new Double(v); }"
    },
    "Mockito-26": {
        "fixes": [
            {
                "k": 1,
                "patch": "primitiveValues.put(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:01:17.735081786 +0200\n+++ /tmp/tmpeqidz6_0.java\t2022-07-12 18:01:17.771081616 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "primitiveValues.put12(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:01:22.307060523 +0200\n+++ /tmp/tmpteb1kd8d.java\t2022-07-12 18:01:22.307060523 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "primitiveValues.put(double.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:01:24.711049341 +0200\n+++ /tmp/tmpi9sxolsz.java\t2022-07-12 18:01:24.711049341 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "primitiveValues.putdouble(double.class,state.class);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:01:58.810890368 +0200\n+++ /tmp/tmp9vyq04k3.java\t2022-07-12 18:01:58.814890347 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.putdouble(double.class,state.class);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "primitiveValues.put12(double.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:01.266878895 +0200\n+++ /tmp/tmpx2ifvu00.java\t2022-07-12 18:02:01.266878895 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "primitiveValues.put(double.class, varValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:03.810867005 +0200\n+++ /tmp/tmpldktzjp1.java\t2022-07-12 18:02:03.810867005 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class, varValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "primitiveValues.put(double.class,stateValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:06.342855172 +0200\n+++ /tmp/tmpfcnndh9a.java\t2022-07-12 18:02:06.342855172 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class,stateValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "primitiveValues.put12(double.class, varValues);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:08.810843634 +0200\n+++ /tmp/tmpqhfb5dhr.java\t2022-07-12 18:02:08.810843634 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put12(double.class, varValues);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "primitiveValues.put(double.class,state.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:11.170832597 +0200\n+++ /tmp/tmp21hx2dbg.java\t2022-07-12 18:02:11.170832597 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.put(double.class,state.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "primitiveValues.putdouble(double.class, 0);",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Mockito-26/src/org/mockito/internal/util/Primitives.java\t2022-07-12 18:02:13.490821743 +0200\n+++ /tmp/tmpt67v8mt_.java\t2022-07-12 18:02:13.494821727 +0200\n@@ -61,8 +61,8 @@\n         primitiveValues.put(byte.class, (byte) 0);\n         primitiveValues.put(short.class, (short) 0);\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+primitiveValues.putdouble(double.class, 0);\n     }\n }\n\\ No newline at end of file\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "primitiveValues.put(double.class, 0);",
        "fixed_line": "primitiveValues.put(double.class, 0D);"
    },
    "JacksonDatabind-71": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:02:16.306808570 +0200\n+++ /tmp/tmpudatg_px.java\t2022-07-12 18:02:16.358808326 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:02:57.982613125 +0200\n+++ /tmp/tmpoppmwfpv.java\t2022-07-12 18:02:57.998613047 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:03:35.066438549 +0200\n+++ /tmp/tmpbz3ssfd8.java\t2022-07-12 18:03:35.086438454 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:03:36.830430231 +0200\n+++ /tmp/tmpad7wtpa7.java\t2022-07-12 18:03:36.830430231 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class; {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:04:13.962254818 +0200\n+++ /tmp/tmps452jyj6.java\t2022-07-12 18:04:13.978254742 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:04:51.458077140 +0200\n+++ /tmp/tmp2s6hiufe.java\t2022-07-12 18:04:51.474077066 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:05:28.833899523 +0200\n+++ /tmp/tmp0thzzl09.java\t2022-07-12 18:05:28.849899448 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class) {\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:06:06.029722290 +0200\n+++ /tmp/tmphn7hwix4.java\t2022-07-12 18:06:06.041722233 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class || raw.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:06:07.821713741 +0200\n+++ /tmp/tmpux3rdgfk.java\t2022-07-12 18:06:07.821713741 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-71/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java\t2022-07-12 18:06:45.049535899 +0200\n+++ /tmp/tmp7kmv42ae.java\t2022-07-12 18:06:45.065535823 +0200\n@@ -70,11 +70,11 @@\n     public static StdKeyDeserializer forType(Class<?> raw)\n     {\n         int kind;\n \n         // first common types:\n-        if (raw == String.class || raw == Object.class) {\n+if (raw == String.class || raw == Object.class) { // as per [JACKSON-407] --raw (raw == Object.class) { // as per [JACKSON-407] -- allow disabling wrapping for Object.class\n             return StringKD.forType(raw);\n         } else if (raw == UUID.class) {\n             kind = TYPE_UUID;\n         } else if (raw == Integer.class) {\n             kind = TYPE_INT;\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (raw == String.class || raw == Object.class) {",
        "fixed_line": "if (raw == String.class || raw == Object.class || raw == CharSequence.class) {"
    },
    "Closure-123": {
        "fixes": [
            {
                "k": 1,
                "patch": "Context rhsContext = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:07:22.493356618 +0200\n+++ /tmp/tmppz_72xah.java\t2022-07-12 18:07:22.521356484 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Context.OTHER = Context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:08:17.073094618 +0200\n+++ /tmp/tmp12g_8po_.java\t2022-07-12 18:08:17.077094599 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "Context rhsContext = p.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:08:20.701077176 +0200\n+++ /tmp/tmptz4j8q9p.java\t2022-07-12 18:08:20.705077156 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = p.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "Context.OTHER = context;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:08:24.269060019 +0200\n+++ /tmp/tmp7wrci5mb.java\t2022-07-12 18:08:24.269060019 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = context;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "Context.OTHER = p.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:08:27.829042897 +0200\n+++ /tmp/tmpxrjohz0q.java\t2022-07-12 18:08:27.829042897 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = p.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "Context rhsContext = Context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:08:31.529025101 +0200\n+++ /tmp/tmpsz4f6hoz.java\t2022-07-12 18:08:31.533025082 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = Context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Context.OTHER = 1;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:09:21.520784320 +0200\n+++ /tmp/tmp_zga4v4t.java\t2022-07-12 18:09:21.520784320 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = 1;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "Context.OTHER = context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:09:25.012767479 +0200\n+++ /tmp/tmpifeyz3im.java\t2022-07-12 18:09:25.016767459 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context.OTHER = context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "Context rhsContext = context.OTHER;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:09:28.648749943 +0200\n+++ /tmp/tmpi2h5xo2m.java\t2022-07-12 18:09:28.652749924 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = context.OTHER;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Context rhsContext = p;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-123/src/com/google/javascript/jscomp/CodeGenerator.java\t2022-07-12 18:10:17.944511917 +0200\n+++ /tmp/tmpkvc5vj8q.java\t2022-07-12 18:10:17.944511917 +0200\n@@ -280,11 +280,11 @@\n       }\n \n       case Token.HOOK: {\n         Preconditions.checkState(childCount == 3);\n         int p = NodeUtil.precedence(type);\n-        Context rhsContext = Context.OTHER;\n+Context rhsContext = p;\n         addExpr(first, p + 1, context);\n         cc.addOp(\"?\", true);\n         addExpr(first.getNext(), 1, rhsContext);\n         cc.addOp(\":\", true);\n         addExpr(last, 1, rhsContext);\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "Context rhsContext = Context.OTHER;",
        "fixed_line": "Context rhsContext = getContextForNoInOperator(context);"
    },
    "Jsoup-27": {
        "fixes": [
            {
                "k": 1,
                "patch": "return newmColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:21.784493355 +0200\n+++ /tmp/tmpwao9l1jk.java\t2022-07-12 18:10:21.800493279 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newmColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "return newm = charset;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:23.920483029 +0200\n+++ /tmp/tmp102h7kju.java\t2022-07-12 18:10:23.920483029 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = charset;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "return notify;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:25.588474965 +0200\n+++ /tmp/tmpr6xckv98.java\t2022-07-12 18:10:25.588474965 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return notify;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return newmillis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:27.188467229 +0200\n+++ /tmp/tmpnffr6q16.java\t2022-07-12 18:10:27.188467229 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newmillis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return newm = new.util.mColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:28.812459376 +0200\n+++ /tmp/tmp0sfdmpr6.java\t2022-07-12 18:10:28.812459376 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.mColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "return new.util.mColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:30.324452065 +0200\n+++ /tmp/tmpz0c9otih.java\t2022-07-12 18:10:30.324452065 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return new.util.mColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "return newm = new.util.millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:31.800444927 +0200\n+++ /tmp/tmp0b83lbng.java\t2022-07-12 18:10:31.804444908 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.millis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "return newm = newmColon;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:33.332437519 +0200\n+++ /tmp/tmp2u8b578s.java\t2022-07-12 18:10:33.332437519 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = newmColon;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "return new.util.millis;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:34.980429548 +0200\n+++ /tmp/tmpoagr8k82.java\t2022-07-12 18:10:34.980429548 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return new.util.millis;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return newm = new.util.millisecond;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Jsoup-27/src/main/java/org/jsoup/helper/DataUtil.java\t2022-07-12 18:10:36.548421964 +0200\n+++ /tmp/tmpffxthsri.java\t2022-07-12 18:10:36.548421964 +0200\n@@ -128,11 +128,11 @@\n         if (contentType == null) return null;\n         Matcher m = charsetPattern.matcher(contentType);\n         if (m.find()) {\n             String charset = m.group(1).trim();\n             charset = charset.toUpperCase(Locale.ENGLISH);\n-            return charset;\n+return newm = new.util.millisecond;\n         }\n         return null;\n     }\n     \n     \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "return charset;",
        "fixed_line": "if (Charset.isSupported(charset)) return charset; charset = charset.toUpperCase(Locale.ENGLISH); if (Charset.isSupported(charset)) return charset;"
    },
    "Math-8": {
        "fixes": [
            {
                "k": 1,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_PER_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:38.296413508 +0200\n+++ /tmp/tmpc7kajiql.java\t2022-07-12 18:10:38.348413260 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_PER_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "public T[] sampleSize = this.numberOfStricts;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:41.260399170 +0200\n+++ /tmp/tmpsidp1a_n.java\t2022-07-12 18:10:41.260399170 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.numberOfStricts;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "public T[] sampleSize = this.fixedStricts;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:43.336389127 +0200\n+++ /tmp/tmpfvd3kgra.java\t2022-07-12 18:10:43.336389127 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.fixedStricts;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:45.424379024 +0200\n+++ /tmp/tmpdf9fh7up.java\t2022-07-12 18:10:45.424379024 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "public T[] sampleSize = this.numberOfArgsPositiveException;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:47.584368573 +0200\n+++ /tmp/tmpolujxib_.java\t2022-07-12 18:10:47.584368573 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.numberOfArgsPositiveException;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_MONTH;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:49.644358603 +0200\n+++ /tmp/tmpzmg4ii4q.java\t2022-07-12 18:10:49.648358584 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_EXTENDED_OF_MONTH;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "public T[] sampleSize = this.fontSize;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:51.700348654 +0200\n+++ /tmp/tmpaum1vdyr.java\t2022-07-12 18:10:51.700348654 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.fontSize;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "public T[] sampleSize = this.year;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:53.724338857 +0200\n+++ /tmp/tmpfms4s680.java\t2022-07-12 18:10:53.728338838 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.year;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_WEEK;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:55.744329081 +0200\n+++ /tmp/tmptghh29dc.java\t2022-07-12 18:10:55.744329081 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = new NotStrictlyPositiveException(Constants.MILLIS_OF_DAYS_OUT_OF_WEEK;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "public T[] sampleSize = this.serialDate;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-8/src/main/java/org/apache/commons/math3/distribution/DiscreteDistribution.java\t2022-07-12 18:10:57.708319573 +0200\n+++ /tmp/tmp65e2ifyn.java\t2022-07-12 18:10:57.708319573 +0200\n@@ -176,17 +176,11 @@\n      * @param sampleSize the number of random values to generate.\n      * @return an array representing the random sample.\n      * @throws NotStrictlyPositiveException if {@code sampleSize} is not\n      * positive.\n      */\n-    public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n-        if (sampleSize <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n-                    sampleSize);\n-        }\n-\n-        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n+public T[] sampleSize = this.serialDate;\n \n         for (int i = 0; i < sampleSize; i++) {\n             out[i] = sample();\n         }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);",
        "fixed_line": "public Object[] sample(int sampleSize) throws NotStrictlyPositiveException { if (sampleSize <= 0) { throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, sampleSize); } final Object[] out = new Object[sampleSize];"
    },
    "Gson-14": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound };",
                "patch_diff": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound };",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound };",
                "patch_diff": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound };",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "private static WildcardType typeBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound };",
                "patch_diff": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound };",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "private static WildcardType[] upperBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static WildcardType supertype = new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "private static WildcardType supertype = new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "patch_diff": "Type Type[] upperBounds = new Type[] { bound }; return new Type[] { bound }; return new Type[] { bound }; }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (bound instanceof WildcardType) { upperBounds = ((WildcardType) bound).getUpperBounds(); } else { upperBounds = new Type[] { bound }; } return new WildcardTypeImpl(upperBounds, EMPTY_TYPE_ARRAY); } /** * Returns a type that represents an unknown supertype of {@code bound}. For * example, if {@code bound} is {@code String.class}, this returns {@code ? * super String}. */ public static WildcardType supertypeOf(Type bound) { Type[] lowerBounds; if (bound instanceof WildcardType) { lowerBounds = ((WildcardType) bound).getLowerBounds(); } else { lowerBounds = new Type[] { bound }; }"
    },
    "Closure-22": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (ancestor.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:01.500301218 +0200\n+++ /tmp/tmp17t1asq_.java\t2022-07-12 18:11:01.544301005 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (ancestor.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:06.576276639 +0200\n+++ /tmp/tmpobzyakam.java\t2022-07-12 18:11:06.576276639 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.GETPROP) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (ancestorType == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:10.356258335 +0200\n+++ /tmp/tmpx_43p29b.java\t2022-07-12 18:11:10.356258335 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestorType == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (type == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:14.196239737 +0200\n+++ /tmp/tmpfk18wtnd.java\t2022-07-12 18:11:14.200239717 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (type == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (gramps.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:17.924221677 +0200\n+++ /tmp/tmp9jxugiib.java\t2022-07-12 18:11:17.924221677 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (gramps.getType() == Token.GETPROP) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:21.388204896 +0200\n+++ /tmp/tmplhmp9rbz.java\t2022-07-12 18:11:21.392204877 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.GETPROP) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (ancestor.getType() == Token.COMMA) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:25.008187357 +0200\n+++ /tmp/tmpd7ltgozq.java\t2022-07-12 18:11:25.008187357 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (ancestor.getType() == Token.COMMA) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (thenOp.getType() == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:28.676169583 +0200\n+++ /tmp/tmpz13qedpe.java\t2022-07-12 18:11:28.676169583 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (thenOp.getType() == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (parent.getType == Token.ASSIGN) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:32.368151689 +0200\n+++ /tmp/tmpf_8r9608.java\t2022-07-12 18:11:32.372151669 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (parent.getType == Token.ASSIGN) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (gramps.getType() == Token.COMMA) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-22/src/com/google/javascript/jscomp/CheckSideEffects.java\t2022-07-12 18:11:36.368132301 +0200\n+++ /tmp/tmpq5zo5gmz.java\t2022-07-12 18:11:36.368132301 +0200\n@@ -96,48 +96,11 @@\n     }\n \n     // Do not try to remove a block or an expr result. We already handle\n     // these cases when we visit the child, and the peephole passes will\n     // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n-\n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n-            return;\n-          else\n-            break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n-\n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n+if (gramps.getType() == Token.COMMA) {\n       String msg = \"This code lacks side-effects. Is there a bug?\";\n       if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n       } else if (isSimpleOp) {\n         msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (parent.getType() == Token.COMMA) { Node gramps = parent.getParent(); if (gramps.isCall() && parent == gramps.getFirstChild()) { if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) { return; } } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n == parent.getLastChild()) { for (Node an : parent.getAncestors()) { int ancestorType = an.getType(); if (ancestorType == Token.COMMA) continue; if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return; else break; } } } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) { if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())) { } else { return; } } boolean isResultUsed = NodeUtil.isExpressionResultUsed(n); boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType()); if (!isResultUsed && (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) { if (n.isQualifiedName() && n.getJSDocInfo() != null) { return; } else if (n.isExprResult()) { return; }",
        "fixed_line": "if (n.isExprResult() || n.isBlock()) { return; } // This no-op statement was there so that JSDoc information could // be attached to the name. This check should not complain about it. if (n.isQualifiedName() && n.getJSDocInfo() != null) {"
    },
    "Math-87": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (i.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:40.432112603 +0200\n+++ /tmp/tmpgg_lljrk.java\t2022-07-12 18:11:40.512112215 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (i.equals(endIndex, 0.0, col, col) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:43.100099666 +0200\n+++ /tmp/tmp8jvp7433.java\t2022-07-12 18:11:43.100099666 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (calendar.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:45.240089289 +0200\n+++ /tmp/tmpp6viu_g_.java\t2022-07-12 18:11:45.240089289 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (calendar.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (i.equals(row, col), 0.0, column)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:47.232079629 +0200\n+++ /tmp/tmpp8s7j_1r.java\t2022-07-12 18:11:47.232079629 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(row, col), 0.0, column)) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (i.equals(endIndex, 0.0, col, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:49.432068961 +0200\n+++ /tmp/tmp0_5kfrzo.java\t2022-07-12 18:11:49.436068942 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (i.equals(subMatrix, col), 0.0, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:51.460059126 +0200\n+++ /tmp/tmpup2nrpae.java\t2022-07-12 18:11:51.464059107 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(subMatrix, col), 0.0, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (i.equals(endIndex, 0.0, col, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:53.688048319 +0200\n+++ /tmp/tmpmrx9z769.java\t2022-07-12 18:11:53.692048300 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (i.equals(endIndex, 0.0, col, column)) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:55.836037902 +0200\n+++ /tmp/tmptduqty2x.java\t2022-07-12 18:11:55.840037883 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(endIndex, 0.0, col, column)) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (row.equals(endIndex, 0.0, col, col = 0;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:11:58.212026374 +0200\n+++ /tmp/tmppqxp6hs4.java\t2022-07-12 18:11:58.212026374 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (row.equals(endIndex, 0.0, col, col = 0;\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (i.equals(value, col), 0.0, null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Math-87/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\t2022-07-12 18:12:00.272016382 +0200\n+++ /tmp/tmpw5qsmdz5.java\t2022-07-12 18:12:00.272016382 +0200\n@@ -270,16 +270,11 @@\n      * @return the row that the variable is basic in.  null if the column is not basic\n      */\n     private Integer getBasicRow(final int col) {\n         Integer row = null;\n         for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n-            if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n-                if (row == null) {\n-                row = i;\n-                } else {\n-                return null;\n-                }\n+if (i.equals(value, col), 0.0, null) {\n             }\n         }\n         return row;\n     }\n \n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) { if (row == null) { row = i; } else { return null; }",
        "fixed_line": "if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) { row = i; } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {"
    },
    "Lang-42": {
        "fixes": [
            {
                "k": 1,
                "patch": "char c = str.charAt(i;",
                "patch_diff": "char c = str.charAt(i;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "char c = str.charAt(i); String entityName = this.entityName == null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "char c = str.charAt(i); String entityName = this.entityName!= null) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName!= null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "char c = str.charAt(i; ++i) {",
                "patch_diff": "char c = str.charAt(i; ++i) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "char c = str.charAt(i; if (entity == null) {",
                "patch_diff": "char c = str.charAt(i; if (entity == null) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (i > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (i > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "char c = str.charAt(i); String entityName = this.entityName!= null) { if (i > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName!= null) { if (i > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "char c = str.charAt(i); String entityName = this.entityName == null) { if (i > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName == null) { if (i > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "char c = str.charAt(i); String entityName = this.entityName; if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName; if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "char c = str.charAt(i); String entityName = this.entityName(c); if (c > 0x7F) {",
                "patch_diff": "char c = str.charAt(i); String entityName = this.entityName(c); if (c > 0x7F) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "char c = str.charAt(i); String entityName = this.entityName(c); if (entityName == null) { if (c > 0x7F) {",
        "fixed_line": "int c = Character.codePointAt(str, i); String entityName = this.entityName(c); if (entityName == null) { if (c >= 0x010000 && i < len - 1) { writer.write(\"&#\"); writer.write(Integer.toString(c, 10)); writer.write(';'); i++; } else if (c > 0x7F) {"
    },
    "JacksonDatabind-101": {
        "fixes": [
            {
                "k": 1,
                "patch": "private static final /*day*/int[] p.nextToken = JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:03.731999595 +0200\n+++ /tmp/tmpl7wl7lu0.java\t2022-07-12 18:12:03.791999304 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken = JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "private static final /*day*/int[] items = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:05.803989541 +0200\n+++ /tmp/tmp_s4wqy2b.java\t2022-07-12 18:12:05.807989521 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "private static final /*day*/int[] EASTER = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:07.487981371 +0200\n+++ /tmp/tmpswz2egt7.java\t2022-07-12 18:12:07.487981371 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] EASTER = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "private static final /*day*/int[] p.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:09.219972966 +0200\n+++ /tmp/tmpa6e6nl03.java\t2022-07-12 18:12:09.219972966 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "private static final /*day*/int[] p.nextToken!= JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:10.843965085 +0200\n+++ /tmp/tmp19r_oqie.java\t2022-07-12 18:12:10.847965066 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken!= JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "p.nextToken = JsonToken.END_ARRAY;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:12.419957437 +0200\n+++ /tmp/tmptbx_n6vy.java\t2022-07-12 18:12:12.423957418 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+p.nextToken = JsonToken.END_ARRAY;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "private static final /*day*/int[] items = this.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:14.519947246 +0200\n+++ /tmp/tmpbpnuphzh.java\t2022-07-12 18:12:14.523947227 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = this.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "private static final /*day*/int[] EASTER = this.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:16.115939499 +0200\n+++ /tmp/tmp696uwe49.java\t2022-07-12 18:12:16.115939499 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] EASTER = this.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "private static final /*day*/int[] items = _beanType.nextToken;",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:17.619932199 +0200\n+++ /tmp/tmpjrr38mr_.java\t2022-07-12 18:12:17.619932199 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] items = _beanType.nextToken;\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "private static final /*day*/int[] p.nextToken = _beanType.nextToken();",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/JacksonDatabind-101/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\t2022-07-12 18:12:19.199924530 +0200\n+++ /tmp/tmpkthtm5mn.java\t2022-07-12 18:12:19.199924530 +0200\n@@ -766,11 +766,11 @@\n                     // [databind#631]: Assign current value, to be accessible by custom serializers\n                     p.setCurrentValue(bean);\n                     // if so, need to copy all remaining tokens into buffer\n                     while (t == JsonToken.FIELD_NAME) {\n                         // NOTE: do NOT skip name as it needs to be copied; `copyCurrentStructure` does that\n-                        p.nextToken();\n+private static final /*day*/int[] p.nextToken = _beanType.nextToken();\n                         tokens.copyCurrentStructure(p);\n                         t = p.nextToken();\n                     }\n                     // 28-Aug-2018, tatu: Let's add sanity check here, easier to catch off-by-some\n                     //    problems if we maintain invariants\n",
                "comp_execute": true,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "p.nextToken();",
        "fixed_line": "if (t != JsonToken.END_OBJECT) { ctxt.reportWrongTokenException(this, JsonToken.END_OBJECT, \"Attempted to unwrap '%s' value\", handledType().getName()); }"
    },
    "JacksonDatabind-19": {
        "fixes": [
            {
                "k": 1,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class);",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "JavaType[] typeParams = findTypeParameters(typeParams, Map.class);",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(typeParams, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class) {",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class,",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class,",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "JavaType[] typeParams = findTypeParameters;",
                "patch_diff": "JavaType[] typeParams = findTypeParameters;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class;",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class;",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class, typeParams);",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class, typeParams);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, typeParams, Map.class);",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, typeParams, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types are",
                "patch_diff": "JavaType[] typeParams = findTypeParameters(rawClass, Map.class); // ok to have no types are",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "JavaType typeParams = findTypeParameters(rawClass, Map.class);",
                "patch_diff": "JavaType typeParams = findTypeParameters(rawClass, Map.class);",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "if (rawClass == Properties.class) { return MapType.construct(rawClass, CORE_TYPE_STRING, CORE_TYPE_STRING); }"
    },
    "Mockito-18": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (type == Set.class) {",
                "patch_diff": "if (type == Set.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (type == Set.class) { return new HashSet<Object>(); }",
                "patch_diff": "if (type == Set.class) { return new HashSet<Object>(); }",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Type.class) {",
                "patch_diff": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "return new LinkedList<Object>(); } else if (type == Type.class) {",
                "patch_diff": "return new LinkedList<Object>(); } else if (type == Type.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "return new LinkedList<Object>(); } else if (type == Long.class) {",
                "patch_diff": "return new LinkedList<Object>(); } else if (type == Long.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Long.class) {",
                "patch_diff": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Long.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (type == Collection.class) {",
                "patch_diff": "if (type == Collection.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "} else if (type == Set.class) {",
                "patch_diff": "} else if (type == Set.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Collection.class) {",
                "patch_diff": "if (type == Set.class) { return new HashSet<Object>(); } else if (type == Collection.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "return new LinkedList<Object>(); } else if (type == Collection.class) {",
                "patch_diff": "return new LinkedList<Object>(); } else if (type == Collection.class) {",
                "comp_execute": false,
                "comp_pass": false,
                "test_execute": false,
                "test_pass": false
            }
        ],
        "buggy_line": "",
        "fixed_line": "} else if (type == Iterable.class) { return new ArrayList<Object>(0);"
    },
    "Closure-20": {
        "fixes": [
            {
                "k": 1,
                "patch": "if (value == null) { // block only override if more specific",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:12:24.759897538 +0200\n+++ /tmp/tmp_xn9z2_m.java\t2022-07-12 18:12:24.819897247 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block only override if more specific\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 2,
                "patch": "if (value == null) { // block == null; can't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:13:08.307685975 +0200\n+++ /tmp/tmp3yur08v9.java\t2022-07-12 18:13:08.311685956 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not use a native function.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 3,
                "patch": "if (value == null) { // block == null; can't be null if we're not.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:13:48.139492235 +0200\n+++ /tmp/tmpx9hddk31.java\t2022-07-12 18:13:48.143492216 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we're not.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 4,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:14:27.435300904 +0200\n+++ /tmp/tmpn396xut4.java\t2022-07-12 18:14:27.435300904 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 5,
                "patch": "if (value == null) { // block == null; can't find",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:15:07.251106858 +0200\n+++ /tmp/tmpedwbq8hv.java\t2022-07-12 18:15:07.251106858 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't find\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 6,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-parse",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:15:47.030912809 +0200\n+++ /tmp/tmp1jyu39te.java\t2022-07-12 18:15:47.030912809 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-parse\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 7,
                "patch": "if (value == null) { // block == null; can't really modify it's do implicit re-initialized (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:16:27.142716982 +0200\n+++ /tmp/tmp5dmdbasc.java\t2022-07-12 18:16:27.142716982 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really modify it's do implicit re-initialized (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 8,
                "patch": "if (value == null) { // block == null; can't be null if we't be null if we're not use a native function.",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:17:06.474524816 +0200\n+++ /tmp/tmpopq10nue.java\t2022-07-12 18:17:06.474524816 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we't be null if we're not use a native function.\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 9,
                "patch": "if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized or EMPTY",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:17:45.518333926 +0200\n+++ /tmp/tmpbwtvjri3.java\t2022-07-12 18:17:45.522333906 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't be null if we't really modify it's do implicit re-initialized or EMPTY\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            },
            {
                "k": 10,
                "patch": "if (value == null) { // block == null; can't really here here (value!= null) {",
                "patch_diff": "--- /mnt/data/andre/mscthesis/storage_for_selfapr_models/defects4j/Closure-20/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\t2022-07-12 18:18:25.518138233 +0200\n+++ /tmp/tmpc1i1yfce.java\t2022-07-12 18:18:25.518138233 +0200\n@@ -215,11 +215,11 @@\n       //\n       // We can't do this in the general case, because String(a) has\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+if (value == null) { // block == null; can't really here here (value!= null) {\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());\n         n.getParent().replaceChild(n, addition);\n         reportCodeChange();\n",
                "comp_execute": true,
                "comp_pass": true,
                "test_execute": true,
                "test_pass": false
            }
        ],
        "buggy_line": "if (value != null) {",
        "fixed_line": "if (value != null && value.getNext() == null && NodeUtil.isImmutableValue(value)) {"
    }
}